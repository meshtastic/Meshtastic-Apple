// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Payload Variant
  var payloadVariant: Config.OneOf_PayloadVariant? = nil

  var device: Config.DeviceConfig {
    get {
      if case .device(let v)? = payloadVariant {return v}
      return Config.DeviceConfig()
    }
    set {payloadVariant = .device(newValue)}
  }

  var position: Config.PositionConfig {
    get {
      if case .position(let v)? = payloadVariant {return v}
      return Config.PositionConfig()
    }
    set {payloadVariant = .position(newValue)}
  }

  var power: Config.PowerConfig {
    get {
      if case .power(let v)? = payloadVariant {return v}
      return Config.PowerConfig()
    }
    set {payloadVariant = .power(newValue)}
  }

  var network: Config.NetworkConfig {
    get {
      if case .network(let v)? = payloadVariant {return v}
      return Config.NetworkConfig()
    }
    set {payloadVariant = .network(newValue)}
  }

  var display: Config.DisplayConfig {
    get {
      if case .display(let v)? = payloadVariant {return v}
      return Config.DisplayConfig()
    }
    set {payloadVariant = .display(newValue)}
  }

  var lora: Config.LoRaConfig {
    get {
      if case .lora(let v)? = payloadVariant {return v}
      return Config.LoRaConfig()
    }
    set {payloadVariant = .lora(newValue)}
  }

  var bluetooth: Config.BluetoothConfig {
    get {
      if case .bluetooth(let v)? = payloadVariant {return v}
      return Config.BluetoothConfig()
    }
    set {payloadVariant = .bluetooth(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Payload Variant
  enum OneOf_PayloadVariant: Equatable {
    case device(Config.DeviceConfig)
    case position(Config.PositionConfig)
    case power(Config.PowerConfig)
    case network(Config.NetworkConfig)
    case display(Config.DisplayConfig)
    case lora(Config.LoRaConfig)
    case bluetooth(Config.BluetoothConfig)

  #if !swift(>=4.1)
    static func ==(lhs: Config.OneOf_PayloadVariant, rhs: Config.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.device, .device): return {
        guard case .device(let l) = lhs, case .device(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.power, .power): return {
        guard case .power(let l) = lhs, case .power(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.network, .network): return {
        guard case .network(let l) = lhs, case .network(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.display, .display): return {
        guard case .display(let l) = lhs, case .display(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lora, .lora): return {
        guard case .lora(let l) = lhs, case .lora(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bluetooth, .bluetooth): return {
        guard case .bluetooth(let l) = lhs, case .bluetooth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// Configuration
  struct DeviceConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Sets the role of node
    var role: Config.DeviceConfig.Role = .client

    ///
    /// Disabling this will disable the SerialConsole by not initilizing the StreamAPI
    var serialEnabled: Bool = false

    ///
    /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
    /// Set this to true to leave the debug log outputting even when API is active.
    var debugLogEnabled: Bool = false

    ///
    /// For boards without a hard wired button, this is the pin number that will be used
    /// Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
    var buttonGpio: UInt32 = 0

    ///
    /// For boards without a PWM buzzer, this is the pin number that will be used
    /// Defaults to PIN_BUZZER if defined.
    var buzzerGpio: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Defines the device's role on the Mesh network
    enum Role: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Client device role
      case client // = 0

      ///
      /// Client Mute device role
      ///   Same as a client except packets will not hop over this node, does not contribute to routing packets for mesh.
      case clientMute // = 1

      ///
      /// Router device role.
      ///   Mesh packets will prefer to be routed over this node. This node will not be used by client apps. 
      ///   The wifi/ble radios and the oled screen will be put to sleep.
      case router // = 2

      ///
      /// Router Client device role
      ///   Mesh packets will prefer to be routed over this node. The Router Client can be used as both a Router and an app connected Client.
      case routerClient // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .client
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .client
        case 1: self = .clientMute
        case 2: self = .router
        case 3: self = .routerClient
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .client: return 0
        case .clientMute: return 1
        case .router: return 2
        case .routerClient: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  ///
  /// Position Config
  struct PositionConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// We should send our position this often (but only if it has changed significantly)
    /// Defaults to 15 minutes
    var positionBroadcastSecs: UInt32 = 0

    ///
    /// Adaptive position braoadcast, which is now the default.
    var positionBroadcastSmartEnabled: Bool = false

    ///
    /// If set, this node is at a fixed position.
    /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
    /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
    var fixedPosition: Bool = false

    ///
    /// Is GPS enabled for this node?
    var gpsEnabled: Bool = false

    ///
    /// How often should we try to get GPS position (in seconds)
    /// or zero for the default of once every 30 seconds
    /// or a very large value (maxint) to update only once at boot.
    var gpsUpdateInterval: UInt32 = 0

    ///
    /// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
    /// Or if zero, use the default of 30 seconds.
    /// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
    /// window.
    var gpsAttemptTime: UInt32 = 0

    ///
    /// Bit field of boolean configuration options for POSITION messages
    /// (bitwise OR of PositionFlags)
    var positionFlags: UInt32 = 0

    ///
    /// (Re)define GPS_RX_PIN for your board.
    var rxGpio: UInt32 = 0

    ///
    /// (Re)define GPS_TX_PIN for your board.
    var txGpio: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Bit field of boolean configuration options, indicating which optional
    ///   fields to include when assembling POSITION messages
    /// Longitude and latitude are always included (also time if GPS-synced)
    /// NOTE: the more fields are included, the larger the message will be -
    ///   leading to longer airtime and a higher risk of packet loss
    enum PositionFlags: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Required for compilation
      case unset // = 0

      ///
      /// Include an altitude value (if available)
      case altitude // = 1

      ///
      /// Altitude value is MSL
      case altitudeMsl // = 2

      ///
      /// Include geoidal separation
      case geoidalSeparation // = 4

      ///
      /// Include the DOP value ; PDOP used by default, see below
      case dop // = 8

      ///
      /// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
      case hvdop // = 16

      ///
      /// Include number of "satellites in view"
      case satinview // = 32

      ///
      /// Include a sequence number incremented per packet
      case seqNo // = 64

      ///
      /// Include positional timestamp (from GPS solution)
      case timestamp // = 128

      ///
      /// Include positional heading
      /// Intended for use with vehicle not walking speeds
      /// walking speeds are likely to be error prone like the compass
      case heading // = 256

      ///
      /// Include positional speed
      /// Intended for use with vehicle not walking speeds
      /// walking speeds are likely to be error prone like the compass
      case speed // = 512
      case UNRECOGNIZED(Int)

      init() {
        self = .unset
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .altitude
        case 2: self = .altitudeMsl
        case 4: self = .geoidalSeparation
        case 8: self = .dop
        case 16: self = .hvdop
        case 32: self = .satinview
        case 64: self = .seqNo
        case 128: self = .timestamp
        case 256: self = .heading
        case 512: self = .speed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unset: return 0
        case .altitude: return 1
        case .altitudeMsl: return 2
        case .geoidalSeparation: return 4
        case .dop: return 8
        case .hvdop: return 16
        case .satinview: return 32
        case .seqNo: return 64
        case .timestamp: return 128
        case .heading: return 256
        case .speed: return 512
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  ///
  /// Power Config\
  /// See [Power Config](/docs/settings/config/power) for additional power config details.
  struct PowerConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
    /// we should try to minimize power consumption as much as possible.
    /// YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
    /// Advanced Option
    var isPowerSaving: Bool = false

    ///
    /// If non-zero, the device will fully power off this many seconds after external power is removed.
    var onBatteryShutdownAfterSecs: UInt32 = 0

    ///
    /// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
    /// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
    /// Should be set to floating point value between 2 and 4
    /// Fixes issues on Heltec v2
    var adcMultiplierOverride: Float = 0

    ///
    /// Wait Bluetooth Seconds
    /// The number of seconds for to wait before turning off BLE in No Bluetooth states
    /// 0 for default of 1 minute
    var waitBluetoothSecs: UInt32 = 0

    ///
    /// Mesh Super Deep Sleep Timeout Seconds
    /// While in Light Sleep if this value is exceeded we will lower into super deep sleep 
    /// for sds_secs (default 1 year) or a button press
    /// 0 for default of two hours, MAXUINT for disabled
    var meshSdsTimeoutSecs: UInt32 = 0

    ///
    /// Super Deep Sleep Seconds
    /// While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
    /// for this value (default 1 year) or a button press
    /// 0 for default of one year
    var sdsSecs: UInt32 = 0

    ///
    /// Light Sleep Seconds
    /// In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
    /// ESP32 Only
    /// 0 for default of 300
    var lsSecs: UInt32 = 0

    ///
    /// Minimum Wake Seconds
    /// While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
    /// 0 for default of 10 seconds
    var minWakeSecs: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Network Config
  struct NetworkConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable WiFi (disables Bluetooth)
    var wifiEnabled: Bool = false

    ///
    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    var wifiSsid: String = String()

    ///
    /// If set, will be use to authenticate to the named wifi
    var wifiPsk: String = String()

    ///
    /// NTP server to use if WiFi is conneced, defaults to `0.pool.ntp.org`
    var ntpServer: String = String()

    ///
    /// Enable Ethernet
    var ethEnabled: Bool = false

    ///
    /// acquire an address via DHCP or assign static
    var ethMode: Config.NetworkConfig.EthMode = .dhcp

    ///
    /// struct to keep static address
    var ipv4Config: Config.NetworkConfig.IpV4Config {
      get {return _ipv4Config ?? Config.NetworkConfig.IpV4Config()}
      set {_ipv4Config = newValue}
    }
    /// Returns true if `ipv4Config` has been explicitly set.
    var hasIpv4Config: Bool {return self._ipv4Config != nil}
    /// Clears the value of `ipv4Config`. Subsequent reads from it will return its default value.
    mutating func clearIpv4Config() {self._ipv4Config = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum EthMode: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// obtain ip address via DHCP
      case dhcp // = 0

      ///
      /// use static ip address
      case `static` // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .dhcp
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dhcp
        case 1: self = .static
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .dhcp: return 0
        case .static: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    struct IpV4Config {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///
      /// Static IP address
      var ip: UInt32 = 0

      ///
      /// Static gateway address
      var gateway: UInt32 = 0

      ///
      /// Static subnet mask
      var subnet: UInt32 = 0

      ///
      /// Static DNS server address
      var dns: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _ipv4Config: Config.NetworkConfig.IpV4Config? = nil
  }

  ///
  /// Display Config
  struct DisplayConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Number of seconds the screen stays on after pressing the user button or receiving a message
    /// 0 for default of one minute MAXUINT for always on
    var screenOnSecs: UInt32 = 0

    ///
    /// How the GPS coordinates are formatted on the OLED screen.
    var gpsFormat: Config.DisplayConfig.GpsCoordinateFormat = .dec

    ///
    /// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
    /// Potentially useful for devices without user buttons.
    var autoScreenCarouselSecs: UInt32 = 0

    ///
    /// If this is set, the displayed compass will always point north. if unset, the old behaviour 
    /// (top of display is heading direction) is used.
    var compassNorthTop: Bool = false

    ///
    /// Flip screen vertically, for cases that mount the screen upside down
    var flipScreen: Bool = false

    ///
    /// Perferred display units
    var units: Config.DisplayConfig.DisplayUnits = .metric

    ///
    /// Override auto-detect in screen
    var oled: Config.DisplayConfig.OledType = .oledAuto

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// How the GPS coordinates are displayed on the OLED screen.
    enum GpsCoordinateFormat: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// GPS coordinates are displayed in the normal decimal degrees format:
      /// DD.DDDDDD DDD.DDDDDD
      case dec // = 0

      ///
      /// GPS coordinates are displayed in the degrees minutes seconds format:
      /// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
      case dms // = 1

      ///
      /// Universal Transverse Mercator format:
      /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
      case utm // = 2

      ///
      /// Military Grid Reference System format:
      /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
      /// E is easting, N is northing
      case mgrs // = 3

      ///
      /// Open Location Code (aka Plus Codes).
      case olc // = 4

      ///
      /// Ordnance Survey Grid Reference (the National Grid System of the UK).
      /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
      /// E is the easting, N is the northing
      case osgr // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .dec
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dec
        case 1: self = .dms
        case 2: self = .utm
        case 3: self = .mgrs
        case 4: self = .olc
        case 5: self = .osgr
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .dec: return 0
        case .dms: return 1
        case .utm: return 2
        case .mgrs: return 3
        case .olc: return 4
        case .osgr: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// Unit display preference
    enum DisplayUnits: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Metric (Default)
      case metric // = 0

      ///
      /// Imperial
      case imperial // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .metric
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .metric
        case 1: self = .imperial
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .metric: return 0
        case .imperial: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// Override OLED outo detect with this if it fails.
    enum OledType: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Default / Auto
      case oledAuto // = 0

      ///
      /// Default / Auto
      case oledSsd1306 // = 1

      ///
      /// Default / Auto
      case oledSh1106 // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .oledAuto
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .oledAuto
        case 1: self = .oledSsd1306
        case 2: self = .oledSh1106
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .oledAuto: return 0
        case .oledSsd1306: return 1
        case .oledSh1106: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  ///
  /// Lora Config
  struct LoRaConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// When enabled, the `modem_preset` fields will be adheared to, else the `bandwidth`/`spread_factor`/`coding_rate`
    /// will be taked from their respective manually defined fields
    var usePreset: Bool = false

    ///
    /// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
    /// As a heuristic: If bandwidth is specified, do not use modem_config.
    /// Because protobufs take ZERO space when the value is zero this works out nicely.
    /// This value is replaced by bandwidth/spread_factor/coding_rate.
    /// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
    var modemPreset: Config.LoRaConfig.ModemPreset = .longFast

    ///
    /// Bandwidth in MHz
    /// Certain bandwidth numbers are 'special' and will be converted to the
    /// appropriate floating point value: 31 -> 31.25MHz
    var bandwidth: UInt32 = 0

    ///
    /// A number from 7 to 12.
    /// Indicates number of chirps per symbol as 1<<spread_factor.
    var spreadFactor: UInt32 = 0

    ///
    /// The denominator of the coding rate.
    /// ie for 4/5, the value is 5. 4/8 the value is 8.
    var codingRate: UInt32 = 0

    ///
    /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
    /// A frequency offset that is added to to the calculated band center frequency.
    /// Used to correct for crystal calibration errors.
    var frequencyOffset: Float = 0

    ///
    /// The region code for the radio (US, CN, EU433, etc...)
    var region: Config.LoRaConfig.RegionCode = .unset

    ///
    /// Maximum number of hops. This can't be greater than 7.
    /// Default of 3
    var hopLimit: UInt32 = 0

    ///
    /// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
    /// Defaults to false
    var txEnabled: Bool = false

    ///
    /// If zero then, use default max legal continuous power (ie. something that won't
    /// burn out the radio hardware)
    /// In most cases you should use zero here.
    /// Units are in dBm.
    var txPower: Int32 = 0

    ///
    /// This is controlling the actual hardware frequency the radio is transmitting on.
    /// Most users should never need to be exposed to this field/concept.
    /// A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
    /// If ZERO then the rule is "use the old channel name hash based
    /// algorithm to derive the channel number")
    /// If using the hash algorithm the channel number will be: hash(channel_name) %
    /// NUM_CHANNELS (Where num channels depends on the regulatory region).
    var channelNum: UInt32 = 0

    ///
    /// If true, duty cycle limits will be exceeded and thus you're possibly not following 
    /// the local regulations if you're not a HAM.
    /// Has no effect if the duty cycle of the used region is 100%. 
    var overrideDutyCycle: Bool = false

    ///
    /// For testing it is useful sometimes to force a node to never listen to
    /// particular other nodes (simulating radio out of range). All nodenums listed
    /// in ignore_incoming will have packets they send droped on receive (by router.cpp)
    var ignoreIncoming: [UInt32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum RegionCode: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Region is not set
      case unset // = 0

      ///
      /// United States
      case us // = 1

      ///
      /// European Union 433mhz
      case eu433 // = 2

      ///
      /// European Union 433mhz
      case eu868 // = 3

      ///
      /// China
      case cn // = 4

      ///
      /// Japan
      case jp // = 5

      ///
      /// Australia / New Zealand
      case anz // = 6

      ///
      /// Korea
      case kr // = 7

      ///
      /// Taiwan
      case tw // = 8

      ///
      /// Russia
      case ru // = 9

      ///
      /// India
      case `in` // = 10

      ///
      /// New Zealand 865mhz
      case nz865 // = 11

      ///
      /// Thailand
      case th // = 12

      ///
      /// WLAN Band
      case lora24 // = 13
      case UNRECOGNIZED(Int)

      init() {
        self = .unset
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .us
        case 2: self = .eu433
        case 3: self = .eu868
        case 4: self = .cn
        case 5: self = .jp
        case 6: self = .anz
        case 7: self = .kr
        case 8: self = .tw
        case 9: self = .ru
        case 10: self = .in
        case 11: self = .nz865
        case 12: self = .th
        case 13: self = .lora24
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unset: return 0
        case .us: return 1
        case .eu433: return 2
        case .eu868: return 3
        case .cn: return 4
        case .jp: return 5
        case .anz: return 6
        case .kr: return 7
        case .tw: return 8
        case .ru: return 9
        case .in: return 10
        case .nz865: return 11
        case .th: return 12
        case .lora24: return 13
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// Standard predefined channel settings
    /// Note: these mappings must match ModemPreset Choice in the device code.
    enum ModemPreset: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Long Range - Fast
      case longFast // = 0

      ///
      /// Long Range - Slow
      case longSlow // = 1

      ///
      /// Very Long Range - Slow
      case veryLongSlow // = 2

      ///
      /// Medium Range - Slow
      case mediumSlow // = 3

      ///
      /// Medium Range - Fast
      case mediumFast // = 4

      ///
      /// Short Range - Slow
      case shortSlow // = 5

      ///
      /// Short Range - Fast
      case shortFast // = 6
      case UNRECOGNIZED(Int)

      init() {
        self = .longFast
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .longFast
        case 1: self = .longSlow
        case 2: self = .veryLongSlow
        case 3: self = .mediumSlow
        case 4: self = .mediumFast
        case 5: self = .shortSlow
        case 6: self = .shortFast
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .longFast: return 0
        case .longSlow: return 1
        case .veryLongSlow: return 2
        case .mediumSlow: return 3
        case .mediumFast: return 4
        case .shortSlow: return 5
        case .shortFast: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  struct BluetoothConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable Bluetooth on the device
    var enabled: Bool = false

    ///
    /// Determines the pairing strategy for the device
    var mode: Config.BluetoothConfig.PairingMode = .randomPin

    ///
    /// Specified pin for PairingMode.FixedPin
    var fixedPin: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PairingMode: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// Device generates a random pin that will be shown on the screen of the device for pairing
      case randomPin // = 0

      ///
      /// Device requires a specified fixed pin for pairing
      case fixedPin // = 1

      ///
      /// Device requires no pin for pairing
      case noPin // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .randomPin
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .randomPin
        case 1: self = .fixedPin
        case 2: self = .noPin
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .randomPin: return 0
        case .fixedPin: return 1
        case .noPin: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Config.DeviceConfig.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.DeviceConfig.Role] = [
    .client,
    .clientMute,
    .router,
    .routerClient,
  ]
}

extension Config.PositionConfig.PositionFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.PositionConfig.PositionFlags] = [
    .unset,
    .altitude,
    .altitudeMsl,
    .geoidalSeparation,
    .dop,
    .hvdop,
    .satinview,
    .seqNo,
    .timestamp,
    .heading,
    .speed,
  ]
}

extension Config.NetworkConfig.EthMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.NetworkConfig.EthMode] = [
    .dhcp,
    .static,
  ]
}

extension Config.DisplayConfig.GpsCoordinateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.DisplayConfig.GpsCoordinateFormat] = [
    .dec,
    .dms,
    .utm,
    .mgrs,
    .olc,
    .osgr,
  ]
}

extension Config.DisplayConfig.DisplayUnits: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.DisplayConfig.DisplayUnits] = [
    .metric,
    .imperial,
  ]
}

extension Config.DisplayConfig.OledType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.DisplayConfig.OledType] = [
    .oledAuto,
    .oledSsd1306,
    .oledSh1106,
  ]
}

extension Config.LoRaConfig.RegionCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.LoRaConfig.RegionCode] = [
    .unset,
    .us,
    .eu433,
    .eu868,
    .cn,
    .jp,
    .anz,
    .kr,
    .tw,
    .ru,
    .in,
    .nz865,
    .th,
    .lora24,
  ]
}

extension Config.LoRaConfig.ModemPreset: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.LoRaConfig.ModemPreset] = [
    .longFast,
    .longSlow,
    .veryLongSlow,
    .mediumSlow,
    .mediumFast,
    .shortSlow,
    .shortFast,
  ]
}

extension Config.BluetoothConfig.PairingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Config.BluetoothConfig.PairingMode] = [
    .randomPin,
    .fixedPin,
    .noPin,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Config: @unchecked Sendable {}
extension Config.OneOf_PayloadVariant: @unchecked Sendable {}
extension Config.DeviceConfig: @unchecked Sendable {}
extension Config.DeviceConfig.Role: @unchecked Sendable {}
extension Config.PositionConfig: @unchecked Sendable {}
extension Config.PositionConfig.PositionFlags: @unchecked Sendable {}
extension Config.PowerConfig: @unchecked Sendable {}
extension Config.NetworkConfig: @unchecked Sendable {}
extension Config.NetworkConfig.EthMode: @unchecked Sendable {}
extension Config.NetworkConfig.IpV4Config: @unchecked Sendable {}
extension Config.DisplayConfig: @unchecked Sendable {}
extension Config.DisplayConfig.GpsCoordinateFormat: @unchecked Sendable {}
extension Config.DisplayConfig.DisplayUnits: @unchecked Sendable {}
extension Config.DisplayConfig.OledType: @unchecked Sendable {}
extension Config.LoRaConfig: @unchecked Sendable {}
extension Config.LoRaConfig.RegionCode: @unchecked Sendable {}
extension Config.LoRaConfig.ModemPreset: @unchecked Sendable {}
extension Config.BluetoothConfig: @unchecked Sendable {}
extension Config.BluetoothConfig.PairingMode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "position"),
    3: .same(proto: "power"),
    4: .same(proto: "network"),
    5: .same(proto: "display"),
    6: .same(proto: "lora"),
    7: .same(proto: "bluetooth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Config.DeviceConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .device(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .device(v)
        }
      }()
      case 2: try {
        var v: Config.PositionConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .position(v)
        }
      }()
      case 3: try {
        var v: Config.PowerConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .power(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .power(v)
        }
      }()
      case 4: try {
        var v: Config.NetworkConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .network(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .network(v)
        }
      }()
      case 5: try {
        var v: Config.DisplayConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .display(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .display(v)
        }
      }()
      case 6: try {
        var v: Config.LoRaConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .lora(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .lora(v)
        }
      }()
      case 7: try {
        var v: Config.BluetoothConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .bluetooth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .bluetooth(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .device?: try {
      guard case .device(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .power?: try {
      guard case .power(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .network?: try {
      guard case .network(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .display?: try {
      guard case .display(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .lora?: try {
      guard case .lora(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bluetooth?: try {
      guard case .bluetooth(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config, rhs: Config) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".DeviceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .standard(proto: "serial_enabled"),
    3: .standard(proto: "debug_log_enabled"),
    4: .standard(proto: "button_gpio"),
    5: .standard(proto: "buzzer_gpio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.serialEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.debugLogEnabled) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.buttonGpio) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.buzzerGpio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    if self.serialEnabled != false {
      try visitor.visitSingularBoolField(value: self.serialEnabled, fieldNumber: 2)
    }
    if self.debugLogEnabled != false {
      try visitor.visitSingularBoolField(value: self.debugLogEnabled, fieldNumber: 3)
    }
    if self.buttonGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.buttonGpio, fieldNumber: 4)
    }
    if self.buzzerGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.buzzerGpio, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.DeviceConfig, rhs: Config.DeviceConfig) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.serialEnabled != rhs.serialEnabled {return false}
    if lhs.debugLogEnabled != rhs.debugLogEnabled {return false}
    if lhs.buttonGpio != rhs.buttonGpio {return false}
    if lhs.buzzerGpio != rhs.buzzerGpio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DeviceConfig.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT"),
    1: .same(proto: "CLIENT_MUTE"),
    2: .same(proto: "ROUTER"),
    3: .same(proto: "ROUTER_CLIENT"),
  ]
}

extension Config.PositionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".PositionConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_broadcast_secs"),
    2: .standard(proto: "position_broadcast_smart_enabled"),
    3: .standard(proto: "fixed_position"),
    4: .standard(proto: "gps_enabled"),
    5: .standard(proto: "gps_update_interval"),
    6: .standard(proto: "gps_attempt_time"),
    7: .standard(proto: "position_flags"),
    8: .standard(proto: "rx_gpio"),
    9: .standard(proto: "tx_gpio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.positionBroadcastSecs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.positionBroadcastSmartEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fixedPosition) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.gpsEnabled) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.gpsUpdateInterval) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.gpsAttemptTime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.positionFlags) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.rxGpio) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.txGpio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positionBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionBroadcastSecs, fieldNumber: 1)
    }
    if self.positionBroadcastSmartEnabled != false {
      try visitor.visitSingularBoolField(value: self.positionBroadcastSmartEnabled, fieldNumber: 2)
    }
    if self.fixedPosition != false {
      try visitor.visitSingularBoolField(value: self.fixedPosition, fieldNumber: 3)
    }
    if self.gpsEnabled != false {
      try visitor.visitSingularBoolField(value: self.gpsEnabled, fieldNumber: 4)
    }
    if self.gpsUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsUpdateInterval, fieldNumber: 5)
    }
    if self.gpsAttemptTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsAttemptTime, fieldNumber: 6)
    }
    if self.positionFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionFlags, fieldNumber: 7)
    }
    if self.rxGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxGpio, fieldNumber: 8)
    }
    if self.txGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.txGpio, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.PositionConfig, rhs: Config.PositionConfig) -> Bool {
    if lhs.positionBroadcastSecs != rhs.positionBroadcastSecs {return false}
    if lhs.positionBroadcastSmartEnabled != rhs.positionBroadcastSmartEnabled {return false}
    if lhs.fixedPosition != rhs.fixedPosition {return false}
    if lhs.gpsEnabled != rhs.gpsEnabled {return false}
    if lhs.gpsUpdateInterval != rhs.gpsUpdateInterval {return false}
    if lhs.gpsAttemptTime != rhs.gpsAttemptTime {return false}
    if lhs.positionFlags != rhs.positionFlags {return false}
    if lhs.rxGpio != rhs.rxGpio {return false}
    if lhs.txGpio != rhs.txGpio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.PositionConfig.PositionFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "ALTITUDE"),
    2: .same(proto: "ALTITUDE_MSL"),
    4: .same(proto: "GEOIDAL_SEPARATION"),
    8: .same(proto: "DOP"),
    16: .same(proto: "HVDOP"),
    32: .same(proto: "SATINVIEW"),
    64: .same(proto: "SEQ_NO"),
    128: .same(proto: "TIMESTAMP"),
    256: .same(proto: "HEADING"),
    512: .same(proto: "SPEED"),
  ]
}

extension Config.PowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".PowerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_power_saving"),
    2: .standard(proto: "on_battery_shutdown_after_secs"),
    3: .standard(proto: "adc_multiplier_override"),
    4: .standard(proto: "wait_bluetooth_secs"),
    5: .standard(proto: "mesh_sds_timeout_secs"),
    6: .standard(proto: "sds_secs"),
    7: .standard(proto: "ls_secs"),
    8: .standard(proto: "min_wake_secs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isPowerSaving) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.onBatteryShutdownAfterSecs) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.adcMultiplierOverride) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.waitBluetoothSecs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.meshSdsTimeoutSecs) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.sdsSecs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.lsSecs) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.minWakeSecs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPowerSaving != false {
      try visitor.visitSingularBoolField(value: self.isPowerSaving, fieldNumber: 1)
    }
    if self.onBatteryShutdownAfterSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.onBatteryShutdownAfterSecs, fieldNumber: 2)
    }
    if self.adcMultiplierOverride != 0 {
      try visitor.visitSingularFloatField(value: self.adcMultiplierOverride, fieldNumber: 3)
    }
    if self.waitBluetoothSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.waitBluetoothSecs, fieldNumber: 4)
    }
    if self.meshSdsTimeoutSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.meshSdsTimeoutSecs, fieldNumber: 5)
    }
    if self.sdsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sdsSecs, fieldNumber: 6)
    }
    if self.lsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.lsSecs, fieldNumber: 7)
    }
    if self.minWakeSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minWakeSecs, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.PowerConfig, rhs: Config.PowerConfig) -> Bool {
    if lhs.isPowerSaving != rhs.isPowerSaving {return false}
    if lhs.onBatteryShutdownAfterSecs != rhs.onBatteryShutdownAfterSecs {return false}
    if lhs.adcMultiplierOverride != rhs.adcMultiplierOverride {return false}
    if lhs.waitBluetoothSecs != rhs.waitBluetoothSecs {return false}
    if lhs.meshSdsTimeoutSecs != rhs.meshSdsTimeoutSecs {return false}
    if lhs.sdsSecs != rhs.sdsSecs {return false}
    if lhs.lsSecs != rhs.lsSecs {return false}
    if lhs.minWakeSecs != rhs.minWakeSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".NetworkConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wifi_enabled"),
    3: .standard(proto: "wifi_ssid"),
    4: .standard(proto: "wifi_psk"),
    5: .standard(proto: "ntp_server"),
    6: .standard(proto: "eth_enabled"),
    7: .standard(proto: "eth_mode"),
    8: .standard(proto: "ipv4_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wifiEnabled) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.wifiSsid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.wifiPsk) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ntpServer) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ethEnabled) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.ethMode) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ipv4Config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.wifiEnabled != false {
      try visitor.visitSingularBoolField(value: self.wifiEnabled, fieldNumber: 1)
    }
    if !self.wifiSsid.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiSsid, fieldNumber: 3)
    }
    if !self.wifiPsk.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiPsk, fieldNumber: 4)
    }
    if !self.ntpServer.isEmpty {
      try visitor.visitSingularStringField(value: self.ntpServer, fieldNumber: 5)
    }
    if self.ethEnabled != false {
      try visitor.visitSingularBoolField(value: self.ethEnabled, fieldNumber: 6)
    }
    if self.ethMode != .dhcp {
      try visitor.visitSingularEnumField(value: self.ethMode, fieldNumber: 7)
    }
    try { if let v = self._ipv4Config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.NetworkConfig, rhs: Config.NetworkConfig) -> Bool {
    if lhs.wifiEnabled != rhs.wifiEnabled {return false}
    if lhs.wifiSsid != rhs.wifiSsid {return false}
    if lhs.wifiPsk != rhs.wifiPsk {return false}
    if lhs.ntpServer != rhs.ntpServer {return false}
    if lhs.ethEnabled != rhs.ethEnabled {return false}
    if lhs.ethMode != rhs.ethMode {return false}
    if lhs._ipv4Config != rhs._ipv4Config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.NetworkConfig.EthMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DHCP"),
    1: .same(proto: "STATIC"),
  ]
}

extension Config.NetworkConfig.IpV4Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.NetworkConfig.protoMessageName + ".IpV4Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "gateway"),
    3: .same(proto: "subnet"),
    4: .same(proto: "dns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.gateway) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.subnet) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ip != 0 {
      try visitor.visitSingularFixed32Field(value: self.ip, fieldNumber: 1)
    }
    if self.gateway != 0 {
      try visitor.visitSingularFixed32Field(value: self.gateway, fieldNumber: 2)
    }
    if self.subnet != 0 {
      try visitor.visitSingularFixed32Field(value: self.subnet, fieldNumber: 3)
    }
    if self.dns != 0 {
      try visitor.visitSingularFixed32Field(value: self.dns, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.NetworkConfig.IpV4Config, rhs: Config.NetworkConfig.IpV4Config) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.dns != rhs.dns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DisplayConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".DisplayConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_on_secs"),
    2: .standard(proto: "gps_format"),
    3: .standard(proto: "auto_screen_carousel_secs"),
    4: .standard(proto: "compass_north_top"),
    5: .standard(proto: "flip_screen"),
    6: .same(proto: "units"),
    7: .same(proto: "oled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenOnSecs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gpsFormat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.autoScreenCarouselSecs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.compassNorthTop) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.flipScreen) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.units) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.oled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenOnSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenOnSecs, fieldNumber: 1)
    }
    if self.gpsFormat != .dec {
      try visitor.visitSingularEnumField(value: self.gpsFormat, fieldNumber: 2)
    }
    if self.autoScreenCarouselSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.autoScreenCarouselSecs, fieldNumber: 3)
    }
    if self.compassNorthTop != false {
      try visitor.visitSingularBoolField(value: self.compassNorthTop, fieldNumber: 4)
    }
    if self.flipScreen != false {
      try visitor.visitSingularBoolField(value: self.flipScreen, fieldNumber: 5)
    }
    if self.units != .metric {
      try visitor.visitSingularEnumField(value: self.units, fieldNumber: 6)
    }
    if self.oled != .oledAuto {
      try visitor.visitSingularEnumField(value: self.oled, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.DisplayConfig, rhs: Config.DisplayConfig) -> Bool {
    if lhs.screenOnSecs != rhs.screenOnSecs {return false}
    if lhs.gpsFormat != rhs.gpsFormat {return false}
    if lhs.autoScreenCarouselSecs != rhs.autoScreenCarouselSecs {return false}
    if lhs.compassNorthTop != rhs.compassNorthTop {return false}
    if lhs.flipScreen != rhs.flipScreen {return false}
    if lhs.units != rhs.units {return false}
    if lhs.oled != rhs.oled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DisplayConfig.GpsCoordinateFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEC"),
    1: .same(proto: "DMS"),
    2: .same(proto: "UTM"),
    3: .same(proto: "MGRS"),
    4: .same(proto: "OLC"),
    5: .same(proto: "OSGR"),
  ]
}

extension Config.DisplayConfig.DisplayUnits: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC"),
    1: .same(proto: "IMPERIAL"),
  ]
}

extension Config.DisplayConfig.OledType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OLED_AUTO"),
    1: .same(proto: "OLED_SSD1306"),
    2: .same(proto: "OLED_SH1106"),
  ]
}

extension Config.LoRaConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".LoRaConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_preset"),
    2: .standard(proto: "modem_preset"),
    3: .same(proto: "bandwidth"),
    4: .standard(proto: "spread_factor"),
    5: .standard(proto: "coding_rate"),
    6: .standard(proto: "frequency_offset"),
    7: .same(proto: "region"),
    8: .standard(proto: "hop_limit"),
    9: .standard(proto: "tx_enabled"),
    10: .standard(proto: "tx_power"),
    11: .standard(proto: "channel_num"),
    12: .standard(proto: "override_duty_cycle"),
    103: .standard(proto: "ignore_incoming"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.usePreset) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.modemPreset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.bandwidth) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.spreadFactor) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.codingRate) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.frequencyOffset) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.hopLimit) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.txEnabled) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.txPower) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.channelNum) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.overrideDutyCycle) }()
      case 103: try { try decoder.decodeRepeatedUInt32Field(value: &self.ignoreIncoming) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usePreset != false {
      try visitor.visitSingularBoolField(value: self.usePreset, fieldNumber: 1)
    }
    if self.modemPreset != .longFast {
      try visitor.visitSingularEnumField(value: self.modemPreset, fieldNumber: 2)
    }
    if self.bandwidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandwidth, fieldNumber: 3)
    }
    if self.spreadFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.spreadFactor, fieldNumber: 4)
    }
    if self.codingRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.codingRate, fieldNumber: 5)
    }
    if self.frequencyOffset != 0 {
      try visitor.visitSingularFloatField(value: self.frequencyOffset, fieldNumber: 6)
    }
    if self.region != .unset {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 7)
    }
    if self.hopLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.hopLimit, fieldNumber: 8)
    }
    if self.txEnabled != false {
      try visitor.visitSingularBoolField(value: self.txEnabled, fieldNumber: 9)
    }
    if self.txPower != 0 {
      try visitor.visitSingularInt32Field(value: self.txPower, fieldNumber: 10)
    }
    if self.channelNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelNum, fieldNumber: 11)
    }
    if self.overrideDutyCycle != false {
      try visitor.visitSingularBoolField(value: self.overrideDutyCycle, fieldNumber: 12)
    }
    if !self.ignoreIncoming.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.ignoreIncoming, fieldNumber: 103)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.LoRaConfig, rhs: Config.LoRaConfig) -> Bool {
    if lhs.usePreset != rhs.usePreset {return false}
    if lhs.modemPreset != rhs.modemPreset {return false}
    if lhs.bandwidth != rhs.bandwidth {return false}
    if lhs.spreadFactor != rhs.spreadFactor {return false}
    if lhs.codingRate != rhs.codingRate {return false}
    if lhs.frequencyOffset != rhs.frequencyOffset {return false}
    if lhs.region != rhs.region {return false}
    if lhs.hopLimit != rhs.hopLimit {return false}
    if lhs.txEnabled != rhs.txEnabled {return false}
    if lhs.txPower != rhs.txPower {return false}
    if lhs.channelNum != rhs.channelNum {return false}
    if lhs.overrideDutyCycle != rhs.overrideDutyCycle {return false}
    if lhs.ignoreIncoming != rhs.ignoreIncoming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.LoRaConfig.RegionCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "US"),
    2: .same(proto: "EU_433"),
    3: .same(proto: "EU_868"),
    4: .same(proto: "CN"),
    5: .same(proto: "JP"),
    6: .same(proto: "ANZ"),
    7: .same(proto: "KR"),
    8: .same(proto: "TW"),
    9: .same(proto: "RU"),
    10: .same(proto: "IN"),
    11: .same(proto: "NZ_865"),
    12: .same(proto: "TH"),
    13: .same(proto: "LORA_24"),
  ]
}

extension Config.LoRaConfig.ModemPreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LONG_FAST"),
    1: .same(proto: "LONG_SLOW"),
    2: .same(proto: "VERY_LONG_SLOW"),
    3: .same(proto: "MEDIUM_SLOW"),
    4: .same(proto: "MEDIUM_FAST"),
    5: .same(proto: "SHORT_SLOW"),
    6: .same(proto: "SHORT_FAST"),
  ]
}

extension Config.BluetoothConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".BluetoothConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "mode"),
    3: .standard(proto: "fixed_pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fixedPin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.mode != .randomPin {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    if self.fixedPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.fixedPin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.BluetoothConfig, rhs: Config.BluetoothConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.fixedPin != rhs.fixedPin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.BluetoothConfig.PairingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANDOM_PIN"),
    1: .same(proto: "FIXED_PIN"),
    2: .same(proto: "NO_PIN"),
  ]
}
