// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/module_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RemoteHardwarePinType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// Unset/unused
  case unknown // = 0

  ///
  /// GPIO pin can be read (if it is high / low)
  case digitalRead // = 1

  ///
  /// GPIO pin can be written to (high / low)
  case digitalWrite // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .digitalRead
    case 2: self = .digitalWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .digitalRead: return 1
    case .digitalWrite: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RemoteHardwarePinType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RemoteHardwarePinType] = [
    .unknown,
    .digitalRead,
    .digitalWrite,
  ]
}

#endif  // swift(>=4.2)

///
/// Module Config
struct ModuleConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// TODO: REPLACE
  var payloadVariant: ModuleConfig.OneOf_PayloadVariant? = nil

  ///
  /// TODO: REPLACE
  var mqtt: ModuleConfig.MQTTConfig {
    get {
      if case .mqtt(let v)? = payloadVariant {return v}
      return ModuleConfig.MQTTConfig()
    }
    set {payloadVariant = .mqtt(newValue)}
  }

  ///
  /// TODO: REPLACE
  var serial: ModuleConfig.SerialConfig {
    get {
      if case .serial(let v)? = payloadVariant {return v}
      return ModuleConfig.SerialConfig()
    }
    set {payloadVariant = .serial(newValue)}
  }

  ///
  /// TODO: REPLACE
  var externalNotification: ModuleConfig.ExternalNotificationConfig {
    get {
      if case .externalNotification(let v)? = payloadVariant {return v}
      return ModuleConfig.ExternalNotificationConfig()
    }
    set {payloadVariant = .externalNotification(newValue)}
  }

  ///
  /// TODO: REPLACE
  var storeForward: ModuleConfig.StoreForwardConfig {
    get {
      if case .storeForward(let v)? = payloadVariant {return v}
      return ModuleConfig.StoreForwardConfig()
    }
    set {payloadVariant = .storeForward(newValue)}
  }

  ///
  /// TODO: REPLACE
  var rangeTest: ModuleConfig.RangeTestConfig {
    get {
      if case .rangeTest(let v)? = payloadVariant {return v}
      return ModuleConfig.RangeTestConfig()
    }
    set {payloadVariant = .rangeTest(newValue)}
  }

  ///
  /// TODO: REPLACE
  var telemetry: ModuleConfig.TelemetryConfig {
    get {
      if case .telemetry(let v)? = payloadVariant {return v}
      return ModuleConfig.TelemetryConfig()
    }
    set {payloadVariant = .telemetry(newValue)}
  }

  ///
  /// TODO: REPLACE
  var cannedMessage: ModuleConfig.CannedMessageConfig {
    get {
      if case .cannedMessage(let v)? = payloadVariant {return v}
      return ModuleConfig.CannedMessageConfig()
    }
    set {payloadVariant = .cannedMessage(newValue)}
  }

  ///
  /// TODO: REPLACE
  var audio: ModuleConfig.AudioConfig {
    get {
      if case .audio(let v)? = payloadVariant {return v}
      return ModuleConfig.AudioConfig()
    }
    set {payloadVariant = .audio(newValue)}
  }

  ///
  /// TODO: REPLACE
  var remoteHardware: ModuleConfig.RemoteHardwareConfig {
    get {
      if case .remoteHardware(let v)? = payloadVariant {return v}
      return ModuleConfig.RemoteHardwareConfig()
    }
    set {payloadVariant = .remoteHardware(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// TODO: REPLACE
  enum OneOf_PayloadVariant: Equatable {
    ///
    /// TODO: REPLACE
    case mqtt(ModuleConfig.MQTTConfig)
    ///
    /// TODO: REPLACE
    case serial(ModuleConfig.SerialConfig)
    ///
    /// TODO: REPLACE
    case externalNotification(ModuleConfig.ExternalNotificationConfig)
    ///
    /// TODO: REPLACE
    case storeForward(ModuleConfig.StoreForwardConfig)
    ///
    /// TODO: REPLACE
    case rangeTest(ModuleConfig.RangeTestConfig)
    ///
    /// TODO: REPLACE
    case telemetry(ModuleConfig.TelemetryConfig)
    ///
    /// TODO: REPLACE
    case cannedMessage(ModuleConfig.CannedMessageConfig)
    ///
    /// TODO: REPLACE
    case audio(ModuleConfig.AudioConfig)
    ///
    /// TODO: REPLACE
    case remoteHardware(ModuleConfig.RemoteHardwareConfig)

  #if !swift(>=4.1)
    static func ==(lhs: ModuleConfig.OneOf_PayloadVariant, rhs: ModuleConfig.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mqtt, .mqtt): return {
        guard case .mqtt(let l) = lhs, case .mqtt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serial, .serial): return {
        guard case .serial(let l) = lhs, case .serial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalNotification, .externalNotification): return {
        guard case .externalNotification(let l) = lhs, case .externalNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeForward, .storeForward): return {
        guard case .storeForward(let l) = lhs, case .storeForward(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rangeTest, .rangeTest): return {
        guard case .rangeTest(let l) = lhs, case .rangeTest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.telemetry, .telemetry): return {
        guard case .telemetry(let l) = lhs, case .telemetry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cannedMessage, .cannedMessage): return {
        guard case .cannedMessage(let l) = lhs, case .cannedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteHardware, .remoteHardware): return {
        guard case .remoteHardware(let l) = lhs, case .remoteHardware(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// MQTT Client Config
  struct MQTTConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
    /// is_uplink_enabled or is_downlink_enabled.
    var enabled: Bool = false

    ///
    /// The server to use for our MQTT global message gateway feature.
    /// If not set, the default server will be used
    var address: String = String()

    ///
    /// MQTT username to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default username
    var username: String = String()

    ///
    /// MQTT password to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default password
    var password: String = String()

    ///
    /// Whether to send encrypted or decrypted packets to MQTT.
    /// This parameter is only honoured if you also set server
    /// (the default official mqtt.meshtastic.org server can handle encrypted packets)
    /// Decrypted packets may be useful for external systems that want to consume meshtastic packets
    var encryptionEnabled: Bool = false

    ///
    /// Whether to send / consume json packets on MQTT
    var jsonEnabled: Bool = false

    ///
    /// If true, we attempt to establish a secure connection using TLS
    var tlsEnabled: Bool = false

    ///
    /// The root topic to use for MQTT messages. Default is "msh".
    /// This is useful if you want to use a single MQTT server for multiple meshtastic networks and separate them via ACLs
    var root: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// RemoteHardwareModule Config
  struct RemoteHardwareConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether the Module is enabled
    var enabled: Bool = false

    ///
    /// Whether the Module allows consumers to read / write to pins not defined in available_pins
    var allowUndefinedPinAccess: Bool = false

    ///
    /// Exposes the available pins to the mesh for reading and writing
    var availablePins: [RemoteHardwarePin] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Audio Config for codec2 voice
  struct AudioConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether Audio is enabled
    var codec2Enabled: Bool = false

    ///
    /// PTT Pin
    var pttPin: UInt32 = 0

    ///
    /// The audio sample rate to use for codec2
    var bitrate: ModuleConfig.AudioConfig.Audio_Baud = .codec2Default

    ///
    /// I2S Word Select
    var i2SWs: UInt32 = 0

    ///
    /// I2S Data IN
    var i2SSd: UInt32 = 0

    ///
    /// I2S Data OUT
    var i2SDin: UInt32 = 0

    ///
    /// I2S Clock
    var i2SSck: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Baudrate for codec2 voice
    enum Audio_Baud: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case codec2Default // = 0
      case codec23200 // = 1
      case codec22400 // = 2
      case codec21600 // = 3
      case codec21400 // = 4
      case codec21300 // = 5
      case codec21200 // = 6
      case codec2700 // = 7
      case codec2700B // = 8
      case UNRECOGNIZED(Int)

      init() {
        self = .codec2Default
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .codec2Default
        case 1: self = .codec23200
        case 2: self = .codec22400
        case 3: self = .codec21600
        case 4: self = .codec21400
        case 5: self = .codec21300
        case 6: self = .codec21200
        case 7: self = .codec2700
        case 8: self = .codec2700B
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .codec2Default: return 0
        case .codec23200: return 1
        case .codec22400: return 2
        case .codec21600: return 3
        case .codec21400: return 4
        case .codec21300: return 5
        case .codec21200: return 6
        case .codec2700: return 7
        case .codec2700B: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  ///
  /// Serial Config
  struct SerialConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Preferences for the SerialModule
    /// FIXME - Move this out of UserPreferences and into a section for module configuration.
    var enabled: Bool = false

    ///
    /// TODO: REPLACE
    var echo: Bool = false

    ///
    /// TODO: REPLACE
    var rxd: UInt32 = 0

    ///
    /// TODO: REPLACE
    var txd: UInt32 = 0

    ///
    /// TODO: REPLACE
    var baud: ModuleConfig.SerialConfig.Serial_Baud = .baudDefault

    ///
    /// TODO: REPLACE
    var timeout: UInt32 = 0

    ///
    /// TODO: REPLACE
    var mode: ModuleConfig.SerialConfig.Serial_Mode = .default

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    enum Serial_Baud: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case baudDefault // = 0
      case baud110 // = 1
      case baud300 // = 2
      case baud600 // = 3
      case baud1200 // = 4
      case baud2400 // = 5
      case baud4800 // = 6
      case baud9600 // = 7
      case baud19200 // = 8
      case baud38400 // = 9
      case baud57600 // = 10
      case baud115200 // = 11
      case baud230400 // = 12
      case baud460800 // = 13
      case baud576000 // = 14
      case baud921600 // = 15
      case UNRECOGNIZED(Int)

      init() {
        self = .baudDefault
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .baudDefault
        case 1: self = .baud110
        case 2: self = .baud300
        case 3: self = .baud600
        case 4: self = .baud1200
        case 5: self = .baud2400
        case 6: self = .baud4800
        case 7: self = .baud9600
        case 8: self = .baud19200
        case 9: self = .baud38400
        case 10: self = .baud57600
        case 11: self = .baud115200
        case 12: self = .baud230400
        case 13: self = .baud460800
        case 14: self = .baud576000
        case 15: self = .baud921600
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .baudDefault: return 0
        case .baud110: return 1
        case .baud300: return 2
        case .baud600: return 3
        case .baud1200: return 4
        case .baud2400: return 5
        case .baud4800: return 6
        case .baud9600: return 7
        case .baud19200: return 8
        case .baud38400: return 9
        case .baud57600: return 10
        case .baud115200: return 11
        case .baud230400: return 12
        case .baud460800: return 13
        case .baud576000: return 14
        case .baud921600: return 15
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// TODO: REPLACE
    enum Serial_Mode: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case `default` // = 0
      case simple // = 1
      case proto // = 2
      case textmsg // = 3
      case nmea // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .default
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .simple
        case 2: self = .proto
        case 3: self = .textmsg
        case 4: self = .nmea
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .default: return 0
        case .simple: return 1
        case .proto: return 2
        case .textmsg: return 3
        case .nmea: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  ///
  /// External Notifications Config
  struct ExternalNotificationConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the ExternalNotificationModule
    var enabled: Bool = false

    ///
    /// When using in On/Off mode, keep the output on for this many
    /// milliseconds. Default 1000ms (1 second).
    var outputMs: UInt32 = 0

    ///
    /// Define the output pin GPIO setting Defaults to
    /// EXT_NOTIFY_OUT if set for the board.
    /// In standalone devices this pin should drive the LED to match the UI.
    var output: UInt32 = 0

    ///
    /// Optional: Define a secondary output pin for a vibra motor
    /// This is used in standalone devices to match the UI.
    var outputVibra: UInt32 = 0

    ///
    /// Optional: Define a tertiary output pin for an active buzzer
    /// This is used in standalone devices to to match the UI.
    var outputBuzzer: UInt32 = 0

    ///
    /// IF this is true, the 'output' Pin will be pulled active high, false
    /// means active low.
    var active: Bool = false

    ///
    /// True: Alert when a text message arrives (output)
    var alertMessage: Bool = false

    ///
    /// True: Alert when a text message arrives (output_vibra)
    var alertMessageVibra: Bool = false

    ///
    /// True: Alert when a text message arrives (output_buzzer)
    var alertMessageBuzzer: Bool = false

    ///
    /// True: Alert when the bell character is received (output)
    var alertBell: Bool = false

    ///
    /// True: Alert when the bell character is received (output_vibra)
    var alertBellVibra: Bool = false

    ///
    /// True: Alert when the bell character is received (output_buzzer)
    var alertBellBuzzer: Bool = false

    ///
    /// use a PWM output instead of a simple on/off output. This will ignore
    /// the 'output', 'output_ms' and 'active' settings and use the
    /// device.buzzer_gpio instead.
    var usePwm: Bool = false

    ///
    /// The notification will toggle with 'output_ms' for this time of seconds.
    /// Default is 0 which means don't repeat at all. 60 would mean blink
    /// and/or beep for 60 seconds
    var nagTimeout: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Store and Forward Module Config
  struct StoreForwardConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the Store and Forward Module
    var enabled: Bool = false

    ///
    /// TODO: REPLACE
    var heartbeat: Bool = false

    ///
    /// TODO: REPLACE
    var records: UInt32 = 0

    ///
    /// TODO: REPLACE
    var historyReturnMax: UInt32 = 0

    ///
    /// TODO: REPLACE
    var historyReturnWindow: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Preferences for the RangeTestModule
  struct RangeTestConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the Range Test Module
    var enabled: Bool = false

    ///
    /// Send out range test messages from this node
    var sender: UInt32 = 0

    ///
    /// Bool value indicating that this node should save a RangeTest.csv file.
    /// ESP32 Only
    var save: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Configuration for both device and environment metrics
  struct TelemetryConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Interval in seconds of how often we should try to send our
    /// device metrics to the mesh
    var deviceUpdateInterval: UInt32 = 0

    var environmentUpdateInterval: UInt32 = 0

    ///
    /// Preferences for the Telemetry Module (Environment)
    /// Enable/Disable the telemetry measurement module measurement collection
    var environmentMeasurementEnabled: Bool = false

    ///
    /// Enable/Disable the telemetry measurement module on-device display
    var environmentScreenEnabled: Bool = false

    ///
    /// We'll always read the sensor in Celsius, but sometimes we might want to
    /// display the results in Fahrenheit as a "user preference".
    var environmentDisplayFahrenheit: Bool = false

    ///
    /// Enable/Disable the air quality metrics
    var airQualityEnabled: Bool = false

    ///
    /// Interval in seconds of how often we should try to send our
    /// air quality metrics to the mesh
    var airQualityInterval: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct CannedMessageConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
    var rotary1Enabled: Bool = false

    ///
    /// GPIO pin for rotary encoder A port.
    var inputbrokerPinA: UInt32 = 0

    ///
    /// GPIO pin for rotary encoder B port.
    var inputbrokerPinB: UInt32 = 0

    ///
    /// GPIO pin for rotary encoder Press port.
    var inputbrokerPinPress: UInt32 = 0

    ///
    /// Generate input event on CW of this kind.
    var inputbrokerEventCw: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Generate input event on CCW of this kind.
    var inputbrokerEventCcw: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Generate input event on Press of this kind.
    var inputbrokerEventPress: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
    var updown1Enabled: Bool = false

    ///
    /// Enable/disable CannedMessageModule.
    var enabled: Bool = false

    ///
    /// Input event origin accepted by the canned message module.
    /// Can be e.g. "rotEnc1", "upDownEnc1" or keyword "_any"
    var allowInputSource: String = String()

    ///
    /// CannedMessageModule also sends a bell character with the messages.
    /// ExternalNotificationModule can benefit from this feature.
    var sendBell: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    enum InputEventChar: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// TODO: REPLACE
      case none // = 0

      ///
      /// TODO: REPLACE
      case up // = 17

      ///
      /// TODO: REPLACE
      case down // = 18

      ///
      /// TODO: REPLACE
      case left // = 19

      ///
      /// TODO: REPLACE
      case right // = 20

      ///
      /// '\n'
      case select // = 10

      ///
      /// TODO: REPLACE
      case back // = 27

      ///
      /// TODO: REPLACE
      case cancel // = 24
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 10: self = .select
        case 17: self = .up
        case 18: self = .down
        case 19: self = .left
        case 20: self = .right
        case 24: self = .cancel
        case 27: self = .back
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .select: return 10
        case .up: return 17
        case .down: return 18
        case .left: return 19
        case .right: return 20
        case .cancel: return 24
        case .back: return 27
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension ModuleConfig.AudioConfig.Audio_Baud: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModuleConfig.AudioConfig.Audio_Baud] = [
    .codec2Default,
    .codec23200,
    .codec22400,
    .codec21600,
    .codec21400,
    .codec21300,
    .codec21200,
    .codec2700,
    .codec2700B,
  ]
}

extension ModuleConfig.SerialConfig.Serial_Baud: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModuleConfig.SerialConfig.Serial_Baud] = [
    .baudDefault,
    .baud110,
    .baud300,
    .baud600,
    .baud1200,
    .baud2400,
    .baud4800,
    .baud9600,
    .baud19200,
    .baud38400,
    .baud57600,
    .baud115200,
    .baud230400,
    .baud460800,
    .baud576000,
    .baud921600,
  ]
}

extension ModuleConfig.SerialConfig.Serial_Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModuleConfig.SerialConfig.Serial_Mode] = [
    .default,
    .simple,
    .proto,
    .textmsg,
    .nmea,
  ]
}

extension ModuleConfig.CannedMessageConfig.InputEventChar: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModuleConfig.CannedMessageConfig.InputEventChar] = [
    .none,
    .up,
    .down,
    .left,
    .right,
    .select,
    .back,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

///
/// A GPIO pin definition for remote hardware module
struct RemoteHardwarePin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// GPIO Pin number (must match Arduino)
  var gpioPin: UInt32 = 0

  ///
  /// Name for the GPIO pin (i.e. Front gate, mailbox, etc)
  var name: String = String()

  ///
  /// Type of GPIO access available to consumers on the mesh
  var type: RemoteHardwarePinType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension RemoteHardwarePinType: @unchecked Sendable {}
extension ModuleConfig: @unchecked Sendable {}
extension ModuleConfig.OneOf_PayloadVariant: @unchecked Sendable {}
extension ModuleConfig.MQTTConfig: @unchecked Sendable {}
extension ModuleConfig.RemoteHardwareConfig: @unchecked Sendable {}
extension ModuleConfig.AudioConfig: @unchecked Sendable {}
extension ModuleConfig.AudioConfig.Audio_Baud: @unchecked Sendable {}
extension ModuleConfig.SerialConfig: @unchecked Sendable {}
extension ModuleConfig.SerialConfig.Serial_Baud: @unchecked Sendable {}
extension ModuleConfig.SerialConfig.Serial_Mode: @unchecked Sendable {}
extension ModuleConfig.ExternalNotificationConfig: @unchecked Sendable {}
extension ModuleConfig.StoreForwardConfig: @unchecked Sendable {}
extension ModuleConfig.RangeTestConfig: @unchecked Sendable {}
extension ModuleConfig.TelemetryConfig: @unchecked Sendable {}
extension ModuleConfig.CannedMessageConfig: @unchecked Sendable {}
extension ModuleConfig.CannedMessageConfig.InputEventChar: @unchecked Sendable {}
extension RemoteHardwarePin: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension RemoteHardwarePinType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DIGITAL_READ"),
    2: .same(proto: "DIGITAL_WRITE"),
  ]
}

extension ModuleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mqtt"),
    2: .same(proto: "serial"),
    3: .standard(proto: "external_notification"),
    4: .standard(proto: "store_forward"),
    5: .standard(proto: "range_test"),
    6: .same(proto: "telemetry"),
    7: .standard(proto: "canned_message"),
    8: .same(proto: "audio"),
    9: .standard(proto: "remote_hardware"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ModuleConfig.MQTTConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqtt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqtt(v)
        }
      }()
      case 2: try {
        var v: ModuleConfig.SerialConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .serial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .serial(v)
        }
      }()
      case 3: try {
        var v: ModuleConfig.ExternalNotificationConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .externalNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .externalNotification(v)
        }
      }()
      case 4: try {
        var v: ModuleConfig.StoreForwardConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .storeForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .storeForward(v)
        }
      }()
      case 5: try {
        var v: ModuleConfig.RangeTestConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .rangeTest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rangeTest(v)
        }
      }()
      case 6: try {
        var v: ModuleConfig.TelemetryConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .telemetry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .telemetry(v)
        }
      }()
      case 7: try {
        var v: ModuleConfig.CannedMessageConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .cannedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .cannedMessage(v)
        }
      }()
      case 8: try {
        var v: ModuleConfig.AudioConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .audio(v)
        }
      }()
      case 9: try {
        var v: ModuleConfig.RemoteHardwareConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .remoteHardware(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .remoteHardware(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .mqtt?: try {
      guard case .mqtt(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .serial?: try {
      guard case .serial(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .externalNotification?: try {
      guard case .externalNotification(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .storeForward?: try {
      guard case .storeForward(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rangeTest?: try {
      guard case .rangeTest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .telemetry?: try {
      guard case .telemetry(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cannedMessage?: try {
      guard case .cannedMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .remoteHardware?: try {
      guard case .remoteHardware(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig, rhs: ModuleConfig) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.MQTTConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".MQTTConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "address"),
    3: .same(proto: "username"),
    4: .same(proto: "password"),
    5: .standard(proto: "encryption_enabled"),
    6: .standard(proto: "json_enabled"),
    7: .standard(proto: "tls_enabled"),
    8: .same(proto: "root"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.encryptionEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.jsonEnabled) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.tlsEnabled) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.root) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 4)
    }
    if self.encryptionEnabled != false {
      try visitor.visitSingularBoolField(value: self.encryptionEnabled, fieldNumber: 5)
    }
    if self.jsonEnabled != false {
      try visitor.visitSingularBoolField(value: self.jsonEnabled, fieldNumber: 6)
    }
    if self.tlsEnabled != false {
      try visitor.visitSingularBoolField(value: self.tlsEnabled, fieldNumber: 7)
    }
    if !self.root.isEmpty {
      try visitor.visitSingularStringField(value: self.root, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.MQTTConfig, rhs: ModuleConfig.MQTTConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.address != rhs.address {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.encryptionEnabled != rhs.encryptionEnabled {return false}
    if lhs.jsonEnabled != rhs.jsonEnabled {return false}
    if lhs.tlsEnabled != rhs.tlsEnabled {return false}
    if lhs.root != rhs.root {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.RemoteHardwareConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".RemoteHardwareConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "allow_undefined_pin_access"),
    3: .standard(proto: "available_pins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowUndefinedPinAccess) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.availablePins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.allowUndefinedPinAccess != false {
      try visitor.visitSingularBoolField(value: self.allowUndefinedPinAccess, fieldNumber: 2)
    }
    if !self.availablePins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availablePins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.RemoteHardwareConfig, rhs: ModuleConfig.RemoteHardwareConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowUndefinedPinAccess != rhs.allowUndefinedPinAccess {return false}
    if lhs.availablePins != rhs.availablePins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.AudioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".AudioConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "codec2_enabled"),
    2: .standard(proto: "ptt_pin"),
    3: .same(proto: "bitrate"),
    4: .standard(proto: "i2s_ws"),
    5: .standard(proto: "i2s_sd"),
    6: .standard(proto: "i2s_din"),
    7: .standard(proto: "i2s_sck"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.codec2Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pttPin) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.bitrate) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.i2SWs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSd) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.i2SDin) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codec2Enabled != false {
      try visitor.visitSingularBoolField(value: self.codec2Enabled, fieldNumber: 1)
    }
    if self.pttPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.pttPin, fieldNumber: 2)
    }
    if self.bitrate != .codec2Default {
      try visitor.visitSingularEnumField(value: self.bitrate, fieldNumber: 3)
    }
    if self.i2SWs != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SWs, fieldNumber: 4)
    }
    if self.i2SSd != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSd, fieldNumber: 5)
    }
    if self.i2SDin != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SDin, fieldNumber: 6)
    }
    if self.i2SSck != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSck, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.AudioConfig, rhs: ModuleConfig.AudioConfig) -> Bool {
    if lhs.codec2Enabled != rhs.codec2Enabled {return false}
    if lhs.pttPin != rhs.pttPin {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.i2SWs != rhs.i2SWs {return false}
    if lhs.i2SSd != rhs.i2SSd {return false}
    if lhs.i2SDin != rhs.i2SDin {return false}
    if lhs.i2SSck != rhs.i2SSck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.AudioConfig.Audio_Baud: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC2_DEFAULT"),
    1: .same(proto: "CODEC2_3200"),
    2: .same(proto: "CODEC2_2400"),
    3: .same(proto: "CODEC2_1600"),
    4: .same(proto: "CODEC2_1400"),
    5: .same(proto: "CODEC2_1300"),
    6: .same(proto: "CODEC2_1200"),
    7: .same(proto: "CODEC2_700"),
    8: .same(proto: "CODEC2_700B"),
  ]
}

extension ModuleConfig.SerialConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".SerialConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "echo"),
    3: .same(proto: "rxd"),
    4: .same(proto: "txd"),
    5: .same(proto: "baud"),
    6: .same(proto: "timeout"),
    7: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.echo) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rxd) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.txd) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.baud) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.echo != false {
      try visitor.visitSingularBoolField(value: self.echo, fieldNumber: 2)
    }
    if self.rxd != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxd, fieldNumber: 3)
    }
    if self.txd != 0 {
      try visitor.visitSingularUInt32Field(value: self.txd, fieldNumber: 4)
    }
    if self.baud != .baudDefault {
      try visitor.visitSingularEnumField(value: self.baud, fieldNumber: 5)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 6)
    }
    if self.mode != .default {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.SerialConfig, rhs: ModuleConfig.SerialConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.echo != rhs.echo {return false}
    if lhs.rxd != rhs.rxd {return false}
    if lhs.txd != rhs.txd {return false}
    if lhs.baud != rhs.baud {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.SerialConfig.Serial_Baud: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BAUD_DEFAULT"),
    1: .same(proto: "BAUD_110"),
    2: .same(proto: "BAUD_300"),
    3: .same(proto: "BAUD_600"),
    4: .same(proto: "BAUD_1200"),
    5: .same(proto: "BAUD_2400"),
    6: .same(proto: "BAUD_4800"),
    7: .same(proto: "BAUD_9600"),
    8: .same(proto: "BAUD_19200"),
    9: .same(proto: "BAUD_38400"),
    10: .same(proto: "BAUD_57600"),
    11: .same(proto: "BAUD_115200"),
    12: .same(proto: "BAUD_230400"),
    13: .same(proto: "BAUD_460800"),
    14: .same(proto: "BAUD_576000"),
    15: .same(proto: "BAUD_921600"),
  ]
}

extension ModuleConfig.SerialConfig.Serial_Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SIMPLE"),
    2: .same(proto: "PROTO"),
    3: .same(proto: "TEXTMSG"),
    4: .same(proto: "NMEA"),
  ]
}

extension ModuleConfig.ExternalNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".ExternalNotificationConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "output_ms"),
    3: .same(proto: "output"),
    8: .standard(proto: "output_vibra"),
    9: .standard(proto: "output_buzzer"),
    4: .same(proto: "active"),
    5: .standard(proto: "alert_message"),
    10: .standard(proto: "alert_message_vibra"),
    11: .standard(proto: "alert_message_buzzer"),
    6: .standard(proto: "alert_bell"),
    12: .standard(proto: "alert_bell_vibra"),
    13: .standard(proto: "alert_bell_buzzer"),
    7: .standard(proto: "use_pwm"),
    14: .standard(proto: "nag_timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outputMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.output) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.alertMessage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.alertBell) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.usePwm) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.outputVibra) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.outputBuzzer) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.alertMessageVibra) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.alertMessageBuzzer) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.alertBellVibra) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.alertBellBuzzer) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.nagTimeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.outputMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputMs, fieldNumber: 2)
    }
    if self.output != 0 {
      try visitor.visitSingularUInt32Field(value: self.output, fieldNumber: 3)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 4)
    }
    if self.alertMessage != false {
      try visitor.visitSingularBoolField(value: self.alertMessage, fieldNumber: 5)
    }
    if self.alertBell != false {
      try visitor.visitSingularBoolField(value: self.alertBell, fieldNumber: 6)
    }
    if self.usePwm != false {
      try visitor.visitSingularBoolField(value: self.usePwm, fieldNumber: 7)
    }
    if self.outputVibra != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputVibra, fieldNumber: 8)
    }
    if self.outputBuzzer != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputBuzzer, fieldNumber: 9)
    }
    if self.alertMessageVibra != false {
      try visitor.visitSingularBoolField(value: self.alertMessageVibra, fieldNumber: 10)
    }
    if self.alertMessageBuzzer != false {
      try visitor.visitSingularBoolField(value: self.alertMessageBuzzer, fieldNumber: 11)
    }
    if self.alertBellVibra != false {
      try visitor.visitSingularBoolField(value: self.alertBellVibra, fieldNumber: 12)
    }
    if self.alertBellBuzzer != false {
      try visitor.visitSingularBoolField(value: self.alertBellBuzzer, fieldNumber: 13)
    }
    if self.nagTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.nagTimeout, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.ExternalNotificationConfig, rhs: ModuleConfig.ExternalNotificationConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.outputMs != rhs.outputMs {return false}
    if lhs.output != rhs.output {return false}
    if lhs.outputVibra != rhs.outputVibra {return false}
    if lhs.outputBuzzer != rhs.outputBuzzer {return false}
    if lhs.active != rhs.active {return false}
    if lhs.alertMessage != rhs.alertMessage {return false}
    if lhs.alertMessageVibra != rhs.alertMessageVibra {return false}
    if lhs.alertMessageBuzzer != rhs.alertMessageBuzzer {return false}
    if lhs.alertBell != rhs.alertBell {return false}
    if lhs.alertBellVibra != rhs.alertBellVibra {return false}
    if lhs.alertBellBuzzer != rhs.alertBellBuzzer {return false}
    if lhs.usePwm != rhs.usePwm {return false}
    if lhs.nagTimeout != rhs.nagTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.StoreForwardConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".StoreForwardConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "heartbeat"),
    3: .same(proto: "records"),
    4: .standard(proto: "history_return_max"),
    5: .standard(proto: "history_return_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.heartbeat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.records) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnMax) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnWindow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.heartbeat != false {
      try visitor.visitSingularBoolField(value: self.heartbeat, fieldNumber: 2)
    }
    if self.records != 0 {
      try visitor.visitSingularUInt32Field(value: self.records, fieldNumber: 3)
    }
    if self.historyReturnMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnMax, fieldNumber: 4)
    }
    if self.historyReturnWindow != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnWindow, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.StoreForwardConfig, rhs: ModuleConfig.StoreForwardConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.heartbeat != rhs.heartbeat {return false}
    if lhs.records != rhs.records {return false}
    if lhs.historyReturnMax != rhs.historyReturnMax {return false}
    if lhs.historyReturnWindow != rhs.historyReturnWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.RangeTestConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".RangeTestConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "sender"),
    3: .same(proto: "save"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.save) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.sender != 0 {
      try visitor.visitSingularUInt32Field(value: self.sender, fieldNumber: 2)
    }
    if self.save != false {
      try visitor.visitSingularBoolField(value: self.save, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.RangeTestConfig, rhs: ModuleConfig.RangeTestConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.save != rhs.save {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.TelemetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".TelemetryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_update_interval"),
    2: .standard(proto: "environment_update_interval"),
    3: .standard(proto: "environment_measurement_enabled"),
    4: .standard(proto: "environment_screen_enabled"),
    5: .standard(proto: "environment_display_fahrenheit"),
    6: .standard(proto: "air_quality_enabled"),
    7: .standard(proto: "air_quality_interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUpdateInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.environmentUpdateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.environmentMeasurementEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.environmentScreenEnabled) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.environmentDisplayFahrenheit) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.airQualityEnabled) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.airQualityInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUpdateInterval, fieldNumber: 1)
    }
    if self.environmentUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentUpdateInterval, fieldNumber: 2)
    }
    if self.environmentMeasurementEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentMeasurementEnabled, fieldNumber: 3)
    }
    if self.environmentScreenEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentScreenEnabled, fieldNumber: 4)
    }
    if self.environmentDisplayFahrenheit != false {
      try visitor.visitSingularBoolField(value: self.environmentDisplayFahrenheit, fieldNumber: 5)
    }
    if self.airQualityEnabled != false {
      try visitor.visitSingularBoolField(value: self.airQualityEnabled, fieldNumber: 6)
    }
    if self.airQualityInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.airQualityInterval, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.TelemetryConfig, rhs: ModuleConfig.TelemetryConfig) -> Bool {
    if lhs.deviceUpdateInterval != rhs.deviceUpdateInterval {return false}
    if lhs.environmentUpdateInterval != rhs.environmentUpdateInterval {return false}
    if lhs.environmentMeasurementEnabled != rhs.environmentMeasurementEnabled {return false}
    if lhs.environmentScreenEnabled != rhs.environmentScreenEnabled {return false}
    if lhs.environmentDisplayFahrenheit != rhs.environmentDisplayFahrenheit {return false}
    if lhs.airQualityEnabled != rhs.airQualityEnabled {return false}
    if lhs.airQualityInterval != rhs.airQualityInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.CannedMessageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ModuleConfig.protoMessageName + ".CannedMessageConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rotary1_enabled"),
    2: .standard(proto: "inputbroker_pin_a"),
    3: .standard(proto: "inputbroker_pin_b"),
    4: .standard(proto: "inputbroker_pin_press"),
    5: .standard(proto: "inputbroker_event_cw"),
    6: .standard(proto: "inputbroker_event_ccw"),
    7: .standard(proto: "inputbroker_event_press"),
    8: .standard(proto: "updown1_enabled"),
    9: .same(proto: "enabled"),
    10: .standard(proto: "allow_input_source"),
    11: .standard(proto: "send_bell"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.rotary1Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinA) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinB) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinPress) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventCw) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventCcw) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventPress) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.updown1Enabled) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.allowInputSource) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.sendBell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotary1Enabled != false {
      try visitor.visitSingularBoolField(value: self.rotary1Enabled, fieldNumber: 1)
    }
    if self.inputbrokerPinA != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinA, fieldNumber: 2)
    }
    if self.inputbrokerPinB != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinB, fieldNumber: 3)
    }
    if self.inputbrokerPinPress != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinPress, fieldNumber: 4)
    }
    if self.inputbrokerEventCw != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventCw, fieldNumber: 5)
    }
    if self.inputbrokerEventCcw != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventCcw, fieldNumber: 6)
    }
    if self.inputbrokerEventPress != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventPress, fieldNumber: 7)
    }
    if self.updown1Enabled != false {
      try visitor.visitSingularBoolField(value: self.updown1Enabled, fieldNumber: 8)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 9)
    }
    if !self.allowInputSource.isEmpty {
      try visitor.visitSingularStringField(value: self.allowInputSource, fieldNumber: 10)
    }
    if self.sendBell != false {
      try visitor.visitSingularBoolField(value: self.sendBell, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModuleConfig.CannedMessageConfig, rhs: ModuleConfig.CannedMessageConfig) -> Bool {
    if lhs.rotary1Enabled != rhs.rotary1Enabled {return false}
    if lhs.inputbrokerPinA != rhs.inputbrokerPinA {return false}
    if lhs.inputbrokerPinB != rhs.inputbrokerPinB {return false}
    if lhs.inputbrokerPinPress != rhs.inputbrokerPinPress {return false}
    if lhs.inputbrokerEventCw != rhs.inputbrokerEventCw {return false}
    if lhs.inputbrokerEventCcw != rhs.inputbrokerEventCcw {return false}
    if lhs.inputbrokerEventPress != rhs.inputbrokerEventPress {return false}
    if lhs.updown1Enabled != rhs.updown1Enabled {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowInputSource != rhs.allowInputSource {return false}
    if lhs.sendBell != rhs.sendBell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.CannedMessageConfig.InputEventChar: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    10: .same(proto: "SELECT"),
    17: .same(proto: "UP"),
    18: .same(proto: "DOWN"),
    19: .same(proto: "LEFT"),
    20: .same(proto: "RIGHT"),
    24: .same(proto: "CANCEL"),
    27: .same(proto: "BACK"),
  ]
}

extension RemoteHardwarePin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteHardwarePin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gpio_pin"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gpioPin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gpioPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpioPin, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RemoteHardwarePin, rhs: RemoteHardwarePin) -> Bool {
    if lhs.gpioPin != rhs.gpioPin {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
