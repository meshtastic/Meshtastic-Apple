// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/mesh.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Note: these enum names must EXACTLY match the string used in the device
/// bin/build-all.sh script.
/// Because they will be used to find firmware filenames in the android app for OTA updates.
/// To match the old style filenames, _ is converted to -, p is converted to .
enum HardwareModel: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case unset // = 0

  ///
  /// TODO: REPLACE
  case tloraV2 // = 1

  ///
  /// TODO: REPLACE
  case tloraV1 // = 2

  ///
  /// TODO: REPLACE
  case tloraV211P6 // = 3

  ///
  /// TODO: REPLACE
  case tbeam // = 4

  ///
  /// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
  /// (see HELTEC_V2 for the new version).
  case heltecV20 // = 5

  ///
  /// TODO: REPLACE
  case tbeamV0P7 // = 6

  ///
  /// TODO: REPLACE
  case tEcho // = 7

  ///
  /// TODO: REPLACE
  case tloraV11P3 // = 8

  ///
  /// TODO: REPLACE
  case rak4631 // = 9

  ///
  /// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
  /// Sadly they did not update anything on the silkscreen to identify this board
  case heltecV21 // = 10

  ///
  /// Ancient heltec WiFi_Lora_32 board
  case heltecV1 // = 11

  ///
  /// New T-BEAM with ESP32-S3 CPU
  case lilygoTbeamS3Core // = 12

  ///
  /// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
  case rak11200 // = 13

  ///
  /// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
  case nanoG1 // = 14

  ///
  /// TODO: REPLACE
  case tloraV211P8 // = 15

  ///
  /// TODO: REPLACE
  case tloraT3S3 // = 16

  ///
  /// B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
  case stationG1 // = 25

  ///
  /// Less common/prototype boards listed here (needs one more byte over the air)
  case loraRelayV1 // = 32

  ///
  /// TODO: REPLACE
  case nrf52840Dk // = 33

  ///
  /// TODO: REPLACE
  case ppr // = 34

  ///
  /// TODO: REPLACE
  case genieblocks // = 35

  ///
  /// TODO: REPLACE
  case nrf52Unknown // = 36

  ///
  /// TODO: REPLACE
  case portduino // = 37

  ///
  /// The simulator built into the android app
  case androidSim // = 38

  ///
  /// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
  case diyV1 // = 39

  ///
  /// nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
  case nrf52840Pca10059 // = 40

  ///
  /// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
  case drDev // = 41

  ///
  /// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, Paper) https://m5stack.com/
  case m5Stack // = 42

  ///
  /// New Heltec LoRA32 with ESP32-S3 CPU
  case heltecV3 // = 43

  ///
  /// New Heltec Wireless Stick Lite with ESP32-S3 CPU
  case heltecWslV3 // = 44

  ///
  /// New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
  case betafpv2400Tx // = 45

  ///
  /// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
  case privateHw // = 255
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .tloraV2
    case 2: self = .tloraV1
    case 3: self = .tloraV211P6
    case 4: self = .tbeam
    case 5: self = .heltecV20
    case 6: self = .tbeamV0P7
    case 7: self = .tEcho
    case 8: self = .tloraV11P3
    case 9: self = .rak4631
    case 10: self = .heltecV21
    case 11: self = .heltecV1
    case 12: self = .lilygoTbeamS3Core
    case 13: self = .rak11200
    case 14: self = .nanoG1
    case 15: self = .tloraV211P8
    case 16: self = .tloraT3S3
    case 25: self = .stationG1
    case 32: self = .loraRelayV1
    case 33: self = .nrf52840Dk
    case 34: self = .ppr
    case 35: self = .genieblocks
    case 36: self = .nrf52Unknown
    case 37: self = .portduino
    case 38: self = .androidSim
    case 39: self = .diyV1
    case 40: self = .nrf52840Pca10059
    case 41: self = .drDev
    case 42: self = .m5Stack
    case 43: self = .heltecV3
    case 44: self = .heltecWslV3
    case 45: self = .betafpv2400Tx
    case 255: self = .privateHw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .tloraV2: return 1
    case .tloraV1: return 2
    case .tloraV211P6: return 3
    case .tbeam: return 4
    case .heltecV20: return 5
    case .tbeamV0P7: return 6
    case .tEcho: return 7
    case .tloraV11P3: return 8
    case .rak4631: return 9
    case .heltecV21: return 10
    case .heltecV1: return 11
    case .lilygoTbeamS3Core: return 12
    case .rak11200: return 13
    case .nanoG1: return 14
    case .tloraV211P8: return 15
    case .tloraT3S3: return 16
    case .stationG1: return 25
    case .loraRelayV1: return 32
    case .nrf52840Dk: return 33
    case .ppr: return 34
    case .genieblocks: return 35
    case .nrf52Unknown: return 36
    case .portduino: return 37
    case .androidSim: return 38
    case .diyV1: return 39
    case .nrf52840Pca10059: return 40
    case .drDev: return 41
    case .m5Stack: return 42
    case .heltecV3: return 43
    case .heltecWslV3: return 44
    case .betafpv2400Tx: return 45
    case .privateHw: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HardwareModel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [HardwareModel] = [
    .unset,
    .tloraV2,
    .tloraV1,
    .tloraV211P6,
    .tbeam,
    .heltecV20,
    .tbeamV0P7,
    .tEcho,
    .tloraV11P3,
    .rak4631,
    .heltecV21,
    .heltecV1,
    .lilygoTbeamS3Core,
    .rak11200,
    .nanoG1,
    .tloraV211P8,
    .tloraT3S3,
    .stationG1,
    .loraRelayV1,
    .nrf52840Dk,
    .ppr,
    .genieblocks,
    .nrf52Unknown,
    .portduino,
    .androidSim,
    .diyV1,
    .nrf52840Pca10059,
    .drDev,
    .m5Stack,
    .heltecV3,
    .heltecWslV3,
    .betafpv2400Tx,
    .privateHw,
  ]
}

#endif  // swift(>=4.2)

///
/// Shared constants between device and phone
enum Constants: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// First enum must be zero, and we are just using this enum to
  /// pass int constants between two very different environments
  case zero // = 0

  ///
  /// From mesh.options
  /// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
  /// outside of this envelope
  case dataPayloadLen // = 237
  case UNRECOGNIZED(Int)

  init() {
    self = .zero
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .zero
    case 237: self = .dataPayloadLen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .zero: return 0
    case .dataPayloadLen: return 237
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Constants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Constants] = [
    .zero,
    .dataPayloadLen,
  ]
}

#endif  // swift(>=4.2)

///
/// Error codes for critical errors
/// The device might report these fault codes on the screen.
/// If you encounter a fault code, please post on the meshtastic.discourse.group
/// and we'll try to help.
enum CriticalErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case none // = 0

  ///
  /// A software bug was detected while trying to send lora
  case txWatchdog // = 1

  ///
  /// A software bug was detected on entry to sleep
  case sleepEnterWait // = 2

  ///
  /// No Lora radio hardware could be found
  case noRadio // = 3

  ///
  /// Not normally used
  case unspecified // = 4

  ///
  /// We failed while configuring a UBlox GPS
  case ubloxUnitFailed // = 5

  ///
  /// This board was expected to have a power management chip and it is missing or broken
  case noAxp192 // = 6

  ///
  /// The channel tried to set a radio setting which is not supported by this chipset,
  /// radio comms settings are now undefined.
  case invalidRadioSetting // = 7

  ///
  /// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
  /// reply with an interrupt.
  case transmitFailed // = 8

  ///
  /// We detected that the main CPU voltage dropped below the minumum acceptable value
  case brownout // = 9

  /// Selftest of SX1262 radio chip failed 
  case sx1262Failure // = 10

  ///
  /// A (likely software but possibly hardware) failure was detected while trying to send packets.
  /// If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
  case radioSpiBug // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .txWatchdog
    case 2: self = .sleepEnterWait
    case 3: self = .noRadio
    case 4: self = .unspecified
    case 5: self = .ubloxUnitFailed
    case 6: self = .noAxp192
    case 7: self = .invalidRadioSetting
    case 8: self = .transmitFailed
    case 9: self = .brownout
    case 10: self = .sx1262Failure
    case 11: self = .radioSpiBug
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .txWatchdog: return 1
    case .sleepEnterWait: return 2
    case .noRadio: return 3
    case .unspecified: return 4
    case .ubloxUnitFailed: return 5
    case .noAxp192: return 6
    case .invalidRadioSetting: return 7
    case .transmitFailed: return 8
    case .brownout: return 9
    case .sx1262Failure: return 10
    case .radioSpiBug: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CriticalErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CriticalErrorCode] = [
    .none,
    .txWatchdog,
    .sleepEnterWait,
    .noRadio,
    .unspecified,
    .ubloxUnitFailed,
    .noAxp192,
    .invalidRadioSetting,
    .transmitFailed,
    .brownout,
    .sx1262Failure,
    .radioSpiBug,
  ]
}

#endif  // swift(>=4.2)

///
/// a gps position
struct Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The new preferred location encoding, multiply by 1e-7 to get degrees
  /// in floating point
  var latitudeI: Int32 {
    get {return _storage._latitudeI}
    set {_uniqueStorage()._latitudeI = newValue}
  }

  ///
  /// TODO: REPLACE
  var longitudeI: Int32 {
    get {return _storage._longitudeI}
    set {_uniqueStorage()._longitudeI = newValue}
  }

  ///
  /// In meters above MSL (but see issue #359)
  var altitude: Int32 {
    get {return _storage._altitude}
    set {_uniqueStorage()._altitude = newValue}
  }

  ///
  /// This is usually not sent over the mesh (to save space), but it is sent
  /// from the phone so that the local device can set its RTC If it is sent over
  /// the mesh (because there are devices on the mesh without GPS), it will only
  /// be sent by devices which has a hardware GPS clock.
  /// seconds since 1970
  var time: UInt32 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  ///
  /// TODO: REPLACE
  var locationSource: Position.LocSource {
    get {return _storage._locationSource}
    set {_uniqueStorage()._locationSource = newValue}
  }

  ///
  /// TODO: REPLACE
  var altitudeSource: Position.AltSource {
    get {return _storage._altitudeSource}
    set {_uniqueStorage()._altitudeSource = newValue}
  }

  ///
  /// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
  var timestamp: UInt32 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  ///
  /// Pos. timestamp milliseconds adjustment (rarely available or required)
  var timestampMillisAdjust: Int32 {
    get {return _storage._timestampMillisAdjust}
    set {_uniqueStorage()._timestampMillisAdjust = newValue}
  }

  ///
  /// HAE altitude in meters - can be used instead of MSL altitude
  var altitudeHae: Int32 {
    get {return _storage._altitudeHae}
    set {_uniqueStorage()._altitudeHae = newValue}
  }

  ///
  /// Geoidal separation in meters
  var altitudeGeoidalSeparation: Int32 {
    get {return _storage._altitudeGeoidalSeparation}
    set {_uniqueStorage()._altitudeGeoidalSeparation = newValue}
  }

  ///
  /// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
  /// - PDOP is sufficient for most cases
  /// - for higher precision scenarios, HDOP and VDOP can be used instead,
  ///   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
  /// TODO: REMOVE/INTEGRATE
  var pdop: UInt32 {
    get {return _storage._pdop}
    set {_uniqueStorage()._pdop = newValue}
  }

  ///
  /// TODO: REPLACE
  var hdop: UInt32 {
    get {return _storage._hdop}
    set {_uniqueStorage()._hdop = newValue}
  }

  ///
  /// TODO: REPLACE
  var vdop: UInt32 {
    get {return _storage._vdop}
    set {_uniqueStorage()._vdop = newValue}
  }

  ///
  /// GPS accuracy (a hardware specific constant) in mm
  ///   multiplied with DOP to calculate positional accuracy
  /// Default: "'bout three meters-ish" :)
  var gpsAccuracy: UInt32 {
    get {return _storage._gpsAccuracy}
    set {_uniqueStorage()._gpsAccuracy = newValue}
  }

  ///
  /// Ground speed in m/s and True North TRACK in 1/100 degrees
  /// Clarification of terms:
  /// - "track" is the direction of motion (measured in horizontal plane)
  /// - "heading" is where the fuselage points (measured in horizontal plane)
  /// - "yaw" indicates a relative rotation about the vertical axis
  /// TODO: REMOVE/INTEGRATE
  var groundSpeed: UInt32 {
    get {return _storage._groundSpeed}
    set {_uniqueStorage()._groundSpeed = newValue}
  }

  ///
  /// TODO: REPLACE
  var groundTrack: UInt32 {
    get {return _storage._groundTrack}
    set {_uniqueStorage()._groundTrack = newValue}
  }

  ///
  /// GPS fix quality (from NMEA GxGGA statement or similar)
  var fixQuality: UInt32 {
    get {return _storage._fixQuality}
    set {_uniqueStorage()._fixQuality = newValue}
  }

  ///
  /// GPS fix type 2D/3D (from NMEA GxGSA statement)
  var fixType: UInt32 {
    get {return _storage._fixType}
    set {_uniqueStorage()._fixType = newValue}
  }

  ///
  /// GPS "Satellites in View" number
  var satsInView: UInt32 {
    get {return _storage._satsInView}
    set {_uniqueStorage()._satsInView = newValue}
  }

  ///
  /// Sensor ID - in case multiple positioning sensors are being used
  var sensorID: UInt32 {
    get {return _storage._sensorID}
    set {_uniqueStorage()._sensorID = newValue}
  }

  ///
  /// Estimated/expected time (in seconds) until next update:
  /// - if we update at fixed intervals of X seconds, use X
  /// - if we update at dynamic intervals (based on relative movement etc),
  ///   but "AT LEAST every Y seconds", use Y
  var nextUpdate: UInt32 {
    get {return _storage._nextUpdate}
    set {_uniqueStorage()._nextUpdate = newValue}
  }

  ///
  /// A sequence number, incremented with each Position message to help
  ///   detect lost updates if needed
  var seqNumber: UInt32 {
    get {return _storage._seqNumber}
    set {_uniqueStorage()._seqNumber = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// How the location was acquired: manual, onboard GPS, external (EUD) GPS
  enum LocSource: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case locUnset // = 0

    ///
    /// TODO: REPLACE
    case locManual // = 1

    ///
    /// TODO: REPLACE
    case locInternal // = 2

    ///
    /// TODO: REPLACE
    case locExternal // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .locUnset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnset
      case 1: self = .locManual
      case 2: self = .locInternal
      case 3: self = .locExternal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .locUnset: return 0
      case .locManual: return 1
      case .locInternal: return 2
      case .locExternal: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///
  /// How the altitude was acquired: manual, GPS int/ext, etc
  /// Default: same as location_source if present
  enum AltSource: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case altUnset // = 0

    ///
    /// TODO: REPLACE
    case altManual // = 1

    ///
    /// TODO: REPLACE
    case altInternal // = 2

    ///
    /// TODO: REPLACE
    case altExternal // = 3

    ///
    /// TODO: REPLACE
    case altBarometric // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .altUnset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .altUnset
      case 1: self = .altManual
      case 2: self = .altInternal
      case 3: self = .altExternal
      case 4: self = .altBarometric
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .altUnset: return 0
      case .altManual: return 1
      case .altInternal: return 2
      case .altExternal: return 3
      case .altBarometric: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Position.LocSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Position.LocSource] = [
    .locUnset,
    .locManual,
    .locInternal,
    .locExternal,
  ]
}

extension Position.AltSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Position.AltSource] = [
    .altUnset,
    .altManual,
    .altInternal,
    .altExternal,
    .altBarometric,
  ]
}

#endif  // swift(>=4.2)

///
/// Broadcast when a newly powered mesh node wants to find a node num it can use
/// Sent from the phone over bluetooth to set the user id for the owner of this node.
/// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
/// The algorithm is as follows:
/// when a node starts up, it broadcasts their user and the normal flow is for all
/// other nodes to reply with their User as well (so the new node can build its nodedb)
/// If a node ever receives a User (not just the first broadcast) message where
/// the sender node number equals our node number, that indicates a collision has
/// occurred and the following steps should happen:
/// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
/// new User who just tried to sign in: it gets to keep its nodenum.
/// We send a broadcast message of OUR User (we use a broadcast so that the other node can
/// receive our message, considering we have the same id - it also serves to let
/// observers correct their nodedb) - this case is rare so it should be okay.
/// If any node receives a User where the macaddr is GTE than their local macaddr,
/// they have been vetoed and should pick a new random nodenum (filtering against
/// whatever it knows about the nodedb) and rebroadcast their User.
/// A few nodenums are reserved and will never be requested:
/// 0xff - broadcast
/// 0 through 3 - for future use
struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A globally unique ID string for this user.
  /// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
  /// Note: app developers are encouraged to also use the following standard
  /// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
  var id: String = String()

  ///
  /// A full name for this user, i.e. "Kevin Hester"
  var longName: String = String()

  ///
  /// A VERY short name, ideally two characters.
  /// Suitable for a tiny OLED screen
  var shortName: String = String()

  ///
  /// This is the addr of the radio.
  /// Not populated by the phone, but added by the esp32 when broadcasting
  var macaddr: Data = Data()

  ///
  /// TBEAM, HELTEC, etc...
  /// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
  /// Apps will still need the string here for older builds
  /// (so OTA update can find the right image), but if the enum is available it will be used instead.
  var hwModel: HardwareModel = .unset

  ///
  /// In some regions Ham radio operators have different bandwidth limitations than others.
  /// If this user is a licensed operator, set this flag.
  /// Also, "long_name" should be their licence number.
  var isLicensed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
struct RouteDiscovery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The list of nodenums this packet has visited so far
  var route: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A Routing control Data packet handled by the routing module
struct Routing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variant: Routing.OneOf_Variant? = nil

  ///
  /// A route request going from the requester
  var routeRequest: RouteDiscovery {
    get {
      if case .routeRequest(let v)? = variant {return v}
      return RouteDiscovery()
    }
    set {variant = .routeRequest(newValue)}
  }

  ///
  /// A route reply
  var routeReply: RouteDiscovery {
    get {
      if case .routeReply(let v)? = variant {return v}
      return RouteDiscovery()
    }
    set {variant = .routeReply(newValue)}
  }

  ///
  /// A failure in delivering a message (usually used for routing control messages, but might be provided
  /// in addition to ack.fail_id to provide details on the type of failure).
  var errorReason: Routing.Error {
    get {
      if case .errorReason(let v)? = variant {return v}
      return .none
    }
    set {variant = .errorReason(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Variant: Equatable {
    ///
    /// A route request going from the requester
    case routeRequest(RouteDiscovery)
    ///
    /// A route reply
    case routeReply(RouteDiscovery)
    ///
    /// A failure in delivering a message (usually used for routing control messages, but might be provided
    /// in addition to ack.fail_id to provide details on the type of failure).
    case errorReason(Routing.Error)

  #if !swift(>=4.1)
    static func ==(lhs: Routing.OneOf_Variant, rhs: Routing.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.routeRequest, .routeRequest): return {
        guard case .routeRequest(let l) = lhs, case .routeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.routeReply, .routeReply): return {
        guard case .routeReply(let l) = lhs, case .routeReply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorReason, .errorReason): return {
        guard case .errorReason(let l) = lhs, case .errorReason(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
  /// details on the type of failure).
  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// This message is not a failure
    case none // = 0

    ///
    /// Our node doesn't have a route to the requested destination anymore.
    case noRoute // = 1

    ///
    /// We received a nak while trying to forward on your behalf
    case gotNak // = 2

    ///
    /// TODO: REPLACE
    case timeout // = 3

    ///
    /// No suitable interface could be found for delivering this packet
    case noInterface // = 4

    ///
    /// We reached the max retransmission count (typically for naive flood routing)
    case maxRetransmit // = 5

    ///
    /// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
    case noChannel // = 6

    ///
    /// The packet was too big for sending (exceeds interface MTU after encoding)
    case tooLarge // = 7

    ///
    /// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
    /// (possibly due to bad channel permissions)
    case noResponse // = 8

    ///
    /// Cannot send currently because duty cycle regulations will be violated.
    case dutyCycleLimit // = 9

    ///
    /// The application layer service on the remote node received your request, but considered your request somehow invalid
    case badRequest // = 32

    ///
    /// The application layer service on the remote node received your request, but considered your request not authorized
    /// (i.e you did not send the request on the required bound channel)
    case notAuthorized // = 33
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .noRoute
      case 2: self = .gotNak
      case 3: self = .timeout
      case 4: self = .noInterface
      case 5: self = .maxRetransmit
      case 6: self = .noChannel
      case 7: self = .tooLarge
      case 8: self = .noResponse
      case 9: self = .dutyCycleLimit
      case 32: self = .badRequest
      case 33: self = .notAuthorized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .noRoute: return 1
      case .gotNak: return 2
      case .timeout: return 3
      case .noInterface: return 4
      case .maxRetransmit: return 5
      case .noChannel: return 6
      case .tooLarge: return 7
      case .noResponse: return 8
      case .dutyCycleLimit: return 9
      case .badRequest: return 32
      case .notAuthorized: return 33
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Routing.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routing.Error] = [
    .none,
    .noRoute,
    .gotNak,
    .timeout,
    .noInterface,
    .maxRetransmit,
    .noChannel,
    .tooLarge,
    .noResponse,
    .dutyCycleLimit,
    .badRequest,
    .notAuthorized,
  ]
}

#endif  // swift(>=4.2)

///
/// (Formerly called SubPacket)
/// The payload portion fo a packet, this is the actual bytes that are sent
/// inside a radio packet (because from/to are broken out by the comms library)
struct DataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Formerly named typ and of type Type
  var portnum: PortNum = .unknownApp

  ///
  /// TODO: REPLACE
  var payload: Data = Data()

  ///
  /// Not normally used, but for testing a sender can request that recipient
  /// responds in kind (i.e. if it received a position, it should unicast back it's position).
  /// Note: that if you set this on a broadcast you will receive many replies.
  var wantResponse: Bool = false

  ///
  /// The address of the destination node.
  /// This field is is filled in by the mesh radio device software, application
  /// layer software should never need it.
  /// RouteDiscovery messages _must_ populate this.
  /// Other message types might need to if they are doing multihop routing.
  var dest: UInt32 = 0

  ///
  /// The address of the original sender for this message.
  /// This field should _only_ be populated for reliable multihop packets (to keep
  /// packets small).
  var source: UInt32 = 0

  ///
  /// Only used in routing or response messages.
  /// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
  var requestID: UInt32 = 0

  ///
  /// If set, this message is intened to be a reply to a previously sent message with the defined id.
  var replyID: UInt32 = 0

  ///
  /// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
  /// a message a heart or poop emoji.
  var emoji: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Waypoint message, used to share arbitrary locations across the mesh
struct Waypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Id of the waypoint
  var id: UInt32 = 0

  ///
  /// latitude_i
  var latitudeI: Int32 = 0

  ///
  /// longitude_i
  var longitudeI: Int32 = 0

  ///
  /// Time the waypoint is to expire (epoch)
  var expire: UInt32 = 0

  ///
  /// If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
  /// If zero, the waypoint is open to be edited by any member of the mesh.
  var lockedTo: UInt32 = 0

  ///
  /// Name of the waypoint - max 30 chars
  var name: String = String()

  ///
  /// Description of the waypoint - max 100 chars
  var description_p: String = String()

  ///
  /// Designator icon for the waypoint in the form of a unicode emoji
  var icon: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A packet envelope sent/received over the mesh
/// only payload_variant is sent in the payload portion of the LORA packet.
/// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
struct MeshPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The sending node number.
  /// Note: Our crypto implementation uses this field as well.
  /// See [crypto](/docs/overview/encryption) for details.
  /// FIXME - really should be fixed32 instead, this encoding only hurts the ble link though.
  var from: UInt32 {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  ///
  /// The (immediatSee Priority description for more details.y should be fixed32 instead, this encoding only
  /// hurts the ble link though.
  var to: UInt32 {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  ///
  /// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
  /// If unset, packet was on the primary channel.
  /// A particular node might know only a subset of channels in use on the mesh.
  /// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
  /// Very briefly, while sending and receiving deep inside the device Router code, this field instead
  /// contains the 'channel hash' instead of the index.
  /// This 'trick' is only used while the payload_variant is an 'encrypted'.
  var channel: UInt32 {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  var payloadVariant: OneOf_PayloadVariant? {
    get {return _storage._payloadVariant}
    set {_uniqueStorage()._payloadVariant = newValue}
  }

  ///
  /// TODO: REPLACE
  var decoded: DataMessage {
    get {
      if case .decoded(let v)? = _storage._payloadVariant {return v}
      return DataMessage()
    }
    set {_uniqueStorage()._payloadVariant = .decoded(newValue)}
  }

  ///
  /// TODO: REPLACE
  var encrypted: Data {
    get {
      if case .encrypted(let v)? = _storage._payloadVariant {return v}
      return Data()
    }
    set {_uniqueStorage()._payloadVariant = .encrypted(newValue)}
  }

  ///
  /// A unique ID for this packet.
  /// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
  /// Otherwise a unique ID for this packet, useful for flooding algorithms.
  /// ID only needs to be unique on a _per sender_ basis, and it only
  /// needs to be unique for a few minutes (long enough to last for the length of
  /// any ACK or the completion of a mesh broadcast flood).
  /// Note: Our crypto implementation uses this id as well.
  /// See [crypto](/docs/overview/encryption) for details.
  /// FIXME - really should be fixed32 instead, this encoding only
  /// hurts the ble link though.
  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///
  /// The time this message was received by the esp32 (secs since 1970).
  /// Note: this field is _never_ sent on the radio link itself (to save space) Times
  /// are typically not sent over the mesh, but they will be added to any Packet
  /// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
  var rxTime: UInt32 {
    get {return _storage._rxTime}
    set {_uniqueStorage()._rxTime = newValue}
  }

  ///
  /// *Never* sent over the radio links.
  /// Set during reception to indicate the SNR of this packet.
  /// Used to collect statistics on current link quality.
  var rxSnr: Float {
    get {return _storage._rxSnr}
    set {_uniqueStorage()._rxSnr = newValue}
  }

  ///
  /// If unset treated as zero (no forwarding, send to adjacent nodes only)
  /// if 1, allow hopping through one node, etc...
  /// For our usecase real world topologies probably have a max of about 3.
  /// This field is normally placed into a few of bits in the header.
  var hopLimit: UInt32 {
    get {return _storage._hopLimit}
    set {_uniqueStorage()._hopLimit = newValue}
  }

  ///
  /// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
  /// We would like to receive a ack packet in response.
  /// Broadcasts messages treat this flag specially: Since acks for broadcasts would
  /// rapidly flood the channel, the normal ack behavior is suppressed.
  /// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
  /// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
  /// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
  /// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
  /// Note: This flag is normally sent in a flag bit in the header when sent over the wire
  var wantAck: Bool {
    get {return _storage._wantAck}
    set {_uniqueStorage()._wantAck = newValue}
  }

  ///
  /// The priority of this message for sending.
  /// See MeshPacket.Priority description for more details.
  var priority: MeshPacket.Priority {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  ///
  /// rssi of received packet. Only sent to phone for dispay purposes.
  var rxRssi: Int32 {
    get {return _storage._rxRssi}
    set {_uniqueStorage()._rxRssi = newValue}
  }

  ///
  /// Describe if this message is delayed
  var delayed: MeshPacket.Delayed {
    get {return _storage._delayed}
    set {_uniqueStorage()._delayed = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable {
    ///
    /// TODO: REPLACE
    case decoded(DataMessage)
    ///
    /// TODO: REPLACE
    case encrypted(Data)

  #if !swift(>=4.1)
    static func ==(lhs: MeshPacket.OneOf_PayloadVariant, rhs: MeshPacket.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.decoded, .decoded): return {
        guard case .decoded(let l) = lhs, case .decoded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.encrypted, .encrypted): return {
        guard case .encrypted(let l) = lhs, case .encrypted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// The priority of this message for sending.
  /// Higher priorities are sent first (when managing the transmit queue).
  /// This field is never sent over the air, it is only used internally inside of a local device node.
  /// API clients (either on the local node or connected directly to the node)
  /// can set this parameter if necessary.
  /// (values must be <= 127 to keep protobuf field to one byte in size.
  /// Detailed background on this field:
  /// I noticed a funny side effect of lora being so slow: Usually when making
  /// a protocol there isn’t much need to use message priority to change the order
  /// of transmission (because interfaces are fairly fast).
  /// But for lora where packets can take a few seconds each, it is very important
  /// to make sure that critical packets are sent ASAP.
  /// In the case of meshtastic that means we want to send protocol acks as soon as possible
  /// (to prevent unneeded retransmissions), we want routing messages to be sent next,
  /// then messages marked as reliable and finally ‘background’ packets like periodic position updates.
  /// So I bit the bullet and implemented a new (internal - not sent over the air)
  /// field in MeshPacket called ‘priority’.
  /// And the transmission queue in the router object is now a priority queue.
  enum Priority: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// Treated as Priority.DEFAULT
    case unset // = 0

    ///
    /// TODO: REPLACE
    case min // = 1

    ///
    /// Background position updates are sent with very low priority -
    /// if the link is super congested they might not go out at all
    case background // = 10

    ///
    /// This priority is used for most messages that don't have a priority set
    case `default` // = 64

    ///
    /// If priority is unset but the message is marked as want_ack,
    /// assume it is important and use a slightly higher priority
    case reliable // = 70

    ///
    /// Ack/naks are sent with very high priority to ensure that retransmission
    /// stops as soon as possible
    case ack // = 120

    ///
    /// TODO: REPLACE
    case max // = 127
    case UNRECOGNIZED(Int)

    init() {
      self = .unset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .min
      case 10: self = .background
      case 64: self = .default
      case 70: self = .reliable
      case 120: self = .ack
      case 127: self = .max
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unset: return 0
      case .min: return 1
      case .background: return 10
      case .default: return 64
      case .reliable: return 70
      case .ack: return 120
      case .max: return 127
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///
  /// Identify if this is a delayed packet
  enum Delayed: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// If unset, the message is being sent in real time.
    case noDelay // = 0

    ///
    /// The message is delayed and was originally a broadcast
    case broadcast // = 1

    ///
    /// The message is delayed and was originally a direct message
    case direct // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .noDelay
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noDelay
      case 1: self = .broadcast
      case 2: self = .direct
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noDelay: return 0
      case .broadcast: return 1
      case .direct: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension MeshPacket.Priority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MeshPacket.Priority] = [
    .unset,
    .min,
    .background,
    .default,
    .reliable,
    .ack,
    .max,
  ]
}

extension MeshPacket.Delayed: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MeshPacket.Delayed] = [
    .noDelay,
    .broadcast,
    .direct,
  ]
}

#endif  // swift(>=4.2)

///
/// The bluetooth to device link:
/// Old BTLE protocol docs from TODO, merge in above and make real docs...
/// use protocol buffers, and NanoPB
/// messages from device to phone:
/// POSITION_UPDATE (..., time)
/// TEXT_RECEIVED(from, text, time)
/// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
/// messages from phone to device:
/// SET_MYID(id, human readable long, human readable short) (send down the unique ID
/// string used for this node, a human readable string shown for that id, and a very
/// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
/// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
/// nodes() (returns list of nodes, with full info, last time seen, loc, battery
/// level etc) SET_CONFIG (switches device to a new set of radio params and
/// preshared key, drops all existing nodes, force our node to rejoin this new group)
/// Full information about a node on the mesh
struct NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The node number
  var num: UInt32 = 0

  ///
  /// The user info for this node
  var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  ///
  /// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
  /// Position.time now indicates the last time we received a POSITION from that node.
  var position: Position {
    get {return _position ?? Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  ///
  /// Returns the Signal-to-noise ratio (SNR) of the last received message,
  /// as measured by the receiver. Return SNR of the last received message in dB
  var snr: Float = 0

  ///
  /// Set to indicate the last time we received a packet from this node
  var lastHeard: UInt32 = 0

  ///
  /// The latest device metrics for the node.
  var deviceMetrics: DeviceMetrics {
    get {return _deviceMetrics ?? DeviceMetrics()}
    set {_deviceMetrics = newValue}
  }
  /// Returns true if `deviceMetrics` has been explicitly set.
  var hasDeviceMetrics: Bool {return self._deviceMetrics != nil}
  /// Clears the value of `deviceMetrics`. Subsequent reads from it will return its default value.
  mutating func clearDeviceMetrics() {self._deviceMetrics = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: User? = nil
  fileprivate var _position: Position? = nil
  fileprivate var _deviceMetrics: DeviceMetrics? = nil
}

///
/// Unique local debugging info for this node
/// Note: we don't include position or the user info, because that will come in the
/// Sent to the phone in response to WantNodes.
struct MyNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Tells the phone what our node number is, default starting value is
  /// lowbyte of macaddr, but it will be fixed if that is already in use
  var myNodeNum: UInt32 = 0

  ///
  /// Note: This flag merely means we detected a hardware GPS in our node.
  /// Not the same as UserPreferences.location_sharing
  var hasGps_p: Bool = false

  ///
  /// The maximum number of 'software' channels that can be set on this node.
  var maxChannels: UInt32 = 0

  ///
  /// 0.0.5 etc...
  var firmwareVersion: String = String()

  ///
  /// An error message we'd like to report back to the mothership through analytics.
  /// It indicates a serious bug occurred on the device, the device coped with it,
  /// but we still want to tell the devs about the bug.
  /// This field will be cleared after the phone reads MyNodeInfo
  /// (i.e. it will only be reported once)
  /// a numeric error code to go with error message, zero means no error
  var errorCode: CriticalErrorCode = .none

  ///
  /// A numeric error address (nonzero if available)
  var errorAddress: UInt32 = 0

  ///
  /// The total number of errors this node has ever encountered
  /// (well - since the last time we discarded preferences)
  var errorCount: UInt32 = 0

  ///
  /// The total number of reboots this node has ever encountered
  /// (well - since the last time we discarded preferences)
  var rebootCount: UInt32 = 0

  ///
  /// Calculated bitrate of the current channel (in Bytes Per Second)
  var bitrate: Float = 0

  ///
  /// How long before we consider a message abandoned and we can clear our
  /// caches of any messages in flight Normally quite large to handle the worst case
  /// message delivery time, 5 minutes.
  /// Formerly called FLOOD_EXPIRE_TIME in the device code
  var messageTimeoutMsec: UInt32 = 0

  ///
  /// The minimum app version that can talk to this device.
  /// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
  var minAppVersion: UInt32 = 0

  ///
  /// 24 time windows of 1hr each with the airtime transmitted out of the device per hour.
  var airPeriodTx: [UInt32] = []

  ///
  /// 24 time windows of 1hr each with the airtime of valid packets for your mesh.
  var airPeriodRx: [UInt32] = []

  ///
  /// Is the device wifi capable?
  var hasWifi_p: Bool = false

  ///
  /// Utilization for the current channel, including well formed TX, RX and malformed RX (aka noise).
  var channelUtilization: Float = 0

  ///
  /// Percent of airtime for transmission used within the last hour.
  var airUtilTx: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Debug output from the device.
/// To minimize the size of records inside the device code, if a time/source/level is not set
/// on the message it is assumed to be a continuation of the previously sent message.
/// This allows the device code to use fixed maxlen 64 byte strings for messages,
/// and then extend as needed by emitting multiple records.
struct LogRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Log levels, chosen to match python logging conventions.
  var message: String = String()

  ///
  /// Seconds since 1970 - or 0 for unknown/unset
  var time: UInt32 = 0

  ///
  /// Usually based on thread name - if known
  var source: String = String()

  ///
  /// Not yet set
  var level: LogRecord.Level = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  enum Level: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// Log levels, chosen to match python logging conventions.
    case unset // = 0

    ///
    /// Log levels, chosen to match python logging conventions.
    case critical // = 50

    ///
    /// Log levels, chosen to match python logging conventions.
    case error // = 40

    ///
    /// Log levels, chosen to match python logging conventions.
    case warning // = 30

    ///
    /// Log levels, chosen to match python logging conventions.
    case info // = 20

    ///
    /// Log levels, chosen to match python logging conventions.
    case debug // = 10

    ///
    /// Log levels, chosen to match python logging conventions.
    case trace // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 5: self = .trace
      case 10: self = .debug
      case 20: self = .info
      case 30: self = .warning
      case 40: self = .error
      case 50: self = .critical
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unset: return 0
      case .trace: return 5
      case .debug: return 10
      case .info: return 20
      case .warning: return 30
      case .error: return 40
      case .critical: return 50
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension LogRecord.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [LogRecord.Level] = [
    .unset,
    .critical,
    .error,
    .warning,
    .info,
    .debug,
    .trace,
  ]
}

#endif  // swift(>=4.2)

struct QueueStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Last attempt to queue status, ErrorCode 
  var res: Int32 = 0

  /// Free entries in the outgoing queue 
  var free: UInt32 = 0

  /// Maximum entries in the outgoing queue 
  var maxlen: UInt32 = 0

  /// What was mesh packet id that generated this response? 
  var meshPacketID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Packets from the radio to the phone will appear on the fromRadio characteristic.
/// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
/// It will sit in that descriptor until consumed by the phone,
/// at which point the next item in the FIFO will be populated.
struct FromRadio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The packet id, used to allow the phone to request missing read packets from the FIFO,
  /// see our bluetooth docs
  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///
  /// Log levels, chosen to match python logging conventions.
  var payloadVariant: OneOf_PayloadVariant? {
    get {return _storage._payloadVariant}
    set {_uniqueStorage()._payloadVariant = newValue}
  }

  ///
  /// Log levels, chosen to match python logging conventions.
  var packet: MeshPacket {
    get {
      if case .packet(let v)? = _storage._payloadVariant {return v}
      return MeshPacket()
    }
    set {_uniqueStorage()._payloadVariant = .packet(newValue)}
  }

  ///
  /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  var myInfo: MyNodeInfo {
    get {
      if case .myInfo(let v)? = _storage._payloadVariant {return v}
      return MyNodeInfo()
    }
    set {_uniqueStorage()._payloadVariant = .myInfo(newValue)}
  }

  ///
  /// One packet is sent for each node in the on radio DB
  /// starts over with the first node in our DB
  var nodeInfo: NodeInfo {
    get {
      if case .nodeInfo(let v)? = _storage._payloadVariant {return v}
      return NodeInfo()
    }
    set {_uniqueStorage()._payloadVariant = .nodeInfo(newValue)}
  }

  ///
  /// Include a part of the config (was: RadioConfig radio)
  var config: Config {
    get {
      if case .config(let v)? = _storage._payloadVariant {return v}
      return Config()
    }
    set {_uniqueStorage()._payloadVariant = .config(newValue)}
  }

  ///
  /// Set to send debug console output over our protobuf stream
  var logRecord: LogRecord {
    get {
      if case .logRecord(let v)? = _storage._payloadVariant {return v}
      return LogRecord()
    }
    set {_uniqueStorage()._payloadVariant = .logRecord(newValue)}
  }

  ///
  /// Sent as true once the device has finished sending all of the responses to want_config
  /// recipient should check if this ID matches our original request nonce, if
  /// not, it means your config responses haven't started yet.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  var configCompleteID: UInt32 {
    get {
      if case .configCompleteID(let v)? = _storage._payloadVariant {return v}
      return 0
    }
    set {_uniqueStorage()._payloadVariant = .configCompleteID(newValue)}
  }

  ///
  /// Sent to tell clients the radio has just rebooted.
  /// Set to true if present.
  /// Not used on all transports, currently just used for the serial console.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  var rebooted: Bool {
    get {
      if case .rebooted(let v)? = _storage._payloadVariant {return v}
      return false
    }
    set {_uniqueStorage()._payloadVariant = .rebooted(newValue)}
  }

  ///
  /// Include module config
  var moduleConfig: ModuleConfig {
    get {
      if case .moduleConfig(let v)? = _storage._payloadVariant {return v}
      return ModuleConfig()
    }
    set {_uniqueStorage()._payloadVariant = .moduleConfig(newValue)}
  }

  ///
  /// One packet is sent for each channel
  var channel: Channel {
    get {
      if case .channel(let v)? = _storage._payloadVariant {return v}
      return Channel()
    }
    set {_uniqueStorage()._payloadVariant = .channel(newValue)}
  }

  ///
  /// Queue status info
  var queueStatus: QueueStatus {
    get {
      if case .queueStatus(let v)? = _storage._payloadVariant {return v}
      return QueueStatus()
    }
    set {_uniqueStorage()._payloadVariant = .queueStatus(newValue)}
  }

  ///
  /// File Transfer Chunk
  var xmodemPacket: XModem {
    get {
      if case .xmodemPacket(let v)? = _storage._payloadVariant {return v}
      return XModem()
    }
    set {_uniqueStorage()._payloadVariant = .xmodemPacket(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  enum OneOf_PayloadVariant: Equatable {
    ///
    /// Log levels, chosen to match python logging conventions.
    case packet(MeshPacket)
    ///
    /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case myInfo(MyNodeInfo)
    ///
    /// One packet is sent for each node in the on radio DB
    /// starts over with the first node in our DB
    case nodeInfo(NodeInfo)
    ///
    /// Include a part of the config (was: RadioConfig radio)
    case config(Config)
    ///
    /// Set to send debug console output over our protobuf stream
    case logRecord(LogRecord)
    ///
    /// Sent as true once the device has finished sending all of the responses to want_config
    /// recipient should check if this ID matches our original request nonce, if
    /// not, it means your config responses haven't started yet.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case configCompleteID(UInt32)
    ///
    /// Sent to tell clients the radio has just rebooted.
    /// Set to true if present.
    /// Not used on all transports, currently just used for the serial console.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case rebooted(Bool)
    ///
    /// Include module config
    case moduleConfig(ModuleConfig)
    ///
    /// One packet is sent for each channel
    case channel(Channel)
    ///
    /// Queue status info
    case queueStatus(QueueStatus)
    ///
    /// File Transfer Chunk
    case xmodemPacket(XModem)

  #if !swift(>=4.1)
    static func ==(lhs: FromRadio.OneOf_PayloadVariant, rhs: FromRadio.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.packet, .packet): return {
        guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.myInfo, .myInfo): return {
        guard case .myInfo(let l) = lhs, case .myInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nodeInfo, .nodeInfo): return {
        guard case .nodeInfo(let l) = lhs, case .nodeInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logRecord, .logRecord): return {
        guard case .logRecord(let l) = lhs, case .logRecord(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configCompleteID, .configCompleteID): return {
        guard case .configCompleteID(let l) = lhs, case .configCompleteID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rebooted, .rebooted): return {
        guard case .rebooted(let l) = lhs, case .rebooted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.moduleConfig, .moduleConfig): return {
        guard case .moduleConfig(let l) = lhs, case .moduleConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channel, .channel): return {
        guard case .channel(let l) = lhs, case .channel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.queueStatus, .queueStatus): return {
        guard case .queueStatus(let l) = lhs, case .queueStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xmodemPacket, .xmodemPacket): return {
        guard case .xmodemPacket(let l) = lhs, case .xmodemPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
/// Once the write completes the phone can assume it is handled.
struct ToRadio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Log levels, chosen to match python logging conventions.
  var payloadVariant: ToRadio.OneOf_PayloadVariant? = nil

  ///
  /// Send this packet on the mesh
  var packet: MeshPacket {
    get {
      if case .packet(let v)? = payloadVariant {return v}
      return MeshPacket()
    }
    set {payloadVariant = .packet(newValue)}
  }

  ///
  /// Phone wants radio to send full node db to the phone, This is
  /// typically the first packet sent to the radio when the phone gets a
  /// bluetooth connection. The radio will respond by sending back a
  /// MyNodeInfo, a owner, a radio config and a series of
  /// FromRadio.node_infos, and config_complete
  /// the integer you write into this field will be reported back in the
  /// config_complete_id response this allows clients to never be confused by
  /// a stale old partially sent config.
  var wantConfigID: UInt32 {
    get {
      if case .wantConfigID(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .wantConfigID(newValue)}
  }

  ///
  /// Tell API server we are disconnecting now.
  /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
  /// (Sending this message is optional for clients)
  var disconnect: Bool {
    get {
      if case .disconnect(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .disconnect(newValue)}
  }

  var xmodemPacket: XModem {
    get {
      if case .xmodemPacket(let v)? = payloadVariant {return v}
      return XModem()
    }
    set {payloadVariant = .xmodemPacket(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  enum OneOf_PayloadVariant: Equatable {
    ///
    /// Send this packet on the mesh
    case packet(MeshPacket)
    ///
    /// Phone wants radio to send full node db to the phone, This is
    /// typically the first packet sent to the radio when the phone gets a
    /// bluetooth connection. The radio will respond by sending back a
    /// MyNodeInfo, a owner, a radio config and a series of
    /// FromRadio.node_infos, and config_complete
    /// the integer you write into this field will be reported back in the
    /// config_complete_id response this allows clients to never be confused by
    /// a stale old partially sent config.
    case wantConfigID(UInt32)
    ///
    /// Tell API server we are disconnecting now.
    /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
    /// (Sending this message is optional for clients)
    case disconnect(Bool)
    case xmodemPacket(XModem)

  #if !swift(>=4.1)
    static func ==(lhs: ToRadio.OneOf_PayloadVariant, rhs: ToRadio.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.packet, .packet): return {
        guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wantConfigID, .wantConfigID): return {
        guard case .wantConfigID(let l) = lhs, case .wantConfigID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disconnect, .disconnect): return {
        guard case .disconnect(let l) = lhs, case .disconnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xmodemPacket, .xmodemPacket): return {
        guard case .xmodemPacket(let l) = lhs, case .xmodemPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///
/// Compressed message payload
struct Compressed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// PortNum to determine the how to handle the compressed payload.
  var portnum: PortNum = .unknownApp

  ///
  /// Compressed data.
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HardwareModel: @unchecked Sendable {}
extension Constants: @unchecked Sendable {}
extension CriticalErrorCode: @unchecked Sendable {}
extension Position: @unchecked Sendable {}
extension Position.LocSource: @unchecked Sendable {}
extension Position.AltSource: @unchecked Sendable {}
extension User: @unchecked Sendable {}
extension RouteDiscovery: @unchecked Sendable {}
extension Routing: @unchecked Sendable {}
extension Routing.OneOf_Variant: @unchecked Sendable {}
extension Routing.Error: @unchecked Sendable {}
extension DataMessage: @unchecked Sendable {}
extension Waypoint: @unchecked Sendable {}
extension MeshPacket: @unchecked Sendable {}
extension MeshPacket.OneOf_PayloadVariant: @unchecked Sendable {}
extension MeshPacket.Priority: @unchecked Sendable {}
extension MeshPacket.Delayed: @unchecked Sendable {}
extension NodeInfo: @unchecked Sendable {}
extension MyNodeInfo: @unchecked Sendable {}
extension LogRecord: @unchecked Sendable {}
extension LogRecord.Level: @unchecked Sendable {}
extension QueueStatus: @unchecked Sendable {}
extension FromRadio: @unchecked Sendable {}
extension FromRadio.OneOf_PayloadVariant: @unchecked Sendable {}
extension ToRadio: @unchecked Sendable {}
extension ToRadio.OneOf_PayloadVariant: @unchecked Sendable {}
extension Compressed: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension HardwareModel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "TLORA_V2"),
    2: .same(proto: "TLORA_V1"),
    3: .same(proto: "TLORA_V2_1_1P6"),
    4: .same(proto: "TBEAM"),
    5: .same(proto: "HELTEC_V2_0"),
    6: .same(proto: "TBEAM_V0P7"),
    7: .same(proto: "T_ECHO"),
    8: .same(proto: "TLORA_V1_1P3"),
    9: .same(proto: "RAK4631"),
    10: .same(proto: "HELTEC_V2_1"),
    11: .same(proto: "HELTEC_V1"),
    12: .same(proto: "LILYGO_TBEAM_S3_CORE"),
    13: .same(proto: "RAK11200"),
    14: .same(proto: "NANO_G1"),
    15: .same(proto: "TLORA_V2_1_1P8"),
    16: .same(proto: "TLORA_T3_S3"),
    25: .same(proto: "STATION_G1"),
    32: .same(proto: "LORA_RELAY_V1"),
    33: .same(proto: "NRF52840DK"),
    34: .same(proto: "PPR"),
    35: .same(proto: "GENIEBLOCKS"),
    36: .same(proto: "NRF52_UNKNOWN"),
    37: .same(proto: "PORTDUINO"),
    38: .same(proto: "ANDROID_SIM"),
    39: .same(proto: "DIY_V1"),
    40: .same(proto: "NRF52840_PCA10059"),
    41: .same(proto: "DR_DEV"),
    42: .same(proto: "M5STACK"),
    43: .same(proto: "HELTEC_V3"),
    44: .same(proto: "HELTEC_WSL_V3"),
    45: .same(proto: "BETAFPV_2400_TX"),
    255: .same(proto: "PRIVATE_HW"),
  ]
}

extension Constants: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ZERO"),
    237: .same(proto: "DATA_PAYLOAD_LEN"),
  ]
}

extension CriticalErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "TX_WATCHDOG"),
    2: .same(proto: "SLEEP_ENTER_WAIT"),
    3: .same(proto: "NO_RADIO"),
    4: .same(proto: "UNSPECIFIED"),
    5: .same(proto: "UBLOX_UNIT_FAILED"),
    6: .same(proto: "NO_AXP192"),
    7: .same(proto: "INVALID_RADIO_SETTING"),
    8: .same(proto: "TRANSMIT_FAILED"),
    9: .same(proto: "BROWNOUT"),
    10: .same(proto: "SX1262_FAILURE"),
    11: .same(proto: "RADIO_SPI_BUG"),
  ]
}

extension Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_i"),
    2: .standard(proto: "longitude_i"),
    3: .same(proto: "altitude"),
    4: .same(proto: "time"),
    5: .standard(proto: "location_source"),
    6: .standard(proto: "altitude_source"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "timestamp_millis_adjust"),
    9: .standard(proto: "altitude_hae"),
    10: .standard(proto: "altitude_geoidal_separation"),
    11: .same(proto: "PDOP"),
    12: .same(proto: "HDOP"),
    13: .same(proto: "VDOP"),
    14: .standard(proto: "gps_accuracy"),
    15: .standard(proto: "ground_speed"),
    16: .standard(proto: "ground_track"),
    17: .standard(proto: "fix_quality"),
    18: .standard(proto: "fix_type"),
    19: .standard(proto: "sats_in_view"),
    20: .standard(proto: "sensor_id"),
    21: .standard(proto: "next_update"),
    22: .standard(proto: "seq_number"),
  ]

  fileprivate class _StorageClass {
    var _latitudeI: Int32 = 0
    var _longitudeI: Int32 = 0
    var _altitude: Int32 = 0
    var _time: UInt32 = 0
    var _locationSource: Position.LocSource = .locUnset
    var _altitudeSource: Position.AltSource = .altUnset
    var _timestamp: UInt32 = 0
    var _timestampMillisAdjust: Int32 = 0
    var _altitudeHae: Int32 = 0
    var _altitudeGeoidalSeparation: Int32 = 0
    var _pdop: UInt32 = 0
    var _hdop: UInt32 = 0
    var _vdop: UInt32 = 0
    var _gpsAccuracy: UInt32 = 0
    var _groundSpeed: UInt32 = 0
    var _groundTrack: UInt32 = 0
    var _fixQuality: UInt32 = 0
    var _fixType: UInt32 = 0
    var _satsInView: UInt32 = 0
    var _sensorID: UInt32 = 0
    var _nextUpdate: UInt32 = 0
    var _seqNumber: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitudeI = source._latitudeI
      _longitudeI = source._longitudeI
      _altitude = source._altitude
      _time = source._time
      _locationSource = source._locationSource
      _altitudeSource = source._altitudeSource
      _timestamp = source._timestamp
      _timestampMillisAdjust = source._timestampMillisAdjust
      _altitudeHae = source._altitudeHae
      _altitudeGeoidalSeparation = source._altitudeGeoidalSeparation
      _pdop = source._pdop
      _hdop = source._hdop
      _vdop = source._vdop
      _gpsAccuracy = source._gpsAccuracy
      _groundSpeed = source._groundSpeed
      _groundTrack = source._groundTrack
      _fixQuality = source._fixQuality
      _fixType = source._fixType
      _satsInView = source._satsInView
      _sensorID = source._sensorID
      _nextUpdate = source._nextUpdate
      _seqNumber = source._seqNumber
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularSFixed32Field(value: &_storage._latitudeI) }()
        case 2: try { try decoder.decodeSingularSFixed32Field(value: &_storage._longitudeI) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._altitude) }()
        case 4: try { try decoder.decodeSingularFixed32Field(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._locationSource) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._altitudeSource) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._timestampMillisAdjust) }()
        case 9: try { try decoder.decodeSingularSInt32Field(value: &_storage._altitudeHae) }()
        case 10: try { try decoder.decodeSingularSInt32Field(value: &_storage._altitudeGeoidalSeparation) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._pdop) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._hdop) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._vdop) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAccuracy) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundSpeed) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundTrack) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixQuality) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixType) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._satsInView) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._sensorID) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextUpdate) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._seqNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._latitudeI != 0 {
        try visitor.visitSingularSFixed32Field(value: _storage._latitudeI, fieldNumber: 1)
      }
      if _storage._longitudeI != 0 {
        try visitor.visitSingularSFixed32Field(value: _storage._longitudeI, fieldNumber: 2)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularInt32Field(value: _storage._altitude, fieldNumber: 3)
      }
      if _storage._time != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._time, fieldNumber: 4)
      }
      if _storage._locationSource != .locUnset {
        try visitor.visitSingularEnumField(value: _storage._locationSource, fieldNumber: 5)
      }
      if _storage._altitudeSource != .altUnset {
        try visitor.visitSingularEnumField(value: _storage._altitudeSource, fieldNumber: 6)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._timestamp, fieldNumber: 7)
      }
      if _storage._timestampMillisAdjust != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timestampMillisAdjust, fieldNumber: 8)
      }
      if _storage._altitudeHae != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._altitudeHae, fieldNumber: 9)
      }
      if _storage._altitudeGeoidalSeparation != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._altitudeGeoidalSeparation, fieldNumber: 10)
      }
      if _storage._pdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pdop, fieldNumber: 11)
      }
      if _storage._hdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hdop, fieldNumber: 12)
      }
      if _storage._vdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._vdop, fieldNumber: 13)
      }
      if _storage._gpsAccuracy != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsAccuracy, fieldNumber: 14)
      }
      if _storage._groundSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groundSpeed, fieldNumber: 15)
      }
      if _storage._groundTrack != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groundTrack, fieldNumber: 16)
      }
      if _storage._fixQuality != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fixQuality, fieldNumber: 17)
      }
      if _storage._fixType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fixType, fieldNumber: 18)
      }
      if _storage._satsInView != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._satsInView, fieldNumber: 19)
      }
      if _storage._sensorID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sensorID, fieldNumber: 20)
      }
      if _storage._nextUpdate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextUpdate, fieldNumber: 21)
      }
      if _storage._seqNumber != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seqNumber, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Position, rhs: Position) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitudeI != rhs_storage._latitudeI {return false}
        if _storage._longitudeI != rhs_storage._longitudeI {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._locationSource != rhs_storage._locationSource {return false}
        if _storage._altitudeSource != rhs_storage._altitudeSource {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._timestampMillisAdjust != rhs_storage._timestampMillisAdjust {return false}
        if _storage._altitudeHae != rhs_storage._altitudeHae {return false}
        if _storage._altitudeGeoidalSeparation != rhs_storage._altitudeGeoidalSeparation {return false}
        if _storage._pdop != rhs_storage._pdop {return false}
        if _storage._hdop != rhs_storage._hdop {return false}
        if _storage._vdop != rhs_storage._vdop {return false}
        if _storage._gpsAccuracy != rhs_storage._gpsAccuracy {return false}
        if _storage._groundSpeed != rhs_storage._groundSpeed {return false}
        if _storage._groundTrack != rhs_storage._groundTrack {return false}
        if _storage._fixQuality != rhs_storage._fixQuality {return false}
        if _storage._fixType != rhs_storage._fixType {return false}
        if _storage._satsInView != rhs_storage._satsInView {return false}
        if _storage._sensorID != rhs_storage._sensorID {return false}
        if _storage._nextUpdate != rhs_storage._nextUpdate {return false}
        if _storage._seqNumber != rhs_storage._seqNumber {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Position.LocSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNSET"),
    1: .same(proto: "LOC_MANUAL"),
    2: .same(proto: "LOC_INTERNAL"),
    3: .same(proto: "LOC_EXTERNAL"),
  ]
}

extension Position.AltSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALT_UNSET"),
    1: .same(proto: "ALT_MANUAL"),
    2: .same(proto: "ALT_INTERNAL"),
    3: .same(proto: "ALT_EXTERNAL"),
    4: .same(proto: "ALT_BAROMETRIC"),
  ]
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "long_name"),
    3: .standard(proto: "short_name"),
    4: .same(proto: "macaddr"),
    5: .standard(proto: "hw_model"),
    6: .standard(proto: "is_licensed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.macaddr) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.hwModel) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isLicensed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
    }
    if !self.macaddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.macaddr, fieldNumber: 4)
    }
    if self.hwModel != .unset {
      try visitor.visitSingularEnumField(value: self.hwModel, fieldNumber: 5)
    }
    if self.isLicensed != false {
      try visitor.visitSingularBoolField(value: self.isLicensed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.macaddr != rhs.macaddr {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs.isLicensed != rhs.isLicensed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RouteDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteDiscovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.route, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RouteDiscovery, rhs: RouteDiscovery) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Routing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_request"),
    2: .standard(proto: "route_reply"),
    3: .standard(proto: "error_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeRequest(v)
        }
      }()
      case 2: try {
        var v: RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeReply(v)
        }
      }()
      case 3: try {
        var v: Routing.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .errorReason(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .routeRequest?: try {
      guard case .routeRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .routeReply?: try {
      guard case .routeReply(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .errorReason?: try {
      guard case .errorReason(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routing, rhs: Routing) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routing.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "NO_ROUTE"),
    2: .same(proto: "GOT_NAK"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "NO_INTERFACE"),
    5: .same(proto: "MAX_RETRANSMIT"),
    6: .same(proto: "NO_CHANNEL"),
    7: .same(proto: "TOO_LARGE"),
    8: .same(proto: "NO_RESPONSE"),
    9: .same(proto: "DUTY_CYCLE_LIMIT"),
    32: .same(proto: "BAD_REQUEST"),
    33: .same(proto: "NOT_AUTHORIZED"),
  ]
}

extension DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "portnum"),
    2: .same(proto: "payload"),
    3: .standard(proto: "want_response"),
    4: .same(proto: "dest"),
    5: .same(proto: "source"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "reply_id"),
    8: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wantResponse) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dest) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.source) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self.replyID) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.portnum != .unknownApp {
      try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if self.wantResponse != false {
      try visitor.visitSingularBoolField(value: self.wantResponse, fieldNumber: 3)
    }
    if self.dest != 0 {
      try visitor.visitSingularFixed32Field(value: self.dest, fieldNumber: 4)
    }
    if self.source != 0 {
      try visitor.visitSingularFixed32Field(value: self.source, fieldNumber: 5)
    }
    if self.requestID != 0 {
      try visitor.visitSingularFixed32Field(value: self.requestID, fieldNumber: 6)
    }
    if self.replyID != 0 {
      try visitor.visitSingularFixed32Field(value: self.replyID, fieldNumber: 7)
    }
    if self.emoji != 0 {
      try visitor.visitSingularFixed32Field(value: self.emoji, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DataMessage, rhs: DataMessage) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.wantResponse != rhs.wantResponse {return false}
    if lhs.dest != rhs.dest {return false}
    if lhs.source != rhs.source {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.replyID != rhs.replyID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Waypoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "latitude_i"),
    3: .standard(proto: "longitude_i"),
    4: .same(proto: "expire"),
    5: .standard(proto: "locked_to"),
    6: .same(proto: "name"),
    7: .same(proto: "description"),
    8: .same(proto: "icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self.latitudeI) }()
      case 3: try { try decoder.decodeSingularSFixed32Field(value: &self.longitudeI) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.expire) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.lockedTo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.latitudeI != 0 {
      try visitor.visitSingularSFixed32Field(value: self.latitudeI, fieldNumber: 2)
    }
    if self.longitudeI != 0 {
      try visitor.visitSingularSFixed32Field(value: self.longitudeI, fieldNumber: 3)
    }
    if self.expire != 0 {
      try visitor.visitSingularUInt32Field(value: self.expire, fieldNumber: 4)
    }
    if self.lockedTo != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockedTo, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if self.icon != 0 {
      try visitor.visitSingularFixed32Field(value: self.icon, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Waypoint, rhs: Waypoint) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.latitudeI != rhs.latitudeI {return false}
    if lhs.longitudeI != rhs.longitudeI {return false}
    if lhs.expire != rhs.expire {return false}
    if lhs.lockedTo != rhs.lockedTo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeshPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MeshPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .same(proto: "channel"),
    4: .same(proto: "decoded"),
    5: .same(proto: "encrypted"),
    6: .same(proto: "id"),
    7: .standard(proto: "rx_time"),
    8: .standard(proto: "rx_snr"),
    9: .standard(proto: "hop_limit"),
    10: .standard(proto: "want_ack"),
    11: .same(proto: "priority"),
    12: .standard(proto: "rx_rssi"),
    13: .same(proto: "delayed"),
  ]

  fileprivate class _StorageClass {
    var _from: UInt32 = 0
    var _to: UInt32 = 0
    var _channel: UInt32 = 0
    var _payloadVariant: MeshPacket.OneOf_PayloadVariant?
    var _id: UInt32 = 0
    var _rxTime: UInt32 = 0
    var _rxSnr: Float = 0
    var _hopLimit: UInt32 = 0
    var _wantAck: Bool = false
    var _priority: MeshPacket.Priority = .unset
    var _rxRssi: Int32 = 0
    var _delayed: MeshPacket.Delayed = .noDelay

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _to = source._to
      _channel = source._channel
      _payloadVariant = source._payloadVariant
      _id = source._id
      _rxTime = source._rxTime
      _rxSnr = source._rxSnr
      _hopLimit = source._hopLimit
      _wantAck = source._wantAck
      _priority = source._priority
      _rxRssi = source._rxRssi
      _delayed = source._delayed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._from) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._to) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
        case 4: try {
          var v: DataMessage?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .decoded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .decoded(v)
          }
        }()
        case 5: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .encrypted(v)
          }
        }()
        case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._id) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._rxTime) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._rxSnr) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._wantAck) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._rxRssi) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._delayed) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._from != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._from, fieldNumber: 1)
      }
      if _storage._to != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._to, fieldNumber: 2)
      }
      if _storage._channel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 3)
      }
      switch _storage._payloadVariant {
      case .decoded?: try {
        guard case .decoded(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .encrypted?: try {
        guard case .encrypted(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if _storage._id != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._id, fieldNumber: 6)
      }
      if _storage._rxTime != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._rxTime, fieldNumber: 7)
      }
      if _storage._rxSnr != 0 {
        try visitor.visitSingularFloatField(value: _storage._rxSnr, fieldNumber: 8)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 9)
      }
      if _storage._wantAck != false {
        try visitor.visitSingularBoolField(value: _storage._wantAck, fieldNumber: 10)
      }
      if _storage._priority != .unset {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 11)
      }
      if _storage._rxRssi != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rxRssi, fieldNumber: 12)
      }
      if _storage._delayed != .noDelay {
        try visitor.visitSingularEnumField(value: _storage._delayed, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeshPacket, rhs: MeshPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._payloadVariant != rhs_storage._payloadVariant {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._rxTime != rhs_storage._rxTime {return false}
        if _storage._rxSnr != rhs_storage._rxSnr {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._wantAck != rhs_storage._wantAck {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._rxRssi != rhs_storage._rxRssi {return false}
        if _storage._delayed != rhs_storage._delayed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeshPacket.Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "MIN"),
    10: .same(proto: "BACKGROUND"),
    64: .same(proto: "DEFAULT"),
    70: .same(proto: "RELIABLE"),
    120: .same(proto: "ACK"),
    127: .same(proto: "MAX"),
  ]
}

extension MeshPacket.Delayed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_DELAY"),
    1: .same(proto: "DELAYED_BROADCAST"),
    2: .same(proto: "DELAYED_DIRECT"),
  ]
}

extension NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "user"),
    3: .same(proto: "position"),
    4: .same(proto: "snr"),
    5: .standard(proto: "last_heard"),
    6: .standard(proto: "device_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.snr) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.lastHeard) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deviceMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.num != 0 {
      try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.snr != 0 {
      try visitor.visitSingularFloatField(value: self.snr, fieldNumber: 4)
    }
    if self.lastHeard != 0 {
      try visitor.visitSingularFixed32Field(value: self.lastHeard, fieldNumber: 5)
    }
    try { if let v = self._deviceMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs._user != rhs._user {return false}
    if lhs._position != rhs._position {return false}
    if lhs.snr != rhs.snr {return false}
    if lhs.lastHeard != rhs.lastHeard {return false}
    if lhs._deviceMetrics != rhs._deviceMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MyNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MyNodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "my_node_num"),
    2: .standard(proto: "has_gps"),
    3: .standard(proto: "max_channels"),
    4: .standard(proto: "firmware_version"),
    5: .standard(proto: "error_code"),
    6: .standard(proto: "error_address"),
    7: .standard(proto: "error_count"),
    8: .standard(proto: "reboot_count"),
    9: .same(proto: "bitrate"),
    10: .standard(proto: "message_timeout_msec"),
    11: .standard(proto: "min_app_version"),
    12: .standard(proto: "air_period_tx"),
    13: .standard(proto: "air_period_rx"),
    14: .standard(proto: "has_wifi"),
    15: .standard(proto: "channel_utilization"),
    16: .standard(proto: "air_util_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.myNodeNum) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasGps_p) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxChannels) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.firmwareVersion) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.errorAddress) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.errorCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.rebootCount) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.bitrate) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.messageTimeoutMsec) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.minAppVersion) }()
      case 12: try { try decoder.decodeRepeatedUInt32Field(value: &self.airPeriodTx) }()
      case 13: try { try decoder.decodeRepeatedUInt32Field(value: &self.airPeriodRx) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.hasWifi_p) }()
      case 15: try { try decoder.decodeSingularFloatField(value: &self.channelUtilization) }()
      case 16: try { try decoder.decodeSingularFloatField(value: &self.airUtilTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myNodeNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.myNodeNum, fieldNumber: 1)
    }
    if self.hasGps_p != false {
      try visitor.visitSingularBoolField(value: self.hasGps_p, fieldNumber: 2)
    }
    if self.maxChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxChannels, fieldNumber: 3)
    }
    if !self.firmwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.firmwareVersion, fieldNumber: 4)
    }
    if self.errorCode != .none {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 5)
    }
    if self.errorAddress != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorAddress, fieldNumber: 6)
    }
    if self.errorCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorCount, fieldNumber: 7)
    }
    if self.rebootCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rebootCount, fieldNumber: 8)
    }
    if self.bitrate != 0 {
      try visitor.visitSingularFloatField(value: self.bitrate, fieldNumber: 9)
    }
    if self.messageTimeoutMsec != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageTimeoutMsec, fieldNumber: 10)
    }
    if self.minAppVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAppVersion, fieldNumber: 11)
    }
    if !self.airPeriodTx.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.airPeriodTx, fieldNumber: 12)
    }
    if !self.airPeriodRx.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.airPeriodRx, fieldNumber: 13)
    }
    if self.hasWifi_p != false {
      try visitor.visitSingularBoolField(value: self.hasWifi_p, fieldNumber: 14)
    }
    if self.channelUtilization != 0 {
      try visitor.visitSingularFloatField(value: self.channelUtilization, fieldNumber: 15)
    }
    if self.airUtilTx != 0 {
      try visitor.visitSingularFloatField(value: self.airUtilTx, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MyNodeInfo, rhs: MyNodeInfo) -> Bool {
    if lhs.myNodeNum != rhs.myNodeNum {return false}
    if lhs.hasGps_p != rhs.hasGps_p {return false}
    if lhs.maxChannels != rhs.maxChannels {return false}
    if lhs.firmwareVersion != rhs.firmwareVersion {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorAddress != rhs.errorAddress {return false}
    if lhs.errorCount != rhs.errorCount {return false}
    if lhs.rebootCount != rhs.rebootCount {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.messageTimeoutMsec != rhs.messageTimeoutMsec {return false}
    if lhs.minAppVersion != rhs.minAppVersion {return false}
    if lhs.airPeriodTx != rhs.airPeriodTx {return false}
    if lhs.airPeriodRx != rhs.airPeriodRx {return false}
    if lhs.hasWifi_p != rhs.hasWifi_p {return false}
    if lhs.channelUtilization != rhs.channelUtilization {return false}
    if lhs.airUtilTx != rhs.airUtilTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "time"),
    3: .same(proto: "source"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if self.level != .unset {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LogRecord, rhs: LogRecord) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.time != rhs.time {return false}
    if lhs.source != rhs.source {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    5: .same(proto: "TRACE"),
    10: .same(proto: "DEBUG"),
    20: .same(proto: "INFO"),
    30: .same(proto: "WARNING"),
    40: .same(proto: "ERROR"),
    50: .same(proto: "CRITICAL"),
  ]
}

extension QueueStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueueStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "res"),
    2: .same(proto: "free"),
    3: .same(proto: "maxlen"),
    4: .standard(proto: "mesh_packet_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.res) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.free) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxlen) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.meshPacketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.res != 0 {
      try visitor.visitSingularInt32Field(value: self.res, fieldNumber: 1)
    }
    if self.free != 0 {
      try visitor.visitSingularUInt32Field(value: self.free, fieldNumber: 2)
    }
    if self.maxlen != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxlen, fieldNumber: 3)
    }
    if self.meshPacketID != 0 {
      try visitor.visitSingularUInt32Field(value: self.meshPacketID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QueueStatus, rhs: QueueStatus) -> Bool {
    if lhs.res != rhs.res {return false}
    if lhs.free != rhs.free {return false}
    if lhs.maxlen != rhs.maxlen {return false}
    if lhs.meshPacketID != rhs.meshPacketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FromRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromRadio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "packet"),
    3: .standard(proto: "my_info"),
    4: .standard(proto: "node_info"),
    5: .same(proto: "config"),
    6: .standard(proto: "log_record"),
    7: .standard(proto: "config_complete_id"),
    8: .same(proto: "rebooted"),
    9: .same(proto: "moduleConfig"),
    10: .same(proto: "channel"),
    11: .same(proto: "queueStatus"),
    12: .same(proto: "xmodemPacket"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _payloadVariant: FromRadio.OneOf_PayloadVariant?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _payloadVariant = source._payloadVariant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 2: try {
          var v: MeshPacket?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .packet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .packet(v)
          }
        }()
        case 3: try {
          var v: MyNodeInfo?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .myInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .myInfo(v)
          }
        }()
        case 4: try {
          var v: NodeInfo?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .nodeInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .nodeInfo(v)
          }
        }()
        case 5: try {
          var v: Config?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .config(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .config(v)
          }
        }()
        case 6: try {
          var v: LogRecord?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .logRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .logRecord(v)
          }
        }()
        case 7: try {
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {
            if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .configCompleteID(v)
          }
        }()
        case 8: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .rebooted(v)
          }
        }()
        case 9: try {
          var v: ModuleConfig?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .moduleConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .moduleConfig(v)
          }
        }()
        case 10: try {
          var v: Channel?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .channel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .channel(v)
          }
        }()
        case 11: try {
          var v: QueueStatus?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .queueStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .queueStatus(v)
          }
        }()
        case 12: try {
          var v: XModem?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .xmodemPacket(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .xmodemPacket(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      switch _storage._payloadVariant {
      case .packet?: try {
        guard case .packet(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .myInfo?: try {
        guard case .myInfo(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .nodeInfo?: try {
        guard case .nodeInfo(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .config?: try {
        guard case .config(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .logRecord?: try {
        guard case .logRecord(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .configCompleteID?: try {
        guard case .configCompleteID(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }()
      case .rebooted?: try {
        guard case .rebooted(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }()
      case .moduleConfig?: try {
        guard case .moduleConfig(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .channel?: try {
        guard case .channel(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .queueStatus?: try {
        guard case .queueStatus(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .xmodemPacket?: try {
        guard case .xmodemPacket(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FromRadio, rhs: FromRadio) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._payloadVariant != rhs_storage._payloadVariant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ToRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToRadio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packet"),
    3: .standard(proto: "want_config_id"),
    4: .same(proto: "disconnect"),
    5: .same(proto: "xmodemPacket"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MeshPacket?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .packet(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .wantConfigID(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .disconnect(v)
        }
      }()
      case 5: try {
        var v: XModem?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .xmodemPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .xmodemPacket(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .packet?: try {
      guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wantConfigID?: try {
      guard case .wantConfigID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .xmodemPacket?: try {
      guard case .xmodemPacket(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ToRadio, rhs: ToRadio) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compressed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Compressed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "portnum"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.portnum != .unknownApp {
      try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Compressed, rhs: Compressed) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
