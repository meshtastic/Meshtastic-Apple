// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: radioconfig.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Meshtastic protobufs
///
/// For more information on protobufs (and tools to use them with the language of your choice) see
/// https://developers.google.com/protocol-buffers/docs/proto3
///
/// We are not placing any of these defs inside a package, because if you do the
/// resulting nanopb version is super verbose package mesh.
///
/// Protobuf build instructions:
///
/// To build java classes for reading writing:
/// protoc -I=. --java_out /tmp mesh.proto
///
/// To generate Nanopb c code:
/// /home/kevinh/packages/nanopb-0.4.0-linux-x86/generator-bin/protoc --nanopb_out=/tmp -I=app/src/main/proto mesh.proto
///
/// Nanopb binaries available here: https://jpa.kapsi.fi/nanopb/download/ use nanopb 0.4.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// The frequency/regulatory region the user has selected.
///
/// Note: In 1.0 builds (which must still be supported by the android app for a
/// long time) this field will be unpopulated.
///
/// If firmware is ever upgraded from an old 1.0ish build, the old
/// MyNodeInfo.region string will be used to set UserPreferences.region and the
/// old value will be no longer set.
enum RegionCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unset // = 0
  case us // = 1
  case eu433 // = 2
  case eu865 // = 3
  case cn // = 4
  case jp // = 5
  case anz // = 6
  case kr // = 7
  case tw // = 8
  case ru // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .us
    case 2: self = .eu433
    case 3: self = .eu865
    case 4: self = .cn
    case 5: self = .jp
    case 6: self = .anz
    case 7: self = .kr
    case 8: self = .tw
    case 9: self = .ru
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .us: return 1
    case .eu433: return 2
    case .eu865: return 3
    case .cn: return 4
    case .jp: return 5
    case .anz: return 6
    case .kr: return 7
    case .tw: return 8
    case .ru: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RegionCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RegionCode] = [
    .unset,
    .us,
    .eu433,
    .eu865,
    .cn,
    .jp,
    .anz,
    .kr,
    .tw,
    .ru,
  ]
}

#endif  // swift(>=4.2)

///
/// Sets the charge control current of devices with a battery charger that can be
/// configured. This is passed into the axp power management chip like on the tbeam.
enum ChargeCurrent: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case maunset // = 0
  case ma100 // = 1
  case ma190 // = 2
  case ma280 // = 3
  case ma360 // = 4
  case ma450 // = 5
  case ma550 // = 6
  case ma630 // = 7
  case ma700 // = 8
  case ma780 // = 9
  case ma880 // = 10
  case ma960 // = 11
  case ma1000 // = 12
  case ma1080 // = 13
  case ma1160 // = 14
  case ma1240 // = 15
  case ma1320 // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .maunset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .maunset
    case 1: self = .ma100
    case 2: self = .ma190
    case 3: self = .ma280
    case 4: self = .ma360
    case 5: self = .ma450
    case 6: self = .ma550
    case 7: self = .ma630
    case 8: self = .ma700
    case 9: self = .ma780
    case 10: self = .ma880
    case 11: self = .ma960
    case 12: self = .ma1000
    case 13: self = .ma1080
    case 14: self = .ma1160
    case 15: self = .ma1240
    case 16: self = .ma1320
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .maunset: return 0
    case .ma100: return 1
    case .ma190: return 2
    case .ma280: return 3
    case .ma360: return 4
    case .ma450: return 5
    case .ma550: return 6
    case .ma630: return 7
    case .ma700: return 8
    case .ma780: return 9
    case .ma880: return 10
    case .ma960: return 11
    case .ma1000: return 12
    case .ma1080: return 13
    case .ma1160: return 14
    case .ma1240: return 15
    case .ma1320: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ChargeCurrent: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ChargeCurrent] = [
    .maunset,
    .ma100,
    .ma190,
    .ma280,
    .ma360,
    .ma450,
    .ma550,
    .ma630,
    .ma700,
    .ma780,
    .ma880,
    .ma960,
    .ma1000,
    .ma1080,
    .ma1160,
    .ma1240,
    .ma1320,
  ]
}

#endif  // swift(>=4.2)

///
/// How the GPS hardware in this unit is operated.
/// Note: This is independent of how our location is shared with other devices.
/// For that see LocationSharing
enum GpsOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// This is treated as GpsOpMobile - it is the default setting
  case gpsOpUnset // = 0

  ///
  /// Note: This mode was removed, because it is identical go GpsOpMobile with a gps_update_rate of once per day
  /// This node is mostly stationary, we should try to get location only once per day,
  /// Once we have that position we should turn the GPS to sleep mode
  /// This is the recommended configuration for stationary 'router' nodes
  case gpsOpStationary // = 1

  ///
  /// This node is mobile and we should get GPS position at a rate governed by gps_update_rate
  case gpsOpMobile // = 2

  ///
  /// We should only use the GPS to get time (no location data should be acquired/stored)
  /// Once we have the time we treat gps_update_interval as MAXINT (i.e. sleep forever)
  case gpsOpTimeOnly // = 3

  ///
  /// GPS is always turned off - this mode is not recommended - use GpsOpTimeOnly instead
  case gpsOpDisabled // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .gpsOpUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gpsOpUnset
    case 1: self = .gpsOpStationary
    case 2: self = .gpsOpMobile
    case 3: self = .gpsOpTimeOnly
    case 4: self = .gpsOpDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .gpsOpUnset: return 0
    case .gpsOpStationary: return 1
    case .gpsOpMobile: return 2
    case .gpsOpTimeOnly: return 3
    case .gpsOpDisabled: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GpsOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GpsOperation] = [
    .gpsOpUnset,
    .gpsOpStationary,
    .gpsOpMobile,
    .gpsOpTimeOnly,
    .gpsOpDisabled,
  ]
}

#endif  // swift(>=4.2)

///
/// How the GPS coordinates are displayed on the OLED screen.
enum GpsCoordinateFormat: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// GPS coordinates are displayed in the normal decimal degrees format: 
  /// DD.DDDDDD DDD.DDDDDD
  case gpsFormatDec // = 0

  ///
  /// GPS coordinates are displayed in the degrees minutes seconds format: 
  /// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
  case gpsFormatDms // = 1

  ///
  /// GPS coordinates are displayed in Universal Transverse Mercator format: 
  /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
  case gpsFormatUtm // = 2

  ///
  /// GPS coordinates are displayed in Military Grid Reference System format: 
  /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square, 
  /// E is easting, N is northing
  case gpsFormatMgrs // = 3

  ///
  /// GPS coordinates are displayed in Open Location Code (aka Plus Codes).
  case gpsFormatOlc // = 4

  ///
  /// GPS coordinates are displayed in Ordnance Survey Grid Reference (the National Grid System of the UK).
  /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square, E is the easting,
  /// N is the northing
  case gpsFormatOsgr // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .gpsFormatDec
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gpsFormatDec
    case 1: self = .gpsFormatDms
    case 2: self = .gpsFormatUtm
    case 3: self = .gpsFormatMgrs
    case 4: self = .gpsFormatOlc
    case 5: self = .gpsFormatOsgr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .gpsFormatDec: return 0
    case .gpsFormatDms: return 1
    case .gpsFormatUtm: return 2
    case .gpsFormatMgrs: return 3
    case .gpsFormatOlc: return 4
    case .gpsFormatOsgr: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GpsCoordinateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GpsCoordinateFormat] = [
    .gpsFormatDec,
    .gpsFormatDms,
    .gpsFormatUtm,
    .gpsFormatMgrs,
    .gpsFormatOlc,
    .gpsFormatOsgr,
  ]
}

#endif  // swift(>=4.2)

///
/// How our location is shared with other nodes (or the local phone)
enum LocationSharing: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// This is the default and treated as LocEnabled.
  case locUnset // = 0

  ///
  /// We are sharing our location
  case locEnabled // = 1

  ///
  /// We are not sharing our location (if the unit has a GPS it will default to only get time - i.e. GpsOpTimeOnly)
  case locDisabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .locUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .locUnset
    case 1: self = .locEnabled
    case 2: self = .locDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .locUnset: return 0
    case .locEnabled: return 1
    case .locDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension LocationSharing: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [LocationSharing] = [
    .locUnset,
    .locEnabled,
    .locDisabled,
  ]
}

#endif  // swift(>=4.2)

///
/// The entire set of user settable/readable settings for our radio device.
/// Includes both the current channel settings and any preferences the user has
/// set for behavior of their node
struct RadioConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preferences: RadioConfig.UserPreferences {
    get {return _preferences ?? RadioConfig.UserPreferences()}
    set {_preferences = newValue}
  }
  /// Returns true if `preferences` has been explicitly set.
  var hasPreferences: Bool {return self._preferences != nil}
  /// Clears the value of `preferences`. Subsequent reads from it will return its default value.
  mutating func clearPreferences() {self._preferences = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// see [software design](/software/other/sw-design.md) for more information on these preferences
  struct UserPreferences {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// We should send our position this often (but only if it has changed significantly)
    /// Defaults to 15 minutes
    var positionBroadcastSecs: UInt32 {
      get {return _storage._positionBroadcastSecs}
      set {_uniqueStorage()._positionBroadcastSecs = newValue}
    }

    ///
    /// Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
    var sendOwnerInterval: UInt32 {
      get {return _storage._sendOwnerInterval}
      set {_uniqueStorage()._sendOwnerInterval = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of 1 minute
    var waitBluetoothSecs: UInt32 {
      get {return _storage._waitBluetoothSecs}
      set {_uniqueStorage()._waitBluetoothSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of one minute
    var screenOnSecs: UInt32 {
      get {return _storage._screenOnSecs}
      set {_uniqueStorage()._screenOnSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of 15 minutes
    /// IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
    var phoneTimeoutSecs: UInt32 {
      get {return _storage._phoneTimeoutSecs}
      set {_uniqueStorage()._phoneTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var phoneSdsTimeoutSec: UInt32 {
      get {return _storage._phoneSdsTimeoutSec}
      set {_uniqueStorage()._phoneSdsTimeoutSec = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var meshSdsTimeoutSecs: UInt32 {
      get {return _storage._meshSdsTimeoutSecs}
      set {_uniqueStorage()._meshSdsTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of one year
    var sdsSecs: UInt32 {
      get {return _storage._sdsSecs}
      set {_uniqueStorage()._sdsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of 3600
    var lsSecs: UInt32 {
      get {return _storage._lsSecs}
      set {_uniqueStorage()._lsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/software/other/power.md) for details.
    /// 0 for default of 10 seconds
    var minWakeSecs: UInt32 {
      get {return _storage._minWakeSecs}
      set {_uniqueStorage()._minWakeSecs = newValue}
    }

    ///
    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    var wifiSsid: String {
      get {return _storage._wifiSsid}
      set {_uniqueStorage()._wifiSsid = newValue}
    }

    ///
    /// If set, will be use to authenticate to the named wifi
    var wifiPassword: String {
      get {return _storage._wifiPassword}
      set {_uniqueStorage()._wifiPassword = newValue}
    }

    ///
    /// If set, the node will operate as an AP (and DHCP server), otherwise it
    /// will be a station
    var wifiApMode: Bool {
      get {return _storage._wifiApMode}
      set {_uniqueStorage()._wifiApMode = newValue}
    }

    ///
    /// The region code for my radio (US, CN, EU433, etc...)
    var region: RegionCode {
      get {return _storage._region}
      set {_uniqueStorage()._region = newValue}
    }

    ///
    /// Sets the current of the battery charger
    var chargeCurrent: ChargeCurrent {
      get {return _storage._chargeCurrent}
      set {_uniqueStorage()._chargeCurrent = newValue}
    }

    ///
    /// Are we operating as a router.
    /// Changes behavior in the following ways:
    /// The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
    /// In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
    /// good line of sight)
    var isRouter: Bool {
      get {return _storage._isRouter}
      set {_uniqueStorage()._isRouter = newValue}
    }

    ///
    /// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
    /// we should try to minimize power consumption as much as possible.
    /// YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
    var isLowPower: Bool {
      get {return _storage._isLowPower}
      set {_uniqueStorage()._isLowPower = newValue}
    }

    ///
    /// If set, this node is at a fixed position.
    /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
    /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
    var fixedPosition: Bool {
      get {return _storage._fixedPosition}
      set {_uniqueStorage()._fixedPosition = newValue}
    }

    ///
    /// If set, this will disable the SerialConsole by not initilizing the StreamAPI
    var serialDisabled: Bool {
      get {return _storage._serialDisabled}
      set {_uniqueStorage()._serialDisabled = newValue}
    }

    ///
    /// How our location is shared with other nodes (or the local phone)
    var locationShare: LocationSharing {
      get {return _storage._locationShare}
      set {_uniqueStorage()._locationShare = newValue}
    }

    ///
    /// How the GPS hardware in this unit is operated.
    /// Note: This is independent of how our location is shared with other devices.
    /// For that see LocationSharing
    var gpsOperation: GpsOperation {
      get {return _storage._gpsOperation}
      set {_uniqueStorage()._gpsOperation = newValue}
    }

    ///
    /// How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
    /// or zero for the default of once every 30 seconds
    /// or a very large value (maxint) to update only once at boot.
    var gpsUpdateInterval: UInt32 {
      get {return _storage._gpsUpdateInterval}
      set {_uniqueStorage()._gpsUpdateInterval = newValue}
    }

    ///
    /// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
    /// Or if zero, use the default of 30 seconds.
    /// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
    /// window. 
    var gpsAttemptTime: UInt32 {
      get {return _storage._gpsAttemptTime}
      set {_uniqueStorage()._gpsAttemptTime = newValue}
    }

    ///
    /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
    /// A frequency offset that is added to to the calculated band center frequency.
    /// Used to correct for crystal calibration errors.
    var frequencyOffset: Float {
      get {return _storage._frequencyOffset}
      set {_uniqueStorage()._frequencyOffset = newValue}
    }

    ///
    /// The server to use for our MQTT global message gateway feature.
    /// If not set, the default server will be used 
    var mqttServer: String {
      get {return _storage._mqttServer}
      set {_uniqueStorage()._mqttServer = newValue}
    }

    ///
    /// If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
    /// is_uplink_enabled or is_downlink_enabled.
    /// But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
    var mqttDisabled: Bool {
      get {return _storage._mqttDisabled}
      set {_uniqueStorage()._mqttDisabled = newValue}
    }

    ///
    /// How the GPS coordinates are displayed on the OLED screen.
    var gpsFormat: GpsCoordinateFormat {
      get {return _storage._gpsFormat}
      set {_uniqueStorage()._gpsFormat = newValue}
    }

    ///
    /// This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
    /// (Region, serial number etc... will be preserved)
    var factoryReset: Bool {
      get {return _storage._factoryReset}
      set {_uniqueStorage()._factoryReset = newValue}
    }

    ///
    /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
    /// Set this to true to leave the debug log outputting even when API is active.
    var debugLogEnabled: Bool {
      get {return _storage._debugLogEnabled}
      set {_uniqueStorage()._debugLogEnabled = newValue}
    }

    ///
    /// If true, radio should not try to be smart about what packets to queue to
    /// the phone
    /// bool keep_all_packets = 101;
    /// If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
    /// bool promiscuous_mode = 102;
    /// For testing it is useful sometimes to force a node to never listen to
    /// particular other nodes (simulating radio out of range). All nodenums listed
    /// in ignore_incoming will have packets they send droped on receive (by router.cpp)
    var ignoreIncoming: [UInt32] {
      get {return _storage._ignoreIncoming}
      set {_uniqueStorage()._ignoreIncoming = newValue}
    }

    ///
    /// Preferences for the SerialPlugin
    /// FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    var serialpluginEnabled: Bool {
      get {return _storage._serialpluginEnabled}
      set {_uniqueStorage()._serialpluginEnabled = newValue}
    }

    var serialpluginEcho: Bool {
      get {return _storage._serialpluginEcho}
      set {_uniqueStorage()._serialpluginEcho = newValue}
    }

    var serialpluginRxd: UInt32 {
      get {return _storage._serialpluginRxd}
      set {_uniqueStorage()._serialpluginRxd = newValue}
    }

    var serialpluginTxd: UInt32 {
      get {return _storage._serialpluginTxd}
      set {_uniqueStorage()._serialpluginTxd = newValue}
    }

    var serialpluginTimeout: UInt32 {
      get {return _storage._serialpluginTimeout}
      set {_uniqueStorage()._serialpluginTimeout = newValue}
    }

    var serialpluginMode: UInt32 {
      get {return _storage._serialpluginMode}
      set {_uniqueStorage()._serialpluginMode = newValue}
    }

    ///
    /// Preferences for the ExternalNotificationPlugin
    /// FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    var extNotificationPluginEnabled: Bool {
      get {return _storage._extNotificationPluginEnabled}
      set {_uniqueStorage()._extNotificationPluginEnabled = newValue}
    }

    var extNotificationPluginOutputMs: UInt32 {
      get {return _storage._extNotificationPluginOutputMs}
      set {_uniqueStorage()._extNotificationPluginOutputMs = newValue}
    }

    var extNotificationPluginOutput: UInt32 {
      get {return _storage._extNotificationPluginOutput}
      set {_uniqueStorage()._extNotificationPluginOutput = newValue}
    }

    var extNotificationPluginActive: Bool {
      get {return _storage._extNotificationPluginActive}
      set {_uniqueStorage()._extNotificationPluginActive = newValue}
    }

    var extNotificationPluginAlertMessage: Bool {
      get {return _storage._extNotificationPluginAlertMessage}
      set {_uniqueStorage()._extNotificationPluginAlertMessage = newValue}
    }

    var extNotificationPluginAlertBell: Bool {
      get {return _storage._extNotificationPluginAlertBell}
      set {_uniqueStorage()._extNotificationPluginAlertBell = newValue}
    }

    ///
    ///Preferences for the RangeTestPlugin
    /// FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    var rangeTestPluginEnabled: Bool {
      get {return _storage._rangeTestPluginEnabled}
      set {_uniqueStorage()._rangeTestPluginEnabled = newValue}
    }

    var rangeTestPluginSender: UInt32 {
      get {return _storage._rangeTestPluginSender}
      set {_uniqueStorage()._rangeTestPluginSender = newValue}
    }

    var rangeTestPluginSave: Bool {
      get {return _storage._rangeTestPluginSave}
      set {_uniqueStorage()._rangeTestPluginSave = newValue}
    }

    ///
    /// Preferences for the StoreForwardPlugin
    ///FIXME - Move this out of UserPreferences and into a section for plugin configuration. (was 136)
    var storeForwardPluginEnabled: Bool {
      get {return _storage._storeForwardPluginEnabled}
      set {_uniqueStorage()._storeForwardPluginEnabled = newValue}
    }

    var storeForwardPluginRecords: UInt32 {
      get {return _storage._storeForwardPluginRecords}
      set {_uniqueStorage()._storeForwardPluginRecords = newValue}
    }

    ///
    /// Preferences for the EnvironmentalMeasurement Plugin
    /// FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    /// Enable/Disable the environmental measurement plugin measurement collection
    var environmentalMeasurementPluginMeasurementEnabled: Bool {
      get {return _storage._environmentalMeasurementPluginMeasurementEnabled}
      set {_uniqueStorage()._environmentalMeasurementPluginMeasurementEnabled = newValue}
    }

    ///
    /// Enable/Disable the environmental measurement plugin on-device display
    var environmentalMeasurementPluginScreenEnabled: Bool {
      get {return _storage._environmentalMeasurementPluginScreenEnabled}
      set {_uniqueStorage()._environmentalMeasurementPluginScreenEnabled = newValue}
    }

    ///
    /// Sometimes sensor reads can fail.
    /// If this happens, we will retry a configurable number of attempts,
    /// each attempt will be delayed by the minimum required refresh rate for that sensor
    var environmentalMeasurementPluginReadErrorCountThreshold: UInt32 {
      get {return _storage._environmentalMeasurementPluginReadErrorCountThreshold}
      set {_uniqueStorage()._environmentalMeasurementPluginReadErrorCountThreshold = newValue}
    }

    ///
    /// Interval in seconds of how often we should try to send our 
    /// measurements to the mesh
    var environmentalMeasurementPluginUpdateInterval: UInt32 {
      get {return _storage._environmentalMeasurementPluginUpdateInterval}
      set {_uniqueStorage()._environmentalMeasurementPluginUpdateInterval = newValue}
    }

    ///
    /// Sometimes we can end up with more than read_error_count_threshold failures.
    /// In this case, we will stop trying to read from the sensor for a while.
    /// Wait this long until trying to read from the sensor again
    var environmentalMeasurementPluginRecoveryInterval: UInt32 {
      get {return _storage._environmentalMeasurementPluginRecoveryInterval}
      set {_uniqueStorage()._environmentalMeasurementPluginRecoveryInterval = newValue}
    }

    ///
    /// We'll always read the sensor in Celsius, but sometimes we might want to
    /// display the results in Farenheit as a "user preference".
    var environmentalMeasurementPluginDisplayFarenheit: Bool {
      get {return _storage._environmentalMeasurementPluginDisplayFarenheit}
      set {_uniqueStorage()._environmentalMeasurementPluginDisplayFarenheit = newValue}
    }

    ///
    /// Specify the sensor type
    var environmentalMeasurementPluginSensorType: RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType {
      get {return _storage._environmentalMeasurementPluginSensorType}
      set {_uniqueStorage()._environmentalMeasurementPluginSensorType = newValue}
    }

    ///
    /// Specify the peferred GPIO Pin for sensor readings
    var environmentalMeasurementPluginSensorPin: UInt32 {
      get {return _storage._environmentalMeasurementPluginSensorPin}
      set {_uniqueStorage()._environmentalMeasurementPluginSensorPin = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum EnvironmentalMeasurementSensorType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case dht11 // = 0
      case UNRECOGNIZED(Int)

      init() {
        self = .dht11
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dht11
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .dht11: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _preferences: RadioConfig.UserPreferences? = nil
}

#if swift(>=4.2)

extension RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType] = [
    .dht11,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RegionCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unset"),
    1: .same(proto: "US"),
    2: .same(proto: "EU433"),
    3: .same(proto: "EU865"),
    4: .same(proto: "CN"),
    5: .same(proto: "JP"),
    6: .same(proto: "ANZ"),
    7: .same(proto: "KR"),
    8: .same(proto: "TW"),
    9: .same(proto: "RU"),
  ]
}

extension ChargeCurrent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAUnset"),
    1: .same(proto: "MA100"),
    2: .same(proto: "MA190"),
    3: .same(proto: "MA280"),
    4: .same(proto: "MA360"),
    5: .same(proto: "MA450"),
    6: .same(proto: "MA550"),
    7: .same(proto: "MA630"),
    8: .same(proto: "MA700"),
    9: .same(proto: "MA780"),
    10: .same(proto: "MA880"),
    11: .same(proto: "MA960"),
    12: .same(proto: "MA1000"),
    13: .same(proto: "MA1080"),
    14: .same(proto: "MA1160"),
    15: .same(proto: "MA1240"),
    16: .same(proto: "MA1320"),
  ]
}

extension GpsOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GpsOpUnset"),
    1: .same(proto: "GpsOpStationary"),
    2: .same(proto: "GpsOpMobile"),
    3: .same(proto: "GpsOpTimeOnly"),
    4: .same(proto: "GpsOpDisabled"),
  ]
}

extension GpsCoordinateFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GpsFormatDec"),
    1: .same(proto: "GpsFormatDMS"),
    2: .same(proto: "GpsFormatUTM"),
    3: .same(proto: "GpsFormatMGRS"),
    4: .same(proto: "GpsFormatOLC"),
    5: .same(proto: "GpsFormatOSGR"),
  ]
}

extension LocationSharing: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LocUnset"),
    1: .same(proto: "LocEnabled"),
    2: .same(proto: "LocDisabled"),
  ]
}

extension RadioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RadioConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preferences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._preferences) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._preferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig, rhs: RadioConfig) -> Bool {
    if lhs._preferences != rhs._preferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RadioConfig.UserPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RadioConfig.protoMessageName + ".UserPreferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_broadcast_secs"),
    2: .standard(proto: "send_owner_interval"),
    4: .standard(proto: "wait_bluetooth_secs"),
    5: .standard(proto: "screen_on_secs"),
    6: .standard(proto: "phone_timeout_secs"),
    7: .standard(proto: "phone_sds_timeout_sec"),
    8: .standard(proto: "mesh_sds_timeout_secs"),
    9: .standard(proto: "sds_secs"),
    10: .standard(proto: "ls_secs"),
    11: .standard(proto: "min_wake_secs"),
    12: .standard(proto: "wifi_ssid"),
    13: .standard(proto: "wifi_password"),
    14: .standard(proto: "wifi_ap_mode"),
    15: .same(proto: "region"),
    16: .standard(proto: "charge_current"),
    37: .standard(proto: "is_router"),
    38: .standard(proto: "is_low_power"),
    39: .standard(proto: "fixed_position"),
    40: .standard(proto: "serial_disabled"),
    32: .standard(proto: "location_share"),
    33: .standard(proto: "gps_operation"),
    34: .standard(proto: "gps_update_interval"),
    36: .standard(proto: "gps_attempt_time"),
    41: .standard(proto: "frequency_offset"),
    42: .standard(proto: "mqtt_server"),
    43: .standard(proto: "mqtt_disabled"),
    44: .standard(proto: "gps_format"),
    100: .standard(proto: "factory_reset"),
    101: .standard(proto: "debug_log_enabled"),
    103: .standard(proto: "ignore_incoming"),
    120: .standard(proto: "serialplugin_enabled"),
    121: .standard(proto: "serialplugin_echo"),
    122: .standard(proto: "serialplugin_rxd"),
    123: .standard(proto: "serialplugin_txd"),
    124: .standard(proto: "serialplugin_timeout"),
    125: .standard(proto: "serialplugin_mode"),
    126: .standard(proto: "ext_notification_plugin_enabled"),
    127: .standard(proto: "ext_notification_plugin_output_ms"),
    128: .standard(proto: "ext_notification_plugin_output"),
    129: .standard(proto: "ext_notification_plugin_active"),
    130: .standard(proto: "ext_notification_plugin_alert_message"),
    131: .standard(proto: "ext_notification_plugin_alert_bell"),
    132: .standard(proto: "range_test_plugin_enabled"),
    133: .standard(proto: "range_test_plugin_sender"),
    134: .standard(proto: "range_test_plugin_save"),
    148: .standard(proto: "store_forward_plugin_enabled"),
    137: .standard(proto: "store_forward_plugin_records"),
    140: .standard(proto: "environmental_measurement_plugin_measurement_enabled"),
    141: .standard(proto: "environmental_measurement_plugin_screen_enabled"),
    142: .standard(proto: "environmental_measurement_plugin_read_error_count_threshold"),
    143: .standard(proto: "environmental_measurement_plugin_update_interval"),
    144: .standard(proto: "environmental_measurement_plugin_recovery_interval"),
    145: .standard(proto: "environmental_measurement_plugin_display_farenheit"),
    146: .standard(proto: "environmental_measurement_plugin_sensor_type"),
    147: .standard(proto: "environmental_measurement_plugin_sensor_pin"),
  ]

  fileprivate class _StorageClass {
    var _positionBroadcastSecs: UInt32 = 0
    var _sendOwnerInterval: UInt32 = 0
    var _waitBluetoothSecs: UInt32 = 0
    var _screenOnSecs: UInt32 = 0
    var _phoneTimeoutSecs: UInt32 = 0
    var _phoneSdsTimeoutSec: UInt32 = 0
    var _meshSdsTimeoutSecs: UInt32 = 0
    var _sdsSecs: UInt32 = 0
    var _lsSecs: UInt32 = 0
    var _minWakeSecs: UInt32 = 0
    var _wifiSsid: String = String()
    var _wifiPassword: String = String()
    var _wifiApMode: Bool = false
    var _region: RegionCode = .unset
    var _chargeCurrent: ChargeCurrent = .maunset
    var _isRouter: Bool = false
    var _isLowPower: Bool = false
    var _fixedPosition: Bool = false
    var _serialDisabled: Bool = false
    var _locationShare: LocationSharing = .locUnset
    var _gpsOperation: GpsOperation = .gpsOpUnset
    var _gpsUpdateInterval: UInt32 = 0
    var _gpsAttemptTime: UInt32 = 0
    var _frequencyOffset: Float = 0
    var _mqttServer: String = String()
    var _mqttDisabled: Bool = false
    var _gpsFormat: GpsCoordinateFormat = .gpsFormatDec
    var _factoryReset: Bool = false
    var _debugLogEnabled: Bool = false
    var _ignoreIncoming: [UInt32] = []
    var _serialpluginEnabled: Bool = false
    var _serialpluginEcho: Bool = false
    var _serialpluginRxd: UInt32 = 0
    var _serialpluginTxd: UInt32 = 0
    var _serialpluginTimeout: UInt32 = 0
    var _serialpluginMode: UInt32 = 0
    var _extNotificationPluginEnabled: Bool = false
    var _extNotificationPluginOutputMs: UInt32 = 0
    var _extNotificationPluginOutput: UInt32 = 0
    var _extNotificationPluginActive: Bool = false
    var _extNotificationPluginAlertMessage: Bool = false
    var _extNotificationPluginAlertBell: Bool = false
    var _rangeTestPluginEnabled: Bool = false
    var _rangeTestPluginSender: UInt32 = 0
    var _rangeTestPluginSave: Bool = false
    var _storeForwardPluginEnabled: Bool = false
    var _storeForwardPluginRecords: UInt32 = 0
    var _environmentalMeasurementPluginMeasurementEnabled: Bool = false
    var _environmentalMeasurementPluginScreenEnabled: Bool = false
    var _environmentalMeasurementPluginReadErrorCountThreshold: UInt32 = 0
    var _environmentalMeasurementPluginUpdateInterval: UInt32 = 0
    var _environmentalMeasurementPluginRecoveryInterval: UInt32 = 0
    var _environmentalMeasurementPluginDisplayFarenheit: Bool = false
    var _environmentalMeasurementPluginSensorType: RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType = .dht11
    var _environmentalMeasurementPluginSensorPin: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionBroadcastSecs = source._positionBroadcastSecs
      _sendOwnerInterval = source._sendOwnerInterval
      _waitBluetoothSecs = source._waitBluetoothSecs
      _screenOnSecs = source._screenOnSecs
      _phoneTimeoutSecs = source._phoneTimeoutSecs
      _phoneSdsTimeoutSec = source._phoneSdsTimeoutSec
      _meshSdsTimeoutSecs = source._meshSdsTimeoutSecs
      _sdsSecs = source._sdsSecs
      _lsSecs = source._lsSecs
      _minWakeSecs = source._minWakeSecs
      _wifiSsid = source._wifiSsid
      _wifiPassword = source._wifiPassword
      _wifiApMode = source._wifiApMode
      _region = source._region
      _chargeCurrent = source._chargeCurrent
      _isRouter = source._isRouter
      _isLowPower = source._isLowPower
      _fixedPosition = source._fixedPosition
      _serialDisabled = source._serialDisabled
      _locationShare = source._locationShare
      _gpsOperation = source._gpsOperation
      _gpsUpdateInterval = source._gpsUpdateInterval
      _gpsAttemptTime = source._gpsAttemptTime
      _frequencyOffset = source._frequencyOffset
      _mqttServer = source._mqttServer
      _mqttDisabled = source._mqttDisabled
      _gpsFormat = source._gpsFormat
      _factoryReset = source._factoryReset
      _debugLogEnabled = source._debugLogEnabled
      _ignoreIncoming = source._ignoreIncoming
      _serialpluginEnabled = source._serialpluginEnabled
      _serialpluginEcho = source._serialpluginEcho
      _serialpluginRxd = source._serialpluginRxd
      _serialpluginTxd = source._serialpluginTxd
      _serialpluginTimeout = source._serialpluginTimeout
      _serialpluginMode = source._serialpluginMode
      _extNotificationPluginEnabled = source._extNotificationPluginEnabled
      _extNotificationPluginOutputMs = source._extNotificationPluginOutputMs
      _extNotificationPluginOutput = source._extNotificationPluginOutput
      _extNotificationPluginActive = source._extNotificationPluginActive
      _extNotificationPluginAlertMessage = source._extNotificationPluginAlertMessage
      _extNotificationPluginAlertBell = source._extNotificationPluginAlertBell
      _rangeTestPluginEnabled = source._rangeTestPluginEnabled
      _rangeTestPluginSender = source._rangeTestPluginSender
      _rangeTestPluginSave = source._rangeTestPluginSave
      _storeForwardPluginEnabled = source._storeForwardPluginEnabled
      _storeForwardPluginRecords = source._storeForwardPluginRecords
      _environmentalMeasurementPluginMeasurementEnabled = source._environmentalMeasurementPluginMeasurementEnabled
      _environmentalMeasurementPluginScreenEnabled = source._environmentalMeasurementPluginScreenEnabled
      _environmentalMeasurementPluginReadErrorCountThreshold = source._environmentalMeasurementPluginReadErrorCountThreshold
      _environmentalMeasurementPluginUpdateInterval = source._environmentalMeasurementPluginUpdateInterval
      _environmentalMeasurementPluginRecoveryInterval = source._environmentalMeasurementPluginRecoveryInterval
      _environmentalMeasurementPluginDisplayFarenheit = source._environmentalMeasurementPluginDisplayFarenheit
      _environmentalMeasurementPluginSensorType = source._environmentalMeasurementPluginSensorType
      _environmentalMeasurementPluginSensorPin = source._environmentalMeasurementPluginSensorPin
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._positionBroadcastSecs) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._sendOwnerInterval) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._waitBluetoothSecs) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._screenOnSecs) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneTimeoutSecs) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneSdsTimeoutSec) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._meshSdsTimeoutSecs) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._sdsSecs) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._lsSecs) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._minWakeSecs) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._wifiSsid) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._wifiPassword) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._wifiApMode) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._region) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._chargeCurrent) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._locationShare) }()
        case 33: try { try decoder.decodeSingularEnumField(value: &_storage._gpsOperation) }()
        case 34: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsUpdateInterval) }()
        case 36: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAttemptTime) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._isRouter) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._isLowPower) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._fixedPosition) }()
        case 40: try { try decoder.decodeSingularBoolField(value: &_storage._serialDisabled) }()
        case 41: try { try decoder.decodeSingularFloatField(value: &_storage._frequencyOffset) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._mqttServer) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._mqttDisabled) }()
        case 44: try { try decoder.decodeSingularEnumField(value: &_storage._gpsFormat) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._factoryReset) }()
        case 101: try { try decoder.decodeSingularBoolField(value: &_storage._debugLogEnabled) }()
        case 103: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._ignoreIncoming) }()
        case 120: try { try decoder.decodeSingularBoolField(value: &_storage._serialpluginEnabled) }()
        case 121: try { try decoder.decodeSingularBoolField(value: &_storage._serialpluginEcho) }()
        case 122: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginRxd) }()
        case 123: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginTxd) }()
        case 124: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginTimeout) }()
        case 125: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginMode) }()
        case 126: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginEnabled) }()
        case 127: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationPluginOutputMs) }()
        case 128: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationPluginOutput) }()
        case 129: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginActive) }()
        case 130: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginAlertMessage) }()
        case 131: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginAlertBell) }()
        case 132: try { try decoder.decodeSingularBoolField(value: &_storage._rangeTestPluginEnabled) }()
        case 133: try { try decoder.decodeSingularUInt32Field(value: &_storage._rangeTestPluginSender) }()
        case 134: try { try decoder.decodeSingularBoolField(value: &_storage._rangeTestPluginSave) }()
        case 137: try { try decoder.decodeSingularUInt32Field(value: &_storage._storeForwardPluginRecords) }()
        case 140: try { try decoder.decodeSingularBoolField(value: &_storage._environmentalMeasurementPluginMeasurementEnabled) }()
        case 141: try { try decoder.decodeSingularBoolField(value: &_storage._environmentalMeasurementPluginScreenEnabled) }()
        case 142: try { try decoder.decodeSingularUInt32Field(value: &_storage._environmentalMeasurementPluginReadErrorCountThreshold) }()
        case 143: try { try decoder.decodeSingularUInt32Field(value: &_storage._environmentalMeasurementPluginUpdateInterval) }()
        case 144: try { try decoder.decodeSingularUInt32Field(value: &_storage._environmentalMeasurementPluginRecoveryInterval) }()
        case 145: try { try decoder.decodeSingularBoolField(value: &_storage._environmentalMeasurementPluginDisplayFarenheit) }()
        case 146: try { try decoder.decodeSingularEnumField(value: &_storage._environmentalMeasurementPluginSensorType) }()
        case 147: try { try decoder.decodeSingularUInt32Field(value: &_storage._environmentalMeasurementPluginSensorPin) }()
        case 148: try { try decoder.decodeSingularBoolField(value: &_storage._storeForwardPluginEnabled) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._positionBroadcastSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._positionBroadcastSecs, fieldNumber: 1)
      }
      if _storage._sendOwnerInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sendOwnerInterval, fieldNumber: 2)
      }
      if _storage._waitBluetoothSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._waitBluetoothSecs, fieldNumber: 4)
      }
      if _storage._screenOnSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._screenOnSecs, fieldNumber: 5)
      }
      if _storage._phoneTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneTimeoutSecs, fieldNumber: 6)
      }
      if _storage._phoneSdsTimeoutSec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneSdsTimeoutSec, fieldNumber: 7)
      }
      if _storage._meshSdsTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._meshSdsTimeoutSecs, fieldNumber: 8)
      }
      if _storage._sdsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sdsSecs, fieldNumber: 9)
      }
      if _storage._lsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lsSecs, fieldNumber: 10)
      }
      if _storage._minWakeSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minWakeSecs, fieldNumber: 11)
      }
      if !_storage._wifiSsid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiSsid, fieldNumber: 12)
      }
      if !_storage._wifiPassword.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiPassword, fieldNumber: 13)
      }
      if _storage._wifiApMode != false {
        try visitor.visitSingularBoolField(value: _storage._wifiApMode, fieldNumber: 14)
      }
      if _storage._region != .unset {
        try visitor.visitSingularEnumField(value: _storage._region, fieldNumber: 15)
      }
      if _storage._chargeCurrent != .maunset {
        try visitor.visitSingularEnumField(value: _storage._chargeCurrent, fieldNumber: 16)
      }
      if _storage._locationShare != .locUnset {
        try visitor.visitSingularEnumField(value: _storage._locationShare, fieldNumber: 32)
      }
      if _storage._gpsOperation != .gpsOpUnset {
        try visitor.visitSingularEnumField(value: _storage._gpsOperation, fieldNumber: 33)
      }
      if _storage._gpsUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsUpdateInterval, fieldNumber: 34)
      }
      if _storage._gpsAttemptTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsAttemptTime, fieldNumber: 36)
      }
      if _storage._isRouter != false {
        try visitor.visitSingularBoolField(value: _storage._isRouter, fieldNumber: 37)
      }
      if _storage._isLowPower != false {
        try visitor.visitSingularBoolField(value: _storage._isLowPower, fieldNumber: 38)
      }
      if _storage._fixedPosition != false {
        try visitor.visitSingularBoolField(value: _storage._fixedPosition, fieldNumber: 39)
      }
      if _storage._serialDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._serialDisabled, fieldNumber: 40)
      }
      if _storage._frequencyOffset != 0 {
        try visitor.visitSingularFloatField(value: _storage._frequencyOffset, fieldNumber: 41)
      }
      if !_storage._mqttServer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mqttServer, fieldNumber: 42)
      }
      if _storage._mqttDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._mqttDisabled, fieldNumber: 43)
      }
      if _storage._gpsFormat != .gpsFormatDec {
        try visitor.visitSingularEnumField(value: _storage._gpsFormat, fieldNumber: 44)
      }
      if _storage._factoryReset != false {
        try visitor.visitSingularBoolField(value: _storage._factoryReset, fieldNumber: 100)
      }
      if _storage._debugLogEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._debugLogEnabled, fieldNumber: 101)
      }
      if !_storage._ignoreIncoming.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._ignoreIncoming, fieldNumber: 103)
      }
      if _storage._serialpluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._serialpluginEnabled, fieldNumber: 120)
      }
      if _storage._serialpluginEcho != false {
        try visitor.visitSingularBoolField(value: _storage._serialpluginEcho, fieldNumber: 121)
      }
      if _storage._serialpluginRxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginRxd, fieldNumber: 122)
      }
      if _storage._serialpluginTxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginTxd, fieldNumber: 123)
      }
      if _storage._serialpluginTimeout != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginTimeout, fieldNumber: 124)
      }
      if _storage._serialpluginMode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginMode, fieldNumber: 125)
      }
      if _storage._extNotificationPluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginEnabled, fieldNumber: 126)
      }
      if _storage._extNotificationPluginOutputMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationPluginOutputMs, fieldNumber: 127)
      }
      if _storage._extNotificationPluginOutput != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationPluginOutput, fieldNumber: 128)
      }
      if _storage._extNotificationPluginActive != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginActive, fieldNumber: 129)
      }
      if _storage._extNotificationPluginAlertMessage != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginAlertMessage, fieldNumber: 130)
      }
      if _storage._extNotificationPluginAlertBell != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginAlertBell, fieldNumber: 131)
      }
      if _storage._rangeTestPluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._rangeTestPluginEnabled, fieldNumber: 132)
      }
      if _storage._rangeTestPluginSender != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rangeTestPluginSender, fieldNumber: 133)
      }
      if _storage._rangeTestPluginSave != false {
        try visitor.visitSingularBoolField(value: _storage._rangeTestPluginSave, fieldNumber: 134)
      }
      if _storage._storeForwardPluginRecords != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._storeForwardPluginRecords, fieldNumber: 137)
      }
      if _storage._environmentalMeasurementPluginMeasurementEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._environmentalMeasurementPluginMeasurementEnabled, fieldNumber: 140)
      }
      if _storage._environmentalMeasurementPluginScreenEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._environmentalMeasurementPluginScreenEnabled, fieldNumber: 141)
      }
      if _storage._environmentalMeasurementPluginReadErrorCountThreshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._environmentalMeasurementPluginReadErrorCountThreshold, fieldNumber: 142)
      }
      if _storage._environmentalMeasurementPluginUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._environmentalMeasurementPluginUpdateInterval, fieldNumber: 143)
      }
      if _storage._environmentalMeasurementPluginRecoveryInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._environmentalMeasurementPluginRecoveryInterval, fieldNumber: 144)
      }
      if _storage._environmentalMeasurementPluginDisplayFarenheit != false {
        try visitor.visitSingularBoolField(value: _storage._environmentalMeasurementPluginDisplayFarenheit, fieldNumber: 145)
      }
      if _storage._environmentalMeasurementPluginSensorType != .dht11 {
        try visitor.visitSingularEnumField(value: _storage._environmentalMeasurementPluginSensorType, fieldNumber: 146)
      }
      if _storage._environmentalMeasurementPluginSensorPin != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._environmentalMeasurementPluginSensorPin, fieldNumber: 147)
      }
      if _storage._storeForwardPluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._storeForwardPluginEnabled, fieldNumber: 148)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig.UserPreferences, rhs: RadioConfig.UserPreferences) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._positionBroadcastSecs != rhs_storage._positionBroadcastSecs {return false}
        if _storage._sendOwnerInterval != rhs_storage._sendOwnerInterval {return false}
        if _storage._waitBluetoothSecs != rhs_storage._waitBluetoothSecs {return false}
        if _storage._screenOnSecs != rhs_storage._screenOnSecs {return false}
        if _storage._phoneTimeoutSecs != rhs_storage._phoneTimeoutSecs {return false}
        if _storage._phoneSdsTimeoutSec != rhs_storage._phoneSdsTimeoutSec {return false}
        if _storage._meshSdsTimeoutSecs != rhs_storage._meshSdsTimeoutSecs {return false}
        if _storage._sdsSecs != rhs_storage._sdsSecs {return false}
        if _storage._lsSecs != rhs_storage._lsSecs {return false}
        if _storage._minWakeSecs != rhs_storage._minWakeSecs {return false}
        if _storage._wifiSsid != rhs_storage._wifiSsid {return false}
        if _storage._wifiPassword != rhs_storage._wifiPassword {return false}
        if _storage._wifiApMode != rhs_storage._wifiApMode {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._chargeCurrent != rhs_storage._chargeCurrent {return false}
        if _storage._isRouter != rhs_storage._isRouter {return false}
        if _storage._isLowPower != rhs_storage._isLowPower {return false}
        if _storage._fixedPosition != rhs_storage._fixedPosition {return false}
        if _storage._serialDisabled != rhs_storage._serialDisabled {return false}
        if _storage._locationShare != rhs_storage._locationShare {return false}
        if _storage._gpsOperation != rhs_storage._gpsOperation {return false}
        if _storage._gpsUpdateInterval != rhs_storage._gpsUpdateInterval {return false}
        if _storage._gpsAttemptTime != rhs_storage._gpsAttemptTime {return false}
        if _storage._frequencyOffset != rhs_storage._frequencyOffset {return false}
        if _storage._mqttServer != rhs_storage._mqttServer {return false}
        if _storage._mqttDisabled != rhs_storage._mqttDisabled {return false}
        if _storage._gpsFormat != rhs_storage._gpsFormat {return false}
        if _storage._factoryReset != rhs_storage._factoryReset {return false}
        if _storage._debugLogEnabled != rhs_storage._debugLogEnabled {return false}
        if _storage._ignoreIncoming != rhs_storage._ignoreIncoming {return false}
        if _storage._serialpluginEnabled != rhs_storage._serialpluginEnabled {return false}
        if _storage._serialpluginEcho != rhs_storage._serialpluginEcho {return false}
        if _storage._serialpluginRxd != rhs_storage._serialpluginRxd {return false}
        if _storage._serialpluginTxd != rhs_storage._serialpluginTxd {return false}
        if _storage._serialpluginTimeout != rhs_storage._serialpluginTimeout {return false}
        if _storage._serialpluginMode != rhs_storage._serialpluginMode {return false}
        if _storage._extNotificationPluginEnabled != rhs_storage._extNotificationPluginEnabled {return false}
        if _storage._extNotificationPluginOutputMs != rhs_storage._extNotificationPluginOutputMs {return false}
        if _storage._extNotificationPluginOutput != rhs_storage._extNotificationPluginOutput {return false}
        if _storage._extNotificationPluginActive != rhs_storage._extNotificationPluginActive {return false}
        if _storage._extNotificationPluginAlertMessage != rhs_storage._extNotificationPluginAlertMessage {return false}
        if _storage._extNotificationPluginAlertBell != rhs_storage._extNotificationPluginAlertBell {return false}
        if _storage._rangeTestPluginEnabled != rhs_storage._rangeTestPluginEnabled {return false}
        if _storage._rangeTestPluginSender != rhs_storage._rangeTestPluginSender {return false}
        if _storage._rangeTestPluginSave != rhs_storage._rangeTestPluginSave {return false}
        if _storage._storeForwardPluginEnabled != rhs_storage._storeForwardPluginEnabled {return false}
        if _storage._storeForwardPluginRecords != rhs_storage._storeForwardPluginRecords {return false}
        if _storage._environmentalMeasurementPluginMeasurementEnabled != rhs_storage._environmentalMeasurementPluginMeasurementEnabled {return false}
        if _storage._environmentalMeasurementPluginScreenEnabled != rhs_storage._environmentalMeasurementPluginScreenEnabled {return false}
        if _storage._environmentalMeasurementPluginReadErrorCountThreshold != rhs_storage._environmentalMeasurementPluginReadErrorCountThreshold {return false}
        if _storage._environmentalMeasurementPluginUpdateInterval != rhs_storage._environmentalMeasurementPluginUpdateInterval {return false}
        if _storage._environmentalMeasurementPluginRecoveryInterval != rhs_storage._environmentalMeasurementPluginRecoveryInterval {return false}
        if _storage._environmentalMeasurementPluginDisplayFarenheit != rhs_storage._environmentalMeasurementPluginDisplayFarenheit {return false}
        if _storage._environmentalMeasurementPluginSensorType != rhs_storage._environmentalMeasurementPluginSensorType {return false}
        if _storage._environmentalMeasurementPluginSensorPin != rhs_storage._environmentalMeasurementPluginSensorPin {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RadioConfig.UserPreferences.EnvironmentalMeasurementSensorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DHT11"),
  ]
}
