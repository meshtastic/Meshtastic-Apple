// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/module_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum RemoteHardwarePinType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///
  /// Unset/unused
  case unknown // = 0

  ///
  /// GPIO pin can be read (if it is high / low)
  case digitalRead // = 1

  ///
  /// GPIO pin can be written to (high / low)
  case digitalWrite // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .digitalRead
    case 2: self = .digitalWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .digitalRead: return 1
    case .digitalWrite: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [RemoteHardwarePinType] = [
    .unknown,
    .digitalRead,
    .digitalWrite,
  ]

}

///
/// Module Config
public struct ModuleConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// TODO: REPLACE
  public var payloadVariant: ModuleConfig.OneOf_PayloadVariant? = nil

  ///
  /// TODO: REPLACE
  public var mqtt: ModuleConfig.MQTTConfig {
    get {
      if case .mqtt(let v)? = payloadVariant {return v}
      return ModuleConfig.MQTTConfig()
    }
    set {payloadVariant = .mqtt(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var serial: ModuleConfig.SerialConfig {
    get {
      if case .serial(let v)? = payloadVariant {return v}
      return ModuleConfig.SerialConfig()
    }
    set {payloadVariant = .serial(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var externalNotification: ModuleConfig.ExternalNotificationConfig {
    get {
      if case .externalNotification(let v)? = payloadVariant {return v}
      return ModuleConfig.ExternalNotificationConfig()
    }
    set {payloadVariant = .externalNotification(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var storeForward: ModuleConfig.StoreForwardConfig {
    get {
      if case .storeForward(let v)? = payloadVariant {return v}
      return ModuleConfig.StoreForwardConfig()
    }
    set {payloadVariant = .storeForward(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var rangeTest: ModuleConfig.RangeTestConfig {
    get {
      if case .rangeTest(let v)? = payloadVariant {return v}
      return ModuleConfig.RangeTestConfig()
    }
    set {payloadVariant = .rangeTest(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var telemetry: ModuleConfig.TelemetryConfig {
    get {
      if case .telemetry(let v)? = payloadVariant {return v}
      return ModuleConfig.TelemetryConfig()
    }
    set {payloadVariant = .telemetry(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var cannedMessage: ModuleConfig.CannedMessageConfig {
    get {
      if case .cannedMessage(let v)? = payloadVariant {return v}
      return ModuleConfig.CannedMessageConfig()
    }
    set {payloadVariant = .cannedMessage(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var audio: ModuleConfig.AudioConfig {
    get {
      if case .audio(let v)? = payloadVariant {return v}
      return ModuleConfig.AudioConfig()
    }
    set {payloadVariant = .audio(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var remoteHardware: ModuleConfig.RemoteHardwareConfig {
    get {
      if case .remoteHardware(let v)? = payloadVariant {return v}
      return ModuleConfig.RemoteHardwareConfig()
    }
    set {payloadVariant = .remoteHardware(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var neighborInfo: ModuleConfig.NeighborInfoConfig {
    get {
      if case .neighborInfo(let v)? = payloadVariant {return v}
      return ModuleConfig.NeighborInfoConfig()
    }
    set {payloadVariant = .neighborInfo(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var ambientLighting: ModuleConfig.AmbientLightingConfig {
    get {
      if case .ambientLighting(let v)? = payloadVariant {return v}
      return ModuleConfig.AmbientLightingConfig()
    }
    set {payloadVariant = .ambientLighting(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var detectionSensor: ModuleConfig.DetectionSensorConfig {
    get {
      if case .detectionSensor(let v)? = payloadVariant {return v}
      return ModuleConfig.DetectionSensorConfig()
    }
    set {payloadVariant = .detectionSensor(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var paxcounter: ModuleConfig.PaxcounterConfig {
    get {
      if case .paxcounter(let v)? = payloadVariant {return v}
      return ModuleConfig.PaxcounterConfig()
    }
    set {payloadVariant = .paxcounter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// TODO: REPLACE
  public enum OneOf_PayloadVariant: Equatable, Sendable {
    ///
    /// TODO: REPLACE
    case mqtt(ModuleConfig.MQTTConfig)
    ///
    /// TODO: REPLACE
    case serial(ModuleConfig.SerialConfig)
    ///
    /// TODO: REPLACE
    case externalNotification(ModuleConfig.ExternalNotificationConfig)
    ///
    /// TODO: REPLACE
    case storeForward(ModuleConfig.StoreForwardConfig)
    ///
    /// TODO: REPLACE
    case rangeTest(ModuleConfig.RangeTestConfig)
    ///
    /// TODO: REPLACE
    case telemetry(ModuleConfig.TelemetryConfig)
    ///
    /// TODO: REPLACE
    case cannedMessage(ModuleConfig.CannedMessageConfig)
    ///
    /// TODO: REPLACE
    case audio(ModuleConfig.AudioConfig)
    ///
    /// TODO: REPLACE
    case remoteHardware(ModuleConfig.RemoteHardwareConfig)
    ///
    /// TODO: REPLACE
    case neighborInfo(ModuleConfig.NeighborInfoConfig)
    ///
    /// TODO: REPLACE
    case ambientLighting(ModuleConfig.AmbientLightingConfig)
    ///
    /// TODO: REPLACE
    case detectionSensor(ModuleConfig.DetectionSensorConfig)
    ///
    /// TODO: REPLACE
    case paxcounter(ModuleConfig.PaxcounterConfig)

  }

  ///
  /// MQTT Client Config
  public struct MQTTConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
    /// is_uplink_enabled or is_downlink_enabled.
    public var enabled: Bool = false

    ///
    /// The server to use for our MQTT global message gateway feature.
    /// If not set, the default server will be used
    public var address: String = String()

    ///
    /// MQTT username to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default username
    public var username: String = String()

    ///
    /// MQTT password to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default password
    public var password: String = String()

    ///
    /// Whether to send encrypted or decrypted packets to MQTT.
    /// This parameter is only honoured if you also set server
    /// (the default official mqtt.meshtastic.org server can handle encrypted packets)
    /// Decrypted packets may be useful for external systems that want to consume meshtastic packets
    public var encryptionEnabled: Bool = false

    ///
    /// Whether to send / consume json packets on MQTT
    public var jsonEnabled: Bool = false

    ///
    /// If true, we attempt to establish a secure connection using TLS
    public var tlsEnabled: Bool = false

    ///
    /// The root topic to use for MQTT messages. Default is "msh".
    /// This is useful if you want to use a single MQTT server for multiple meshtastic networks and separate them via ACLs
    public var root: String = String()

    ///
    /// If true, we can use the connected phone / client to proxy messages to MQTT instead of a direct connection
    public var proxyToClientEnabled: Bool = false

    ///
    /// If true, we will periodically report unencrypted information about our node to a map via MQTT
    public var mapReportingEnabled: Bool = false

    ///
    /// Settings for reporting information about our node to a map via MQTT
    public var mapReportSettings: ModuleConfig.MapReportSettings {
      get {return _mapReportSettings ?? ModuleConfig.MapReportSettings()}
      set {_mapReportSettings = newValue}
    }
    /// Returns true if `mapReportSettings` has been explicitly set.
    public var hasMapReportSettings: Bool {return self._mapReportSettings != nil}
    /// Clears the value of `mapReportSettings`. Subsequent reads from it will return its default value.
    public mutating func clearMapReportSettings() {self._mapReportSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _mapReportSettings: ModuleConfig.MapReportSettings? = nil
  }

  ///
  /// Settings for reporting unencrypted information about our node to a map via MQTT
  public struct MapReportSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// How often we should report our info to the map (in seconds)
    public var publishIntervalSecs: UInt32 = 0

    ///
    /// Bits of precision for the location sent (default of 32 is full precision).
    public var positionPrecision: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// RemoteHardwareModule Config
  public struct RemoteHardwareConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether the Module is enabled
    public var enabled: Bool = false

    ///
    /// Whether the Module allows consumers to read / write to pins not defined in available_pins
    public var allowUndefinedPinAccess: Bool = false

    ///
    /// Exposes the available pins to the mesh for reading and writing
    public var availablePins: [RemoteHardwarePin] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// NeighborInfoModule Config
  public struct NeighborInfoConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether the Module is enabled
    public var enabled: Bool = false

    ///
    /// Interval in seconds of how often we should try to send our
    /// Neighbor Info (minimum is 14400, i.e., 4 hours)
    public var updateInterval: UInt32 = 0

    ///
    /// Whether in addition to sending it to MQTT and the PhoneAPI, our NeighborInfo should be transmitted over LoRa.
    /// Note that this is not available on a channel with default key and name.
    public var transmitOverLora: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Detection Sensor Module Config
  public struct DetectionSensorConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether the Module is enabled
    public var enabled: Bool = false

    ///
    /// Interval in seconds of how often we can send a message to the mesh when a
    /// trigger event is detected
    public var minimumBroadcastSecs: UInt32 = 0

    ///
    /// Interval in seconds of how often we should send a message to the mesh
    /// with the current state regardless of trigger events When set to 0, only
    /// trigger events will be broadcasted Works as a sort of status heartbeat
    /// for peace of mind
    public var stateBroadcastSecs: UInt32 = 0

    ///
    /// Send ASCII bell with alert message
    /// Useful for triggering ext. notification on bell
    public var sendBell: Bool = false

    ///
    /// Friendly name used to format message sent to mesh
    /// Example: A name "Motion" would result in a message "Motion detected"
    /// Maximum length of 20 characters
    public var name: String = String()

    ///
    /// GPIO pin to monitor for state changes
    public var monitorPin: UInt32 = 0

    ///
    /// The type of trigger event to be used
    public var detectionTriggerType: ModuleConfig.DetectionSensorConfig.TriggerType = .logicLow

    ///
    /// Whether or not use INPUT_PULLUP mode for GPIO pin
    /// Only applicable if the board uses pull-up resistors on the pin
    public var usePullup: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TriggerType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Event is triggered if pin is low
      case logicLow // = 0

      /// Event is triggered if pin is high
      case logicHigh // = 1

      /// Event is triggered when pin goes high to low
      case fallingEdge // = 2

      /// Event is triggered when pin goes low to high
      case risingEdge // = 3

      /// Event is triggered on every pin state change, low is considered to be
      /// "active"
      case eitherEdgeActiveLow // = 4

      /// Event is triggered on every pin state change, high is considered to be
      /// "active"
      case eitherEdgeActiveHigh // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .logicLow
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .logicLow
        case 1: self = .logicHigh
        case 2: self = .fallingEdge
        case 3: self = .risingEdge
        case 4: self = .eitherEdgeActiveLow
        case 5: self = .eitherEdgeActiveHigh
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .logicLow: return 0
        case .logicHigh: return 1
        case .fallingEdge: return 2
        case .risingEdge: return 3
        case .eitherEdgeActiveLow: return 4
        case .eitherEdgeActiveHigh: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [ModuleConfig.DetectionSensorConfig.TriggerType] = [
        .logicLow,
        .logicHigh,
        .fallingEdge,
        .risingEdge,
        .eitherEdgeActiveLow,
        .eitherEdgeActiveHigh,
      ]

    }

    public init() {}
  }

  ///
  /// Audio Config for codec2 voice
  public struct AudioConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Whether Audio is enabled
    public var codec2Enabled: Bool = false

    ///
    /// PTT Pin
    public var pttPin: UInt32 = 0

    ///
    /// The audio sample rate to use for codec2
    public var bitrate: ModuleConfig.AudioConfig.Audio_Baud = .codec2Default

    ///
    /// I2S Word Select
    public var i2SWs: UInt32 = 0

    ///
    /// I2S Data IN
    public var i2SSd: UInt32 = 0

    ///
    /// I2S Data OUT
    public var i2SDin: UInt32 = 0

    ///
    /// I2S Clock
    public var i2SSck: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Baudrate for codec2 voice
    public enum Audio_Baud: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case codec2Default // = 0
      case codec23200 // = 1
      case codec22400 // = 2
      case codec21600 // = 3
      case codec21400 // = 4
      case codec21300 // = 5
      case codec21200 // = 6
      case codec2700 // = 7
      case codec2700B // = 8
      case UNRECOGNIZED(Int)

      public init() {
        self = .codec2Default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .codec2Default
        case 1: self = .codec23200
        case 2: self = .codec22400
        case 3: self = .codec21600
        case 4: self = .codec21400
        case 5: self = .codec21300
        case 6: self = .codec21200
        case 7: self = .codec2700
        case 8: self = .codec2700B
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .codec2Default: return 0
        case .codec23200: return 1
        case .codec22400: return 2
        case .codec21600: return 3
        case .codec21400: return 4
        case .codec21300: return 5
        case .codec21200: return 6
        case .codec2700: return 7
        case .codec2700B: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [ModuleConfig.AudioConfig.Audio_Baud] = [
        .codec2Default,
        .codec23200,
        .codec22400,
        .codec21600,
        .codec21400,
        .codec21300,
        .codec21200,
        .codec2700,
        .codec2700B,
      ]

    }

    public init() {}
  }

  ///
  /// Config for the Paxcounter Module
  public struct PaxcounterConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the Paxcounter Module
    public var enabled: Bool = false

    public var paxcounterUpdateInterval: UInt32 = 0

    ///
    /// WiFi RSSI threshold. Defaults to -80
    public var wifiThreshold: Int32 = 0

    ///
    /// BLE RSSI threshold. Defaults to -80
    public var bleThreshold: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Serial Config
  public struct SerialConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Preferences for the SerialModule
    public var enabled: Bool = false

    ///
    /// TODO: REPLACE
    public var echo: Bool = false

    ///
    /// RX pin (should match Arduino gpio pin number)
    public var rxd: UInt32 = 0

    ///
    /// TX pin (should match Arduino gpio pin number)
    public var txd: UInt32 = 0

    ///
    /// Serial baud rate
    public var baud: ModuleConfig.SerialConfig.Serial_Baud = .baudDefault

    ///
    /// TODO: REPLACE
    public var timeout: UInt32 = 0

    ///
    /// Mode for serial module operation
    public var mode: ModuleConfig.SerialConfig.Serial_Mode = .default

    ///
    /// Overrides the platform's defacto Serial port instance to use with Serial module config settings
    /// This is currently only usable in output modes like NMEA / CalTopo and may behave strangely or not work at all in other modes
    /// Existing logging over the Serial Console will still be present
    public var overrideConsoleSerialPort: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    public enum Serial_Baud: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case baudDefault // = 0
      case baud110 // = 1
      case baud300 // = 2
      case baud600 // = 3
      case baud1200 // = 4
      case baud2400 // = 5
      case baud4800 // = 6
      case baud9600 // = 7
      case baud19200 // = 8
      case baud38400 // = 9
      case baud57600 // = 10
      case baud115200 // = 11
      case baud230400 // = 12
      case baud460800 // = 13
      case baud576000 // = 14
      case baud921600 // = 15
      case UNRECOGNIZED(Int)

      public init() {
        self = .baudDefault
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .baudDefault
        case 1: self = .baud110
        case 2: self = .baud300
        case 3: self = .baud600
        case 4: self = .baud1200
        case 5: self = .baud2400
        case 6: self = .baud4800
        case 7: self = .baud9600
        case 8: self = .baud19200
        case 9: self = .baud38400
        case 10: self = .baud57600
        case 11: self = .baud115200
        case 12: self = .baud230400
        case 13: self = .baud460800
        case 14: self = .baud576000
        case 15: self = .baud921600
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .baudDefault: return 0
        case .baud110: return 1
        case .baud300: return 2
        case .baud600: return 3
        case .baud1200: return 4
        case .baud2400: return 5
        case .baud4800: return 6
        case .baud9600: return 7
        case .baud19200: return 8
        case .baud38400: return 9
        case .baud57600: return 10
        case .baud115200: return 11
        case .baud230400: return 12
        case .baud460800: return 13
        case .baud576000: return 14
        case .baud921600: return 15
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [ModuleConfig.SerialConfig.Serial_Baud] = [
        .baudDefault,
        .baud110,
        .baud300,
        .baud600,
        .baud1200,
        .baud2400,
        .baud4800,
        .baud9600,
        .baud19200,
        .baud38400,
        .baud57600,
        .baud115200,
        .baud230400,
        .baud460800,
        .baud576000,
        .baud921600,
      ]

    }

    ///
    /// TODO: REPLACE
    public enum Serial_Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case `default` // = 0
      case simple // = 1
      case proto // = 2
      case textmsg // = 3
      case nmea // = 4

      /// NMEA messages specifically tailored for CalTopo
      case caltopo // = 5

      /// Ecowitt WS85 weather station
      case ws85 // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .simple
        case 2: self = .proto
        case 3: self = .textmsg
        case 4: self = .nmea
        case 5: self = .caltopo
        case 6: self = .ws85
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .simple: return 1
        case .proto: return 2
        case .textmsg: return 3
        case .nmea: return 4
        case .caltopo: return 5
        case .ws85: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [ModuleConfig.SerialConfig.Serial_Mode] = [
        .default,
        .simple,
        .proto,
        .textmsg,
        .nmea,
        .caltopo,
        .ws85,
      ]

    }

    public init() {}
  }

  ///
  /// External Notifications Config
  public struct ExternalNotificationConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the ExternalNotificationModule
    public var enabled: Bool = false

    ///
    /// When using in On/Off mode, keep the output on for this many
    /// milliseconds. Default 1000ms (1 second).
    public var outputMs: UInt32 = 0

    ///
    /// Define the output pin GPIO setting Defaults to
    /// EXT_NOTIFY_OUT if set for the board.
    /// In standalone devices this pin should drive the LED to match the UI.
    public var output: UInt32 = 0

    ///
    /// Optional: Define a secondary output pin for a vibra motor
    /// This is used in standalone devices to match the UI.
    public var outputVibra: UInt32 = 0

    ///
    /// Optional: Define a tertiary output pin for an active buzzer
    /// This is used in standalone devices to to match the UI.
    public var outputBuzzer: UInt32 = 0

    ///
    /// IF this is true, the 'output' Pin will be pulled active high, false
    /// means active low.
    public var active: Bool = false

    ///
    /// True: Alert when a text message arrives (output)
    public var alertMessage: Bool = false

    ///
    /// True: Alert when a text message arrives (output_vibra)
    public var alertMessageVibra: Bool = false

    ///
    /// True: Alert when a text message arrives (output_buzzer)
    public var alertMessageBuzzer: Bool = false

    ///
    /// True: Alert when the bell character is received (output)
    public var alertBell: Bool = false

    ///
    /// True: Alert when the bell character is received (output_vibra)
    public var alertBellVibra: Bool = false

    ///
    /// True: Alert when the bell character is received (output_buzzer)
    public var alertBellBuzzer: Bool = false

    ///
    /// use a PWM output instead of a simple on/off output. This will ignore
    /// the 'output', 'output_ms' and 'active' settings and use the
    /// device.buzzer_gpio instead.
    public var usePwm: Bool = false

    ///
    /// The notification will toggle with 'output_ms' for this time of seconds.
    /// Default is 0 which means don't repeat at all. 60 would mean blink
    /// and/or beep for 60 seconds
    public var nagTimeout: UInt32 = 0

    ///
    /// When true, enables devices with native I2S audio output to use the RTTTL over speaker like a buzzer
    /// T-Watch S3 and T-Deck for example have this capability
    public var useI2SAsBuzzer: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Store and Forward Module Config
  public struct StoreForwardConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the Store and Forward Module
    public var enabled: Bool = false

    ///
    /// TODO: REPLACE
    public var heartbeat: Bool = false

    ///
    /// TODO: REPLACE
    public var records: UInt32 = 0

    ///
    /// TODO: REPLACE
    public var historyReturnMax: UInt32 = 0

    ///
    /// TODO: REPLACE
    public var historyReturnWindow: UInt32 = 0

    ///
    /// Set to true to let this node act as a server that stores received messages and resends them upon request.
    public var isServer: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Preferences for the RangeTestModule
  public struct RangeTestConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the Range Test Module
    public var enabled: Bool = false

    ///
    /// Send out range test messages from this node
    public var sender: UInt32 = 0

    ///
    /// Bool value indicating that this node should save a RangeTest.csv file.
    /// ESP32 Only
    public var save: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Configuration for both device and environment metrics
  public struct TelemetryConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Interval in seconds of how often we should try to send our
    /// device metrics to the mesh
    public var deviceUpdateInterval: UInt32 = 0

    public var environmentUpdateInterval: UInt32 = 0

    ///
    /// Preferences for the Telemetry Module (Environment)
    /// Enable/Disable the telemetry measurement module measurement collection
    public var environmentMeasurementEnabled: Bool = false

    ///
    /// Enable/Disable the telemetry measurement module on-device display
    public var environmentScreenEnabled: Bool = false

    ///
    /// We'll always read the sensor in Celsius, but sometimes we might want to
    /// display the results in Fahrenheit as a "user preference".
    public var environmentDisplayFahrenheit: Bool = false

    ///
    /// Enable/Disable the air quality metrics
    public var airQualityEnabled: Bool = false

    ///
    /// Interval in seconds of how often we should try to send our
    /// air quality metrics to the mesh
    public var airQualityInterval: UInt32 = 0

    ///
    /// Enable/disable Power metrics
    public var powerMeasurementEnabled: Bool = false

    ///
    /// Interval in seconds of how often we should try to send our
    /// power metrics to the mesh
    public var powerUpdateInterval: UInt32 = 0

    ///
    /// Enable/Disable the power measurement module on-device display
    public var powerScreenEnabled: Bool = false

    ///
    /// Preferences for the (Health) Telemetry Module
    /// Enable/Disable the telemetry measurement module measurement collection
    public var healthMeasurementEnabled: Bool = false

    ///
    /// Interval in seconds of how often we should try to send our
    /// health metrics to the mesh
    public var healthUpdateInterval: UInt32 = 0

    ///
    /// Enable/Disable the health telemetry module on-device display
    public var healthScreenEnabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// TODO: REPLACE
  public struct CannedMessageConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
    public var rotary1Enabled: Bool = false

    ///
    /// GPIO pin for rotary encoder A port.
    public var inputbrokerPinA: UInt32 = 0

    ///
    /// GPIO pin for rotary encoder B port.
    public var inputbrokerPinB: UInt32 = 0

    ///
    /// GPIO pin for rotary encoder Press port.
    public var inputbrokerPinPress: UInt32 = 0

    ///
    /// Generate input event on CW of this kind.
    public var inputbrokerEventCw: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Generate input event on CCW of this kind.
    public var inputbrokerEventCcw: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Generate input event on Press of this kind.
    public var inputbrokerEventPress: ModuleConfig.CannedMessageConfig.InputEventChar = .none

    ///
    /// Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
    public var updown1Enabled: Bool = false

    ///
    /// Enable/disable CannedMessageModule.
    public var enabled: Bool = false

    ///
    /// Input event origin accepted by the canned message module.
    /// Can be e.g. "rotEnc1", "upDownEnc1", "scanAndSelect", "cardkb", "serialkb", or keyword "_any"
    public var allowInputSource: String = String()

    ///
    /// CannedMessageModule also sends a bell character with the messages.
    /// ExternalNotificationModule can benefit from this feature.
    public var sendBell: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    public enum InputEventChar: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// TODO: REPLACE
      case none // = 0

      ///
      /// TODO: REPLACE
      case up // = 17

      ///
      /// TODO: REPLACE
      case down // = 18

      ///
      /// TODO: REPLACE
      case left // = 19

      ///
      /// TODO: REPLACE
      case right // = 20

      ///
      /// '\n'
      case select // = 10

      ///
      /// TODO: REPLACE
      case back // = 27

      ///
      /// TODO: REPLACE
      case cancel // = 24
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 10: self = .select
        case 17: self = .up
        case 18: self = .down
        case 19: self = .left
        case 20: self = .right
        case 24: self = .cancel
        case 27: self = .back
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .select: return 10
        case .up: return 17
        case .down: return 18
        case .left: return 19
        case .right: return 20
        case .cancel: return 24
        case .back: return 27
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [ModuleConfig.CannedMessageConfig.InputEventChar] = [
        .none,
        .up,
        .down,
        .left,
        .right,
        .select,
        .back,
        .cancel,
      ]

    }

    public init() {}
  }

  ///
  ///Ambient Lighting Module - Settings for control of onboard LEDs to allow users to adjust the brightness levels and respective color levels.
  ///Initially created for the RAK14001 RGB LED module.
  public struct AmbientLightingConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Sets LED to on or off.
    public var ledState: Bool = false

    ///
    /// Sets the current for the LED output. Default is 10.
    public var current: UInt32 = 0

    ///
    /// Sets the red LED level. Values are 0-255.
    public var red: UInt32 = 0

    ///
    /// Sets the green LED level. Values are 0-255.
    public var green: UInt32 = 0

    ///
    /// Sets the blue LED level. Values are 0-255.
    public var blue: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

///
/// A GPIO pin definition for remote hardware module
public struct RemoteHardwarePin: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// GPIO Pin number (must match Arduino)
  public var gpioPin: UInt32 = 0

  ///
  /// Name for the GPIO pin (i.e. Front gate, mailbox, etc)
  public var name: String = String()

  ///
  /// Type of GPIO access available to consumers on the mesh
  public var type: RemoteHardwarePinType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension RemoteHardwarePinType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DIGITAL_READ"),
    2: .same(proto: "DIGITAL_WRITE"),
  ]
}

extension ModuleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mqtt"),
    2: .same(proto: "serial"),
    3: .standard(proto: "external_notification"),
    4: .standard(proto: "store_forward"),
    5: .standard(proto: "range_test"),
    6: .same(proto: "telemetry"),
    7: .standard(proto: "canned_message"),
    8: .same(proto: "audio"),
    9: .standard(proto: "remote_hardware"),
    10: .standard(proto: "neighbor_info"),
    11: .standard(proto: "ambient_lighting"),
    12: .standard(proto: "detection_sensor"),
    13: .same(proto: "paxcounter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ModuleConfig.MQTTConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqtt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqtt(v)
        }
      }()
      case 2: try {
        var v: ModuleConfig.SerialConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .serial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .serial(v)
        }
      }()
      case 3: try {
        var v: ModuleConfig.ExternalNotificationConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .externalNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .externalNotification(v)
        }
      }()
      case 4: try {
        var v: ModuleConfig.StoreForwardConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .storeForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .storeForward(v)
        }
      }()
      case 5: try {
        var v: ModuleConfig.RangeTestConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .rangeTest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rangeTest(v)
        }
      }()
      case 6: try {
        var v: ModuleConfig.TelemetryConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .telemetry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .telemetry(v)
        }
      }()
      case 7: try {
        var v: ModuleConfig.CannedMessageConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .cannedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .cannedMessage(v)
        }
      }()
      case 8: try {
        var v: ModuleConfig.AudioConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .audio(v)
        }
      }()
      case 9: try {
        var v: ModuleConfig.RemoteHardwareConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .remoteHardware(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .remoteHardware(v)
        }
      }()
      case 10: try {
        var v: ModuleConfig.NeighborInfoConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .neighborInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .neighborInfo(v)
        }
      }()
      case 11: try {
        var v: ModuleConfig.AmbientLightingConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .ambientLighting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .ambientLighting(v)
        }
      }()
      case 12: try {
        var v: ModuleConfig.DetectionSensorConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .detectionSensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .detectionSensor(v)
        }
      }()
      case 13: try {
        var v: ModuleConfig.PaxcounterConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .paxcounter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .paxcounter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .mqtt?: try {
      guard case .mqtt(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .serial?: try {
      guard case .serial(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .externalNotification?: try {
      guard case .externalNotification(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .storeForward?: try {
      guard case .storeForward(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rangeTest?: try {
      guard case .rangeTest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .telemetry?: try {
      guard case .telemetry(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cannedMessage?: try {
      guard case .cannedMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .remoteHardware?: try {
      guard case .remoteHardware(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .neighborInfo?: try {
      guard case .neighborInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .ambientLighting?: try {
      guard case .ambientLighting(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .detectionSensor?: try {
      guard case .detectionSensor(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .paxcounter?: try {
      guard case .paxcounter(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig, rhs: ModuleConfig) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.MQTTConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".MQTTConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "address"),
    3: .same(proto: "username"),
    4: .same(proto: "password"),
    5: .standard(proto: "encryption_enabled"),
    6: .standard(proto: "json_enabled"),
    7: .standard(proto: "tls_enabled"),
    8: .same(proto: "root"),
    9: .standard(proto: "proxy_to_client_enabled"),
    10: .standard(proto: "map_reporting_enabled"),
    11: .standard(proto: "map_report_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.encryptionEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.jsonEnabled) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.tlsEnabled) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.root) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.proxyToClientEnabled) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.mapReportingEnabled) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._mapReportSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 4)
    }
    if self.encryptionEnabled != false {
      try visitor.visitSingularBoolField(value: self.encryptionEnabled, fieldNumber: 5)
    }
    if self.jsonEnabled != false {
      try visitor.visitSingularBoolField(value: self.jsonEnabled, fieldNumber: 6)
    }
    if self.tlsEnabled != false {
      try visitor.visitSingularBoolField(value: self.tlsEnabled, fieldNumber: 7)
    }
    if !self.root.isEmpty {
      try visitor.visitSingularStringField(value: self.root, fieldNumber: 8)
    }
    if self.proxyToClientEnabled != false {
      try visitor.visitSingularBoolField(value: self.proxyToClientEnabled, fieldNumber: 9)
    }
    if self.mapReportingEnabled != false {
      try visitor.visitSingularBoolField(value: self.mapReportingEnabled, fieldNumber: 10)
    }
    try { if let v = self._mapReportSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.MQTTConfig, rhs: ModuleConfig.MQTTConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.address != rhs.address {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.encryptionEnabled != rhs.encryptionEnabled {return false}
    if lhs.jsonEnabled != rhs.jsonEnabled {return false}
    if lhs.tlsEnabled != rhs.tlsEnabled {return false}
    if lhs.root != rhs.root {return false}
    if lhs.proxyToClientEnabled != rhs.proxyToClientEnabled {return false}
    if lhs.mapReportingEnabled != rhs.mapReportingEnabled {return false}
    if lhs._mapReportSettings != rhs._mapReportSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.MapReportSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".MapReportSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_interval_secs"),
    2: .standard(proto: "position_precision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.publishIntervalSecs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.positionPrecision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.publishIntervalSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.publishIntervalSecs, fieldNumber: 1)
    }
    if self.positionPrecision != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionPrecision, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.MapReportSettings, rhs: ModuleConfig.MapReportSettings) -> Bool {
    if lhs.publishIntervalSecs != rhs.publishIntervalSecs {return false}
    if lhs.positionPrecision != rhs.positionPrecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.RemoteHardwareConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".RemoteHardwareConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "allow_undefined_pin_access"),
    3: .standard(proto: "available_pins"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowUndefinedPinAccess) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.availablePins) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.allowUndefinedPinAccess != false {
      try visitor.visitSingularBoolField(value: self.allowUndefinedPinAccess, fieldNumber: 2)
    }
    if !self.availablePins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availablePins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.RemoteHardwareConfig, rhs: ModuleConfig.RemoteHardwareConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowUndefinedPinAccess != rhs.allowUndefinedPinAccess {return false}
    if lhs.availablePins != rhs.availablePins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.NeighborInfoConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".NeighborInfoConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "update_interval"),
    3: .standard(proto: "transmit_over_lora"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.updateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.transmitOverLora) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.updateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.updateInterval, fieldNumber: 2)
    }
    if self.transmitOverLora != false {
      try visitor.visitSingularBoolField(value: self.transmitOverLora, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.NeighborInfoConfig, rhs: ModuleConfig.NeighborInfoConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.updateInterval != rhs.updateInterval {return false}
    if lhs.transmitOverLora != rhs.transmitOverLora {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.DetectionSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".DetectionSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "minimum_broadcast_secs"),
    3: .standard(proto: "state_broadcast_secs"),
    4: .standard(proto: "send_bell"),
    5: .same(proto: "name"),
    6: .standard(proto: "monitor_pin"),
    7: .standard(proto: "detection_trigger_type"),
    8: .standard(proto: "use_pullup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.minimumBroadcastSecs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.stateBroadcastSecs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sendBell) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.monitorPin) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.detectionTriggerType) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.usePullup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.minimumBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minimumBroadcastSecs, fieldNumber: 2)
    }
    if self.stateBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.stateBroadcastSecs, fieldNumber: 3)
    }
    if self.sendBell != false {
      try visitor.visitSingularBoolField(value: self.sendBell, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.monitorPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.monitorPin, fieldNumber: 6)
    }
    if self.detectionTriggerType != .logicLow {
      try visitor.visitSingularEnumField(value: self.detectionTriggerType, fieldNumber: 7)
    }
    if self.usePullup != false {
      try visitor.visitSingularBoolField(value: self.usePullup, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.DetectionSensorConfig, rhs: ModuleConfig.DetectionSensorConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.minimumBroadcastSecs != rhs.minimumBroadcastSecs {return false}
    if lhs.stateBroadcastSecs != rhs.stateBroadcastSecs {return false}
    if lhs.sendBell != rhs.sendBell {return false}
    if lhs.name != rhs.name {return false}
    if lhs.monitorPin != rhs.monitorPin {return false}
    if lhs.detectionTriggerType != rhs.detectionTriggerType {return false}
    if lhs.usePullup != rhs.usePullup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.DetectionSensorConfig.TriggerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGIC_LOW"),
    1: .same(proto: "LOGIC_HIGH"),
    2: .same(proto: "FALLING_EDGE"),
    3: .same(proto: "RISING_EDGE"),
    4: .same(proto: "EITHER_EDGE_ACTIVE_LOW"),
    5: .same(proto: "EITHER_EDGE_ACTIVE_HIGH"),
  ]
}

extension ModuleConfig.AudioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".AudioConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "codec2_enabled"),
    2: .standard(proto: "ptt_pin"),
    3: .same(proto: "bitrate"),
    4: .standard(proto: "i2s_ws"),
    5: .standard(proto: "i2s_sd"),
    6: .standard(proto: "i2s_din"),
    7: .standard(proto: "i2s_sck"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.codec2Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pttPin) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.bitrate) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.i2SWs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSd) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.i2SDin) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSck) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codec2Enabled != false {
      try visitor.visitSingularBoolField(value: self.codec2Enabled, fieldNumber: 1)
    }
    if self.pttPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.pttPin, fieldNumber: 2)
    }
    if self.bitrate != .codec2Default {
      try visitor.visitSingularEnumField(value: self.bitrate, fieldNumber: 3)
    }
    if self.i2SWs != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SWs, fieldNumber: 4)
    }
    if self.i2SSd != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSd, fieldNumber: 5)
    }
    if self.i2SDin != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SDin, fieldNumber: 6)
    }
    if self.i2SSck != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSck, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.AudioConfig, rhs: ModuleConfig.AudioConfig) -> Bool {
    if lhs.codec2Enabled != rhs.codec2Enabled {return false}
    if lhs.pttPin != rhs.pttPin {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.i2SWs != rhs.i2SWs {return false}
    if lhs.i2SSd != rhs.i2SSd {return false}
    if lhs.i2SDin != rhs.i2SDin {return false}
    if lhs.i2SSck != rhs.i2SSck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.AudioConfig.Audio_Baud: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC2_DEFAULT"),
    1: .same(proto: "CODEC2_3200"),
    2: .same(proto: "CODEC2_2400"),
    3: .same(proto: "CODEC2_1600"),
    4: .same(proto: "CODEC2_1400"),
    5: .same(proto: "CODEC2_1300"),
    6: .same(proto: "CODEC2_1200"),
    7: .same(proto: "CODEC2_700"),
    8: .same(proto: "CODEC2_700B"),
  ]
}

extension ModuleConfig.PaxcounterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".PaxcounterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "paxcounter_update_interval"),
    3: .standard(proto: "wifi_threshold"),
    4: .standard(proto: "ble_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.paxcounterUpdateInterval) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.wifiThreshold) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.bleThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.paxcounterUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.paxcounterUpdateInterval, fieldNumber: 2)
    }
    if self.wifiThreshold != 0 {
      try visitor.visitSingularInt32Field(value: self.wifiThreshold, fieldNumber: 3)
    }
    if self.bleThreshold != 0 {
      try visitor.visitSingularInt32Field(value: self.bleThreshold, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.PaxcounterConfig, rhs: ModuleConfig.PaxcounterConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.paxcounterUpdateInterval != rhs.paxcounterUpdateInterval {return false}
    if lhs.wifiThreshold != rhs.wifiThreshold {return false}
    if lhs.bleThreshold != rhs.bleThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.SerialConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".SerialConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "echo"),
    3: .same(proto: "rxd"),
    4: .same(proto: "txd"),
    5: .same(proto: "baud"),
    6: .same(proto: "timeout"),
    7: .same(proto: "mode"),
    8: .standard(proto: "override_console_serial_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.echo) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rxd) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.txd) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.baud) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.overrideConsoleSerialPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.echo != false {
      try visitor.visitSingularBoolField(value: self.echo, fieldNumber: 2)
    }
    if self.rxd != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxd, fieldNumber: 3)
    }
    if self.txd != 0 {
      try visitor.visitSingularUInt32Field(value: self.txd, fieldNumber: 4)
    }
    if self.baud != .baudDefault {
      try visitor.visitSingularEnumField(value: self.baud, fieldNumber: 5)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 6)
    }
    if self.mode != .default {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 7)
    }
    if self.overrideConsoleSerialPort != false {
      try visitor.visitSingularBoolField(value: self.overrideConsoleSerialPort, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.SerialConfig, rhs: ModuleConfig.SerialConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.echo != rhs.echo {return false}
    if lhs.rxd != rhs.rxd {return false}
    if lhs.txd != rhs.txd {return false}
    if lhs.baud != rhs.baud {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.overrideConsoleSerialPort != rhs.overrideConsoleSerialPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.SerialConfig.Serial_Baud: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BAUD_DEFAULT"),
    1: .same(proto: "BAUD_110"),
    2: .same(proto: "BAUD_300"),
    3: .same(proto: "BAUD_600"),
    4: .same(proto: "BAUD_1200"),
    5: .same(proto: "BAUD_2400"),
    6: .same(proto: "BAUD_4800"),
    7: .same(proto: "BAUD_9600"),
    8: .same(proto: "BAUD_19200"),
    9: .same(proto: "BAUD_38400"),
    10: .same(proto: "BAUD_57600"),
    11: .same(proto: "BAUD_115200"),
    12: .same(proto: "BAUD_230400"),
    13: .same(proto: "BAUD_460800"),
    14: .same(proto: "BAUD_576000"),
    15: .same(proto: "BAUD_921600"),
  ]
}

extension ModuleConfig.SerialConfig.Serial_Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SIMPLE"),
    2: .same(proto: "PROTO"),
    3: .same(proto: "TEXTMSG"),
    4: .same(proto: "NMEA"),
    5: .same(proto: "CALTOPO"),
    6: .same(proto: "WS85"),
  ]
}

extension ModuleConfig.ExternalNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".ExternalNotificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "output_ms"),
    3: .same(proto: "output"),
    8: .standard(proto: "output_vibra"),
    9: .standard(proto: "output_buzzer"),
    4: .same(proto: "active"),
    5: .standard(proto: "alert_message"),
    10: .standard(proto: "alert_message_vibra"),
    11: .standard(proto: "alert_message_buzzer"),
    6: .standard(proto: "alert_bell"),
    12: .standard(proto: "alert_bell_vibra"),
    13: .standard(proto: "alert_bell_buzzer"),
    7: .standard(proto: "use_pwm"),
    14: .standard(proto: "nag_timeout"),
    15: .standard(proto: "use_i2s_as_buzzer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outputMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.output) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.alertMessage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.alertBell) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.usePwm) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.outputVibra) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.outputBuzzer) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.alertMessageVibra) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.alertMessageBuzzer) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.alertBellVibra) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.alertBellBuzzer) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.nagTimeout) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.useI2SAsBuzzer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.outputMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputMs, fieldNumber: 2)
    }
    if self.output != 0 {
      try visitor.visitSingularUInt32Field(value: self.output, fieldNumber: 3)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 4)
    }
    if self.alertMessage != false {
      try visitor.visitSingularBoolField(value: self.alertMessage, fieldNumber: 5)
    }
    if self.alertBell != false {
      try visitor.visitSingularBoolField(value: self.alertBell, fieldNumber: 6)
    }
    if self.usePwm != false {
      try visitor.visitSingularBoolField(value: self.usePwm, fieldNumber: 7)
    }
    if self.outputVibra != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputVibra, fieldNumber: 8)
    }
    if self.outputBuzzer != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputBuzzer, fieldNumber: 9)
    }
    if self.alertMessageVibra != false {
      try visitor.visitSingularBoolField(value: self.alertMessageVibra, fieldNumber: 10)
    }
    if self.alertMessageBuzzer != false {
      try visitor.visitSingularBoolField(value: self.alertMessageBuzzer, fieldNumber: 11)
    }
    if self.alertBellVibra != false {
      try visitor.visitSingularBoolField(value: self.alertBellVibra, fieldNumber: 12)
    }
    if self.alertBellBuzzer != false {
      try visitor.visitSingularBoolField(value: self.alertBellBuzzer, fieldNumber: 13)
    }
    if self.nagTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.nagTimeout, fieldNumber: 14)
    }
    if self.useI2SAsBuzzer != false {
      try visitor.visitSingularBoolField(value: self.useI2SAsBuzzer, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.ExternalNotificationConfig, rhs: ModuleConfig.ExternalNotificationConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.outputMs != rhs.outputMs {return false}
    if lhs.output != rhs.output {return false}
    if lhs.outputVibra != rhs.outputVibra {return false}
    if lhs.outputBuzzer != rhs.outputBuzzer {return false}
    if lhs.active != rhs.active {return false}
    if lhs.alertMessage != rhs.alertMessage {return false}
    if lhs.alertMessageVibra != rhs.alertMessageVibra {return false}
    if lhs.alertMessageBuzzer != rhs.alertMessageBuzzer {return false}
    if lhs.alertBell != rhs.alertBell {return false}
    if lhs.alertBellVibra != rhs.alertBellVibra {return false}
    if lhs.alertBellBuzzer != rhs.alertBellBuzzer {return false}
    if lhs.usePwm != rhs.usePwm {return false}
    if lhs.nagTimeout != rhs.nagTimeout {return false}
    if lhs.useI2SAsBuzzer != rhs.useI2SAsBuzzer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.StoreForwardConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".StoreForwardConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "heartbeat"),
    3: .same(proto: "records"),
    4: .standard(proto: "history_return_max"),
    5: .standard(proto: "history_return_window"),
    6: .standard(proto: "is_server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.heartbeat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.records) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnMax) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnWindow) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isServer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.heartbeat != false {
      try visitor.visitSingularBoolField(value: self.heartbeat, fieldNumber: 2)
    }
    if self.records != 0 {
      try visitor.visitSingularUInt32Field(value: self.records, fieldNumber: 3)
    }
    if self.historyReturnMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnMax, fieldNumber: 4)
    }
    if self.historyReturnWindow != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnWindow, fieldNumber: 5)
    }
    if self.isServer != false {
      try visitor.visitSingularBoolField(value: self.isServer, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.StoreForwardConfig, rhs: ModuleConfig.StoreForwardConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.heartbeat != rhs.heartbeat {return false}
    if lhs.records != rhs.records {return false}
    if lhs.historyReturnMax != rhs.historyReturnMax {return false}
    if lhs.historyReturnWindow != rhs.historyReturnWindow {return false}
    if lhs.isServer != rhs.isServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.RangeTestConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".RangeTestConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "sender"),
    3: .same(proto: "save"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.save) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.sender != 0 {
      try visitor.visitSingularUInt32Field(value: self.sender, fieldNumber: 2)
    }
    if self.save != false {
      try visitor.visitSingularBoolField(value: self.save, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.RangeTestConfig, rhs: ModuleConfig.RangeTestConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.save != rhs.save {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.TelemetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".TelemetryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_update_interval"),
    2: .standard(proto: "environment_update_interval"),
    3: .standard(proto: "environment_measurement_enabled"),
    4: .standard(proto: "environment_screen_enabled"),
    5: .standard(proto: "environment_display_fahrenheit"),
    6: .standard(proto: "air_quality_enabled"),
    7: .standard(proto: "air_quality_interval"),
    8: .standard(proto: "power_measurement_enabled"),
    9: .standard(proto: "power_update_interval"),
    10: .standard(proto: "power_screen_enabled"),
    11: .standard(proto: "health_measurement_enabled"),
    12: .standard(proto: "health_update_interval"),
    13: .standard(proto: "health_screen_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUpdateInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.environmentUpdateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.environmentMeasurementEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.environmentScreenEnabled) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.environmentDisplayFahrenheit) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.airQualityEnabled) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.airQualityInterval) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.powerMeasurementEnabled) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.powerUpdateInterval) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.powerScreenEnabled) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.healthMeasurementEnabled) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.healthUpdateInterval) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.healthScreenEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUpdateInterval, fieldNumber: 1)
    }
    if self.environmentUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentUpdateInterval, fieldNumber: 2)
    }
    if self.environmentMeasurementEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentMeasurementEnabled, fieldNumber: 3)
    }
    if self.environmentScreenEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentScreenEnabled, fieldNumber: 4)
    }
    if self.environmentDisplayFahrenheit != false {
      try visitor.visitSingularBoolField(value: self.environmentDisplayFahrenheit, fieldNumber: 5)
    }
    if self.airQualityEnabled != false {
      try visitor.visitSingularBoolField(value: self.airQualityEnabled, fieldNumber: 6)
    }
    if self.airQualityInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.airQualityInterval, fieldNumber: 7)
    }
    if self.powerMeasurementEnabled != false {
      try visitor.visitSingularBoolField(value: self.powerMeasurementEnabled, fieldNumber: 8)
    }
    if self.powerUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerUpdateInterval, fieldNumber: 9)
    }
    if self.powerScreenEnabled != false {
      try visitor.visitSingularBoolField(value: self.powerScreenEnabled, fieldNumber: 10)
    }
    if self.healthMeasurementEnabled != false {
      try visitor.visitSingularBoolField(value: self.healthMeasurementEnabled, fieldNumber: 11)
    }
    if self.healthUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.healthUpdateInterval, fieldNumber: 12)
    }
    if self.healthScreenEnabled != false {
      try visitor.visitSingularBoolField(value: self.healthScreenEnabled, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.TelemetryConfig, rhs: ModuleConfig.TelemetryConfig) -> Bool {
    if lhs.deviceUpdateInterval != rhs.deviceUpdateInterval {return false}
    if lhs.environmentUpdateInterval != rhs.environmentUpdateInterval {return false}
    if lhs.environmentMeasurementEnabled != rhs.environmentMeasurementEnabled {return false}
    if lhs.environmentScreenEnabled != rhs.environmentScreenEnabled {return false}
    if lhs.environmentDisplayFahrenheit != rhs.environmentDisplayFahrenheit {return false}
    if lhs.airQualityEnabled != rhs.airQualityEnabled {return false}
    if lhs.airQualityInterval != rhs.airQualityInterval {return false}
    if lhs.powerMeasurementEnabled != rhs.powerMeasurementEnabled {return false}
    if lhs.powerUpdateInterval != rhs.powerUpdateInterval {return false}
    if lhs.powerScreenEnabled != rhs.powerScreenEnabled {return false}
    if lhs.healthMeasurementEnabled != rhs.healthMeasurementEnabled {return false}
    if lhs.healthUpdateInterval != rhs.healthUpdateInterval {return false}
    if lhs.healthScreenEnabled != rhs.healthScreenEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.CannedMessageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".CannedMessageConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rotary1_enabled"),
    2: .standard(proto: "inputbroker_pin_a"),
    3: .standard(proto: "inputbroker_pin_b"),
    4: .standard(proto: "inputbroker_pin_press"),
    5: .standard(proto: "inputbroker_event_cw"),
    6: .standard(proto: "inputbroker_event_ccw"),
    7: .standard(proto: "inputbroker_event_press"),
    8: .standard(proto: "updown1_enabled"),
    9: .same(proto: "enabled"),
    10: .standard(proto: "allow_input_source"),
    11: .standard(proto: "send_bell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.rotary1Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinA) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinB) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinPress) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventCw) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventCcw) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.inputbrokerEventPress) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.updown1Enabled) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.allowInputSource) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.sendBell) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotary1Enabled != false {
      try visitor.visitSingularBoolField(value: self.rotary1Enabled, fieldNumber: 1)
    }
    if self.inputbrokerPinA != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinA, fieldNumber: 2)
    }
    if self.inputbrokerPinB != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinB, fieldNumber: 3)
    }
    if self.inputbrokerPinPress != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinPress, fieldNumber: 4)
    }
    if self.inputbrokerEventCw != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventCw, fieldNumber: 5)
    }
    if self.inputbrokerEventCcw != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventCcw, fieldNumber: 6)
    }
    if self.inputbrokerEventPress != .none {
      try visitor.visitSingularEnumField(value: self.inputbrokerEventPress, fieldNumber: 7)
    }
    if self.updown1Enabled != false {
      try visitor.visitSingularBoolField(value: self.updown1Enabled, fieldNumber: 8)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 9)
    }
    if !self.allowInputSource.isEmpty {
      try visitor.visitSingularStringField(value: self.allowInputSource, fieldNumber: 10)
    }
    if self.sendBell != false {
      try visitor.visitSingularBoolField(value: self.sendBell, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.CannedMessageConfig, rhs: ModuleConfig.CannedMessageConfig) -> Bool {
    if lhs.rotary1Enabled != rhs.rotary1Enabled {return false}
    if lhs.inputbrokerPinA != rhs.inputbrokerPinA {return false}
    if lhs.inputbrokerPinB != rhs.inputbrokerPinB {return false}
    if lhs.inputbrokerPinPress != rhs.inputbrokerPinPress {return false}
    if lhs.inputbrokerEventCw != rhs.inputbrokerEventCw {return false}
    if lhs.inputbrokerEventCcw != rhs.inputbrokerEventCcw {return false}
    if lhs.inputbrokerEventPress != rhs.inputbrokerEventPress {return false}
    if lhs.updown1Enabled != rhs.updown1Enabled {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowInputSource != rhs.allowInputSource {return false}
    if lhs.sendBell != rhs.sendBell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModuleConfig.CannedMessageConfig.InputEventChar: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    10: .same(proto: "SELECT"),
    17: .same(proto: "UP"),
    18: .same(proto: "DOWN"),
    19: .same(proto: "LEFT"),
    20: .same(proto: "RIGHT"),
    24: .same(proto: "CANCEL"),
    27: .same(proto: "BACK"),
  ]
}

extension ModuleConfig.AmbientLightingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ModuleConfig.protoMessageName + ".AmbientLightingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "led_state"),
    2: .same(proto: "current"),
    3: .same(proto: "red"),
    4: .same(proto: "green"),
    5: .same(proto: "blue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ledState) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.current) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.red) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.green) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.blue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ledState != false {
      try visitor.visitSingularBoolField(value: self.ledState, fieldNumber: 1)
    }
    if self.current != 0 {
      try visitor.visitSingularUInt32Field(value: self.current, fieldNumber: 2)
    }
    if self.red != 0 {
      try visitor.visitSingularUInt32Field(value: self.red, fieldNumber: 3)
    }
    if self.green != 0 {
      try visitor.visitSingularUInt32Field(value: self.green, fieldNumber: 4)
    }
    if self.blue != 0 {
      try visitor.visitSingularUInt32Field(value: self.blue, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ModuleConfig.AmbientLightingConfig, rhs: ModuleConfig.AmbientLightingConfig) -> Bool {
    if lhs.ledState != rhs.ledState {return false}
    if lhs.current != rhs.current {return false}
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoteHardwarePin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteHardwarePin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gpio_pin"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gpioPin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gpioPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpioPin, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoteHardwarePin, rhs: RemoteHardwarePin) -> Bool {
    if lhs.gpioPin != rhs.gpioPin {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
