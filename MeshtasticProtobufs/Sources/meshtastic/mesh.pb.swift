// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/mesh.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Note: these enum names must EXACTLY match the string used in the device
/// bin/build-all.sh script.
/// Because they will be used to find firmware filenames in the android app for OTA updates.
/// To match the old style filenames, _ is converted to -, p is converted to .
public enum HardwareModel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case unset // = 0

  ///
  /// TODO: REPLACE
  case tloraV2 // = 1

  ///
  /// TODO: REPLACE
  case tloraV1 // = 2

  ///
  /// TODO: REPLACE
  case tloraV211P6 // = 3

  ///
  /// TODO: REPLACE
  case tbeam // = 4

  ///
  /// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
  /// (see HELTEC_V2 for the new version).
  case heltecV20 // = 5

  ///
  /// TODO: REPLACE
  case tbeamV0P7 // = 6

  ///
  /// TODO: REPLACE
  case tEcho // = 7

  ///
  /// TODO: REPLACE
  case tloraV11P3 // = 8

  ///
  /// TODO: REPLACE
  case rak4631 // = 9

  ///
  /// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
  /// Sadly they did not update anything on the silkscreen to identify this board
  case heltecV21 // = 10

  ///
  /// Ancient heltec WiFi_Lora_32 board
  case heltecV1 // = 11

  ///
  /// New T-BEAM with ESP32-S3 CPU
  case lilygoTbeamS3Core // = 12

  ///
  /// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
  case rak11200 // = 13

  ///
  /// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
  case nanoG1 // = 14

  ///
  /// TODO: REPLACE
  case tloraV211P8 // = 15

  ///
  /// TODO: REPLACE
  case tloraT3S3 // = 16

  ///
  /// B&Q Consulting Nano G1 Explorer: https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer
  case nanoG1Explorer // = 17

  ///
  /// B&Q Consulting Nano G2 Ultra: https://wiki.uniteng.com/en/meshtastic/nano-g2-ultra
  case nanoG2Ultra // = 18

  ///
  /// LoRAType device: https://loratype.org/
  case loraType // = 19

  ///
  /// wiphone https://www.wiphone.io/
  case wiphone // = 20

  ///
  /// WIO Tracker WM1110 family from Seeed Studio. Includes wio-1110-tracker and wio-1110-sdk
  case wioWm1110 // = 21

  ///
  /// RAK2560 Solar base station based on RAK4630
  case rak2560 // = 22

  ///
  /// Heltec HRU-3601: https://heltec.org/project/hru-3601/
  case heltecHru3601 // = 23

  ///
  /// Heltec Wireless Bridge
  case heltecWirelessBridge // = 24

  ///
  /// B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
  case stationG1 // = 25

  ///
  /// RAK11310 (RP2040 + SX1262)
  case rak11310 // = 26

  ///
  /// Makerfabs SenseLoRA Receiver (RP2040 + RFM96)
  case senseloraRp2040 // = 27

  ///
  /// Makerfabs SenseLoRA Industrial Monitor (ESP32-S3 + RFM96)
  case senseloraS3 // = 28

  ///
  /// Canary Radio Company - CanaryOne: https://canaryradio.io/products/canaryone
  case canaryone // = 29

  ///
  /// Waveshare RP2040 LoRa - https://www.waveshare.com/rp2040-lora.htm
  case rp2040Lora // = 30

  ///
  /// B&Q Consulting Station G2: https://wiki.uniteng.com/en/meshtastic/station-g2
  case stationG2 // = 31

  ///
  /// ---------------------------------------------------------------------------
  /// Less common/prototype boards listed here (needs one more byte over the air)
  /// ---------------------------------------------------------------------------
  case loraRelayV1 // = 32

  ///
  /// TODO: REPLACE
  case nrf52840Dk // = 33

  ///
  /// TODO: REPLACE
  case ppr // = 34

  ///
  /// TODO: REPLACE
  case genieblocks // = 35

  ///
  /// TODO: REPLACE
  case nrf52Unknown // = 36

  ///
  /// TODO: REPLACE
  case portduino // = 37

  ///
  /// The simulator built into the android app
  case androidSim // = 38

  ///
  /// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
  case diyV1 // = 39

  ///
  /// nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
  case nrf52840Pca10059 // = 40

  ///
  /// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
  case drDev // = 41

  ///
  /// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
  case m5Stack // = 42

  ///
  /// New Heltec LoRA32 with ESP32-S3 CPU
  case heltecV3 // = 43

  ///
  /// New Heltec Wireless Stick Lite with ESP32-S3 CPU
  case heltecWslV3 // = 44

  ///
  /// New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
  case betafpv2400Tx // = 45

  ///
  /// BetaFPV ExpressLRS "Nano" TX Module 900MHz with ESP32 CPU
  case betafpv900NanoTx // = 46

  ///
  /// Raspberry Pi Pico (W) with Waveshare SX1262 LoRa Node Module
  case rpiPico // = 47

  ///
  /// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
  /// Newer V1.1, version is written on the PCB near the display.
  case heltecWirelessTracker // = 48

  ///
  /// Heltec Wireless Paper with ESP32-S3 CPU and E-Ink display
  case heltecWirelessPaper // = 49

  ///
  /// LilyGo T-Deck with ESP32-S3 CPU, Keyboard and IPS display
  case tDeck // = 50

  ///
  /// LilyGo T-Watch S3 with ESP32-S3 CPU and IPS display
  case tWatchS3 // = 51

  ///
  /// Bobricius Picomputer with ESP32-S3 CPU, Keyboard and IPS display
  case picomputerS3 // = 52

  ///
  /// Heltec HT-CT62 with ESP32-C3 CPU and SX1262 LoRa
  case heltecHt62 // = 53

  ///
  /// EBYTE SPI LoRa module and ESP32-S3
  case ebyteEsp32S3 // = 54

  ///
  /// Waveshare ESP32-S3-PICO with PICO LoRa HAT and 2.9inch e-Ink
  case esp32S3Pico // = 55

  ///
  /// CircuitMess Chatter 2 LLCC68 Lora Module and ESP32 Wroom
  /// Lora module can be swapped out for a Heltec RA-62 which is "almost" pin compatible
  /// with one cut and one jumper Meshtastic works
  case chatter2 // = 56

  ///
  /// Heltec Wireless Paper, With ESP32-S3 CPU and E-Ink display
  /// Older "V1.0" Variant, has no "version sticker"
  /// E-Ink model is DEPG0213BNS800
  /// Tab on the screen protector is RED
  /// Flex connector marking is FPC-7528B
  case heltecWirelessPaperV10 // = 57

  ///
  /// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
  /// Older "V1.0" Variant
  case heltecWirelessTrackerV10 // = 58

  ///
  /// unPhone with ESP32-S3, TFT touchscreen,  LSM6DS3TR-C accelerometer and gyroscope
  case unphone // = 59

  ///
  /// Teledatics TD-LORAC NRF52840 based M.2 LoRA module
  /// Compatible with the TD-WRLS development board
  case tdLorac // = 60

  ///
  /// CDEBYTE EoRa-S3 board using their own MM modules, clone of LILYGO T3S3
  case cdebyteEoraS3 // = 61

  ///
  /// TWC_MESH_V4 
  /// Adafruit NRF52840 feather express with SX1262, SSD1306 OLED and NEO6M GPS
  case twcMeshV4 // = 62

  ///
  /// NRF52_PROMICRO_DIY
  /// Promicro NRF52840 with SX1262/LLCC68, SSD1306 OLED and NEO6M GPS
  case nrf52PromicroDiy // = 63

  ///
  /// RadioMaster 900 Bandit Nano, https://www.radiomasterrc.com/products/bandit-nano-expresslrs-rf-module
  /// ESP32-D0WDQ6 With SX1276/SKY66122, SSD1306 OLED and No GPS
  case radiomaster900BanditNano // = 64

  ///
  /// Heltec Capsule Sensor V3 with ESP32-S3 CPU, Portable LoRa device that can replace GNSS modules or sensors
  case heltecCapsuleSensorV3 // = 65

  ///
  /// Heltec Vision Master T190 with ESP32-S3 CPU, and a 1.90 inch TFT display
  case heltecVisionMasterT190 // = 66

  ///
  /// Heltec Vision Master E213 with ESP32-S3 CPU, and a 2.13 inch E-Ink display
  case heltecVisionMasterE213 // = 67

  ///
  /// Heltec Vision Master E290 with ESP32-S3 CPU, and a 2.9 inch E-Ink display
  case heltecVisionMasterE290 // = 68

  ///
  /// Heltec Mesh Node T114 board with nRF52840 CPU, and a 1.14 inch TFT display, Ultimate low-power design,
  /// specifically adapted for the Meshtatic project
  case heltecMeshNodeT114 // = 69

  ///
  /// Sensecap Indicator from Seeed Studio. ESP32-S3 device with TFT and RP2040 coprocessor
  case sensecapIndicator // = 70

  ///
  /// Seeed studio T1000-E tracker card. NRF52840 w/ LR1110 radio, GPS, button, buzzer, and sensors.
  case trackerT1000E // = 71

  ///
  /// RAK3172 STM32WLE5 Module (https://store.rakwireless.com/products/wisduo-lpwan-module-rak3172)
  case rak3172 // = 72

  ///
  /// Seeed Studio Wio-E5 (either mini or Dev kit) using STM32WL chip.
  case wioE5 // = 73

  ///
  /// RadioMaster 900 Bandit, https://www.radiomasterrc.com/products/bandit-expresslrs-rf-module
  /// SSD1306 OLED and No GPS
  case radiomaster900Bandit // = 74

  ///
  /// Minewsemi ME25LS01 (ME25LE01_V1.0). NRF52840 w/ LR1110 radio, buttons and leds and pins.
  case me25Ls014Y10Td // = 75

  ///
  /// RP2040_FEATHER_RFM95
  /// Adafruit Feather RP2040 with RFM95 LoRa Radio RFM95 with SX1272, SSD1306 OLED
  /// https://www.adafruit.com/product/5714
  /// https://www.adafruit.com/product/326
  /// https://www.adafruit.com/product/938
  ///  ^^^ short A0 to switch to I2C address 0x3C
  case rp2040FeatherRfm95 // = 76

  /// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/ 
  case m5StackCorebasic // = 77
  case m5StackCore2 // = 78

  /// Pico2 with Waveshare Hat, same as Pico 
  case rpiPico2 // = 79

  /// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/ 
  case m5StackCores3 // = 80

  /// Seeed XIAO S3 DK
  case seeedXiaoS3 // = 81

  ///
  /// Nordic nRF52840+Semtech SX1262 LoRa BLE Combo Module. nRF52840+SX1262 MS24SF1
  case ms24Sf1 // = 82

  ///
  /// Lilygo TLora-C6 with the new ESP32-C6 MCU
  case tloraC6 // = 83

  ///
  /// WisMesh Tap
  /// RAK-4631 w/ TFT in injection modled case
  case wismeshTap // = 84

  ///
  /// Similar to PORTDUINO but used by Routastic devices, this is not any
  /// particular device and does not run Meshtastic's code but supports
  /// the same frame format.
  /// Runs on linux, see https://github.com/Jorropo/routastic
  case routastic // = 85

  ///
  /// Mesh-Tab, esp32 based
  /// https://github.com/valzzu/Mesh-Tab
  case meshTab // = 86

  ///
  /// ------------------------------------------------------------------------------------------------------------------------------------------
  /// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
  /// ------------------------------------------------------------------------------------------------------------------------------------------
  case privateHw // = 255
  case UNRECOGNIZED(Int)

  public init() {
    self = .unset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .tloraV2
    case 2: self = .tloraV1
    case 3: self = .tloraV211P6
    case 4: self = .tbeam
    case 5: self = .heltecV20
    case 6: self = .tbeamV0P7
    case 7: self = .tEcho
    case 8: self = .tloraV11P3
    case 9: self = .rak4631
    case 10: self = .heltecV21
    case 11: self = .heltecV1
    case 12: self = .lilygoTbeamS3Core
    case 13: self = .rak11200
    case 14: self = .nanoG1
    case 15: self = .tloraV211P8
    case 16: self = .tloraT3S3
    case 17: self = .nanoG1Explorer
    case 18: self = .nanoG2Ultra
    case 19: self = .loraType
    case 20: self = .wiphone
    case 21: self = .wioWm1110
    case 22: self = .rak2560
    case 23: self = .heltecHru3601
    case 24: self = .heltecWirelessBridge
    case 25: self = .stationG1
    case 26: self = .rak11310
    case 27: self = .senseloraRp2040
    case 28: self = .senseloraS3
    case 29: self = .canaryone
    case 30: self = .rp2040Lora
    case 31: self = .stationG2
    case 32: self = .loraRelayV1
    case 33: self = .nrf52840Dk
    case 34: self = .ppr
    case 35: self = .genieblocks
    case 36: self = .nrf52Unknown
    case 37: self = .portduino
    case 38: self = .androidSim
    case 39: self = .diyV1
    case 40: self = .nrf52840Pca10059
    case 41: self = .drDev
    case 42: self = .m5Stack
    case 43: self = .heltecV3
    case 44: self = .heltecWslV3
    case 45: self = .betafpv2400Tx
    case 46: self = .betafpv900NanoTx
    case 47: self = .rpiPico
    case 48: self = .heltecWirelessTracker
    case 49: self = .heltecWirelessPaper
    case 50: self = .tDeck
    case 51: self = .tWatchS3
    case 52: self = .picomputerS3
    case 53: self = .heltecHt62
    case 54: self = .ebyteEsp32S3
    case 55: self = .esp32S3Pico
    case 56: self = .chatter2
    case 57: self = .heltecWirelessPaperV10
    case 58: self = .heltecWirelessTrackerV10
    case 59: self = .unphone
    case 60: self = .tdLorac
    case 61: self = .cdebyteEoraS3
    case 62: self = .twcMeshV4
    case 63: self = .nrf52PromicroDiy
    case 64: self = .radiomaster900BanditNano
    case 65: self = .heltecCapsuleSensorV3
    case 66: self = .heltecVisionMasterT190
    case 67: self = .heltecVisionMasterE213
    case 68: self = .heltecVisionMasterE290
    case 69: self = .heltecMeshNodeT114
    case 70: self = .sensecapIndicator
    case 71: self = .trackerT1000E
    case 72: self = .rak3172
    case 73: self = .wioE5
    case 74: self = .radiomaster900Bandit
    case 75: self = .me25Ls014Y10Td
    case 76: self = .rp2040FeatherRfm95
    case 77: self = .m5StackCorebasic
    case 78: self = .m5StackCore2
    case 79: self = .rpiPico2
    case 80: self = .m5StackCores3
    case 81: self = .seeedXiaoS3
    case 82: self = .ms24Sf1
    case 83: self = .tloraC6
    case 84: self = .wismeshTap
    case 85: self = .routastic
    case 86: self = .meshTab
    case 255: self = .privateHw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unset: return 0
    case .tloraV2: return 1
    case .tloraV1: return 2
    case .tloraV211P6: return 3
    case .tbeam: return 4
    case .heltecV20: return 5
    case .tbeamV0P7: return 6
    case .tEcho: return 7
    case .tloraV11P3: return 8
    case .rak4631: return 9
    case .heltecV21: return 10
    case .heltecV1: return 11
    case .lilygoTbeamS3Core: return 12
    case .rak11200: return 13
    case .nanoG1: return 14
    case .tloraV211P8: return 15
    case .tloraT3S3: return 16
    case .nanoG1Explorer: return 17
    case .nanoG2Ultra: return 18
    case .loraType: return 19
    case .wiphone: return 20
    case .wioWm1110: return 21
    case .rak2560: return 22
    case .heltecHru3601: return 23
    case .heltecWirelessBridge: return 24
    case .stationG1: return 25
    case .rak11310: return 26
    case .senseloraRp2040: return 27
    case .senseloraS3: return 28
    case .canaryone: return 29
    case .rp2040Lora: return 30
    case .stationG2: return 31
    case .loraRelayV1: return 32
    case .nrf52840Dk: return 33
    case .ppr: return 34
    case .genieblocks: return 35
    case .nrf52Unknown: return 36
    case .portduino: return 37
    case .androidSim: return 38
    case .diyV1: return 39
    case .nrf52840Pca10059: return 40
    case .drDev: return 41
    case .m5Stack: return 42
    case .heltecV3: return 43
    case .heltecWslV3: return 44
    case .betafpv2400Tx: return 45
    case .betafpv900NanoTx: return 46
    case .rpiPico: return 47
    case .heltecWirelessTracker: return 48
    case .heltecWirelessPaper: return 49
    case .tDeck: return 50
    case .tWatchS3: return 51
    case .picomputerS3: return 52
    case .heltecHt62: return 53
    case .ebyteEsp32S3: return 54
    case .esp32S3Pico: return 55
    case .chatter2: return 56
    case .heltecWirelessPaperV10: return 57
    case .heltecWirelessTrackerV10: return 58
    case .unphone: return 59
    case .tdLorac: return 60
    case .cdebyteEoraS3: return 61
    case .twcMeshV4: return 62
    case .nrf52PromicroDiy: return 63
    case .radiomaster900BanditNano: return 64
    case .heltecCapsuleSensorV3: return 65
    case .heltecVisionMasterT190: return 66
    case .heltecVisionMasterE213: return 67
    case .heltecVisionMasterE290: return 68
    case .heltecMeshNodeT114: return 69
    case .sensecapIndicator: return 70
    case .trackerT1000E: return 71
    case .rak3172: return 72
    case .wioE5: return 73
    case .radiomaster900Bandit: return 74
    case .me25Ls014Y10Td: return 75
    case .rp2040FeatherRfm95: return 76
    case .m5StackCorebasic: return 77
    case .m5StackCore2: return 78
    case .rpiPico2: return 79
    case .m5StackCores3: return 80
    case .seeedXiaoS3: return 81
    case .ms24Sf1: return 82
    case .tloraC6: return 83
    case .wismeshTap: return 84
    case .routastic: return 85
    case .meshTab: return 86
    case .privateHw: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [HardwareModel] = [
    .unset,
    .tloraV2,
    .tloraV1,
    .tloraV211P6,
    .tbeam,
    .heltecV20,
    .tbeamV0P7,
    .tEcho,
    .tloraV11P3,
    .rak4631,
    .heltecV21,
    .heltecV1,
    .lilygoTbeamS3Core,
    .rak11200,
    .nanoG1,
    .tloraV211P8,
    .tloraT3S3,
    .nanoG1Explorer,
    .nanoG2Ultra,
    .loraType,
    .wiphone,
    .wioWm1110,
    .rak2560,
    .heltecHru3601,
    .heltecWirelessBridge,
    .stationG1,
    .rak11310,
    .senseloraRp2040,
    .senseloraS3,
    .canaryone,
    .rp2040Lora,
    .stationG2,
    .loraRelayV1,
    .nrf52840Dk,
    .ppr,
    .genieblocks,
    .nrf52Unknown,
    .portduino,
    .androidSim,
    .diyV1,
    .nrf52840Pca10059,
    .drDev,
    .m5Stack,
    .heltecV3,
    .heltecWslV3,
    .betafpv2400Tx,
    .betafpv900NanoTx,
    .rpiPico,
    .heltecWirelessTracker,
    .heltecWirelessPaper,
    .tDeck,
    .tWatchS3,
    .picomputerS3,
    .heltecHt62,
    .ebyteEsp32S3,
    .esp32S3Pico,
    .chatter2,
    .heltecWirelessPaperV10,
    .heltecWirelessTrackerV10,
    .unphone,
    .tdLorac,
    .cdebyteEoraS3,
    .twcMeshV4,
    .nrf52PromicroDiy,
    .radiomaster900BanditNano,
    .heltecCapsuleSensorV3,
    .heltecVisionMasterT190,
    .heltecVisionMasterE213,
    .heltecVisionMasterE290,
    .heltecMeshNodeT114,
    .sensecapIndicator,
    .trackerT1000E,
    .rak3172,
    .wioE5,
    .radiomaster900Bandit,
    .me25Ls014Y10Td,
    .rp2040FeatherRfm95,
    .m5StackCorebasic,
    .m5StackCore2,
    .rpiPico2,
    .m5StackCores3,
    .seeedXiaoS3,
    .ms24Sf1,
    .tloraC6,
    .wismeshTap,
    .routastic,
    .meshTab,
    .privateHw,
  ]

}

///
/// Shared constants between device and phone
public enum Constants: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///
  /// First enum must be zero, and we are just using this enum to
  /// pass int constants between two very different environments
  case zero // = 0

  ///
  /// From mesh.options
  /// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
  /// outside of this envelope
  case dataPayloadLen // = 233
  case UNRECOGNIZED(Int)

  public init() {
    self = .zero
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .zero
    case 233: self = .dataPayloadLen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .zero: return 0
    case .dataPayloadLen: return 233
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Constants] = [
    .zero,
    .dataPayloadLen,
  ]

}

///
/// Error codes for critical errors
/// The device might report these fault codes on the screen.
/// If you encounter a fault code, please post on the meshtastic.discourse.group
/// and we'll try to help.
public enum CriticalErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case none // = 0

  ///
  /// A software bug was detected while trying to send lora
  case txWatchdog // = 1

  ///
  /// A software bug was detected on entry to sleep
  case sleepEnterWait // = 2

  ///
  /// No Lora radio hardware could be found
  case noRadio // = 3

  ///
  /// Not normally used
  case unspecified // = 4

  ///
  /// We failed while configuring a UBlox GPS
  case ubloxUnitFailed // = 5

  ///
  /// This board was expected to have a power management chip and it is missing or broken
  case noAxp192 // = 6

  ///
  /// The channel tried to set a radio setting which is not supported by this chipset,
  /// radio comms settings are now undefined.
  case invalidRadioSetting // = 7

  ///
  /// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
  /// reply with an interrupt.
  case transmitFailed // = 8

  ///
  /// We detected that the main CPU voltage dropped below the minimum acceptable value
  case brownout // = 9

  /// Selftest of SX1262 radio chip failed 
  case sx1262Failure // = 10

  ///
  /// A (likely software but possibly hardware) failure was detected while trying to send packets.
  /// If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
  case radioSpiBug // = 11

  ///
  /// Corruption was detected on the flash filesystem but we were able to repair things.
  /// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
  case flashCorruptionRecoverable // = 12

  ///
  /// Corruption was detected on the flash filesystem but we were unable to repair things.
  /// NOTE: Your node will probably need to be reconfigured the next time it reboots (it will lose the region code etc...)
  /// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
  case flashCorruptionUnrecoverable // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .txWatchdog
    case 2: self = .sleepEnterWait
    case 3: self = .noRadio
    case 4: self = .unspecified
    case 5: self = .ubloxUnitFailed
    case 6: self = .noAxp192
    case 7: self = .invalidRadioSetting
    case 8: self = .transmitFailed
    case 9: self = .brownout
    case 10: self = .sx1262Failure
    case 11: self = .radioSpiBug
    case 12: self = .flashCorruptionRecoverable
    case 13: self = .flashCorruptionUnrecoverable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .txWatchdog: return 1
    case .sleepEnterWait: return 2
    case .noRadio: return 3
    case .unspecified: return 4
    case .ubloxUnitFailed: return 5
    case .noAxp192: return 6
    case .invalidRadioSetting: return 7
    case .transmitFailed: return 8
    case .brownout: return 9
    case .sx1262Failure: return 10
    case .radioSpiBug: return 11
    case .flashCorruptionRecoverable: return 12
    case .flashCorruptionUnrecoverable: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CriticalErrorCode] = [
    .none,
    .txWatchdog,
    .sleepEnterWait,
    .noRadio,
    .unspecified,
    .ubloxUnitFailed,
    .noAxp192,
    .invalidRadioSetting,
    .transmitFailed,
    .brownout,
    .sx1262Failure,
    .radioSpiBug,
    .flashCorruptionRecoverable,
    .flashCorruptionUnrecoverable,
  ]

}

///
/// Enum for modules excluded from a device's configuration.
/// Each value represents a ModuleConfigType that can be toggled as excluded
/// by setting its corresponding bit in the `excluded_modules` bitmask field.
public enum ExcludedModules: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///
  /// Default value of 0 indicates no modules are excluded.
  case excludedNone // = 0

  ///
  /// MQTT module
  case mqttConfig // = 1

  ///
  /// Serial module
  case serialConfig // = 2

  ///
  /// External Notification module
  case extnotifConfig // = 4

  ///
  /// Store and Forward module
  case storeforwardConfig // = 8

  ///
  /// Range Test module
  case rangetestConfig // = 16

  ///
  /// Telemetry module
  case telemetryConfig // = 32

  ///
  /// Canned Message module
  case cannedmsgConfig // = 64

  ///
  /// Audio module
  case audioConfig // = 128

  ///
  /// Remote Hardware module
  case remotehardwareConfig // = 256

  ///
  /// Neighbor Info module
  case neighborinfoConfig // = 512

  ///
  /// Ambient Lighting module
  case ambientlightingConfig // = 1024

  ///
  /// Detection Sensor module
  case detectionsensorConfig // = 2048

  ///
  /// Paxcounter module
  case paxcounterConfig // = 4096
  case UNRECOGNIZED(Int)

  public init() {
    self = .excludedNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .excludedNone
    case 1: self = .mqttConfig
    case 2: self = .serialConfig
    case 4: self = .extnotifConfig
    case 8: self = .storeforwardConfig
    case 16: self = .rangetestConfig
    case 32: self = .telemetryConfig
    case 64: self = .cannedmsgConfig
    case 128: self = .audioConfig
    case 256: self = .remotehardwareConfig
    case 512: self = .neighborinfoConfig
    case 1024: self = .ambientlightingConfig
    case 2048: self = .detectionsensorConfig
    case 4096: self = .paxcounterConfig
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .excludedNone: return 0
    case .mqttConfig: return 1
    case .serialConfig: return 2
    case .extnotifConfig: return 4
    case .storeforwardConfig: return 8
    case .rangetestConfig: return 16
    case .telemetryConfig: return 32
    case .cannedmsgConfig: return 64
    case .audioConfig: return 128
    case .remotehardwareConfig: return 256
    case .neighborinfoConfig: return 512
    case .ambientlightingConfig: return 1024
    case .detectionsensorConfig: return 2048
    case .paxcounterConfig: return 4096
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ExcludedModules] = [
    .excludedNone,
    .mqttConfig,
    .serialConfig,
    .extnotifConfig,
    .storeforwardConfig,
    .rangetestConfig,
    .telemetryConfig,
    .cannedmsgConfig,
    .audioConfig,
    .remotehardwareConfig,
    .neighborinfoConfig,
    .ambientlightingConfig,
    .detectionsensorConfig,
    .paxcounterConfig,
  ]

}

///
/// A GPS Position
public struct Position: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The new preferred location encoding, multiply by 1e-7 to get degrees
  /// in floating point
  public var latitudeI: Int32 {
    get {return _storage._latitudeI ?? 0}
    set {_uniqueStorage()._latitudeI = newValue}
  }
  /// Returns true if `latitudeI` has been explicitly set.
  public var hasLatitudeI: Bool {return _storage._latitudeI != nil}
  /// Clears the value of `latitudeI`. Subsequent reads from it will return its default value.
  public mutating func clearLatitudeI() {_uniqueStorage()._latitudeI = nil}

  ///
  /// TODO: REPLACE
  public var longitudeI: Int32 {
    get {return _storage._longitudeI ?? 0}
    set {_uniqueStorage()._longitudeI = newValue}
  }
  /// Returns true if `longitudeI` has been explicitly set.
  public var hasLongitudeI: Bool {return _storage._longitudeI != nil}
  /// Clears the value of `longitudeI`. Subsequent reads from it will return its default value.
  public mutating func clearLongitudeI() {_uniqueStorage()._longitudeI = nil}

  ///
  /// In meters above MSL (but see issue #359)
  public var altitude: Int32 {
    get {return _storage._altitude ?? 0}
    set {_uniqueStorage()._altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  public var hasAltitude: Bool {return _storage._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  public mutating func clearAltitude() {_uniqueStorage()._altitude = nil}

  ///
  /// This is usually not sent over the mesh (to save space), but it is sent
  /// from the phone so that the local device can set its time if it is sent over
  /// the mesh (because there are devices on the mesh without GPS or RTC).
  /// seconds since 1970
  public var time: UInt32 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  ///
  /// TODO: REPLACE
  public var locationSource: Position.LocSource {
    get {return _storage._locationSource}
    set {_uniqueStorage()._locationSource = newValue}
  }

  ///
  /// TODO: REPLACE
  public var altitudeSource: Position.AltSource {
    get {return _storage._altitudeSource}
    set {_uniqueStorage()._altitudeSource = newValue}
  }

  ///
  /// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
  public var timestamp: UInt32 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  ///
  /// Pos. timestamp milliseconds adjustment (rarely available or required)
  public var timestampMillisAdjust: Int32 {
    get {return _storage._timestampMillisAdjust}
    set {_uniqueStorage()._timestampMillisAdjust = newValue}
  }

  ///
  /// HAE altitude in meters - can be used instead of MSL altitude
  public var altitudeHae: Int32 {
    get {return _storage._altitudeHae ?? 0}
    set {_uniqueStorage()._altitudeHae = newValue}
  }
  /// Returns true if `altitudeHae` has been explicitly set.
  public var hasAltitudeHae: Bool {return _storage._altitudeHae != nil}
  /// Clears the value of `altitudeHae`. Subsequent reads from it will return its default value.
  public mutating func clearAltitudeHae() {_uniqueStorage()._altitudeHae = nil}

  ///
  /// Geoidal separation in meters
  public var altitudeGeoidalSeparation: Int32 {
    get {return _storage._altitudeGeoidalSeparation ?? 0}
    set {_uniqueStorage()._altitudeGeoidalSeparation = newValue}
  }
  /// Returns true if `altitudeGeoidalSeparation` has been explicitly set.
  public var hasAltitudeGeoidalSeparation: Bool {return _storage._altitudeGeoidalSeparation != nil}
  /// Clears the value of `altitudeGeoidalSeparation`. Subsequent reads from it will return its default value.
  public mutating func clearAltitudeGeoidalSeparation() {_uniqueStorage()._altitudeGeoidalSeparation = nil}

  ///
  /// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
  /// - PDOP is sufficient for most cases
  /// - for higher precision scenarios, HDOP and VDOP can be used instead,
  ///   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
  /// TODO: REMOVE/INTEGRATE
  public var pdop: UInt32 {
    get {return _storage._pdop}
    set {_uniqueStorage()._pdop = newValue}
  }

  ///
  /// TODO: REPLACE
  public var hdop: UInt32 {
    get {return _storage._hdop}
    set {_uniqueStorage()._hdop = newValue}
  }

  ///
  /// TODO: REPLACE
  public var vdop: UInt32 {
    get {return _storage._vdop}
    set {_uniqueStorage()._vdop = newValue}
  }

  ///
  /// GPS accuracy (a hardware specific constant) in mm
  ///   multiplied with DOP to calculate positional accuracy
  /// Default: "'bout three meters-ish" :)
  public var gpsAccuracy: UInt32 {
    get {return _storage._gpsAccuracy}
    set {_uniqueStorage()._gpsAccuracy = newValue}
  }

  ///
  /// Ground speed in m/s and True North TRACK in 1/100 degrees
  /// Clarification of terms:
  /// - "track" is the direction of motion (measured in horizontal plane)
  /// - "heading" is where the fuselage points (measured in horizontal plane)
  /// - "yaw" indicates a relative rotation about the vertical axis
  /// TODO: REMOVE/INTEGRATE
  public var groundSpeed: UInt32 {
    get {return _storage._groundSpeed ?? 0}
    set {_uniqueStorage()._groundSpeed = newValue}
  }
  /// Returns true if `groundSpeed` has been explicitly set.
  public var hasGroundSpeed: Bool {return _storage._groundSpeed != nil}
  /// Clears the value of `groundSpeed`. Subsequent reads from it will return its default value.
  public mutating func clearGroundSpeed() {_uniqueStorage()._groundSpeed = nil}

  ///
  /// TODO: REPLACE
  public var groundTrack: UInt32 {
    get {return _storage._groundTrack ?? 0}
    set {_uniqueStorage()._groundTrack = newValue}
  }
  /// Returns true if `groundTrack` has been explicitly set.
  public var hasGroundTrack: Bool {return _storage._groundTrack != nil}
  /// Clears the value of `groundTrack`. Subsequent reads from it will return its default value.
  public mutating func clearGroundTrack() {_uniqueStorage()._groundTrack = nil}

  ///
  /// GPS fix quality (from NMEA GxGGA statement or similar)
  public var fixQuality: UInt32 {
    get {return _storage._fixQuality}
    set {_uniqueStorage()._fixQuality = newValue}
  }

  ///
  /// GPS fix type 2D/3D (from NMEA GxGSA statement)
  public var fixType: UInt32 {
    get {return _storage._fixType}
    set {_uniqueStorage()._fixType = newValue}
  }

  ///
  /// GPS "Satellites in View" number
  public var satsInView: UInt32 {
    get {return _storage._satsInView}
    set {_uniqueStorage()._satsInView = newValue}
  }

  ///
  /// Sensor ID - in case multiple positioning sensors are being used
  public var sensorID: UInt32 {
    get {return _storage._sensorID}
    set {_uniqueStorage()._sensorID = newValue}
  }

  ///
  /// Estimated/expected time (in seconds) until next update:
  /// - if we update at fixed intervals of X seconds, use X
  /// - if we update at dynamic intervals (based on relative movement etc),
  ///   but "AT LEAST every Y seconds", use Y
  public var nextUpdate: UInt32 {
    get {return _storage._nextUpdate}
    set {_uniqueStorage()._nextUpdate = newValue}
  }

  ///
  /// A sequence number, incremented with each Position message to help
  ///   detect lost updates if needed
  public var seqNumber: UInt32 {
    get {return _storage._seqNumber}
    set {_uniqueStorage()._seqNumber = newValue}
  }

  ///
  /// Indicates the bits of precision set by the sending node
  public var precisionBits: UInt32 {
    get {return _storage._precisionBits}
    set {_uniqueStorage()._precisionBits = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// How the location was acquired: manual, onboard GPS, external (EUD) GPS
  public enum LocSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case locUnset // = 0

    ///
    /// TODO: REPLACE
    case locManual // = 1

    ///
    /// TODO: REPLACE
    case locInternal // = 2

    ///
    /// TODO: REPLACE
    case locExternal // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .locUnset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnset
      case 1: self = .locManual
      case 2: self = .locInternal
      case 3: self = .locExternal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .locUnset: return 0
      case .locManual: return 1
      case .locInternal: return 2
      case .locExternal: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Position.LocSource] = [
      .locUnset,
      .locManual,
      .locInternal,
      .locExternal,
    ]

  }

  ///
  /// How the altitude was acquired: manual, GPS int/ext, etc
  /// Default: same as location_source if present
  public enum AltSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case altUnset // = 0

    ///
    /// TODO: REPLACE
    case altManual // = 1

    ///
    /// TODO: REPLACE
    case altInternal // = 2

    ///
    /// TODO: REPLACE
    case altExternal // = 3

    ///
    /// TODO: REPLACE
    case altBarometric // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .altUnset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .altUnset
      case 1: self = .altManual
      case 2: self = .altInternal
      case 3: self = .altExternal
      case 4: self = .altBarometric
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .altUnset: return 0
      case .altManual: return 1
      case .altInternal: return 2
      case .altExternal: return 3
      case .altBarometric: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Position.AltSource] = [
      .altUnset,
      .altManual,
      .altInternal,
      .altExternal,
      .altBarometric,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Broadcast when a newly powered mesh node wants to find a node num it can use
/// Sent from the phone over bluetooth to set the user id for the owner of this node.
/// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
/// The algorithm is as follows:
/// when a node starts up, it broadcasts their user and the normal flow is for all
/// other nodes to reply with their User as well (so the new node can build its nodedb)
/// If a node ever receives a User (not just the first broadcast) message where
/// the sender node number equals our node number, that indicates a collision has
/// occurred and the following steps should happen:
/// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
/// new User who just tried to sign in: it gets to keep its nodenum.
/// We send a broadcast message of OUR User (we use a broadcast so that the other node can
/// receive our message, considering we have the same id - it also serves to let
/// observers correct their nodedb) - this case is rare so it should be okay.
/// If any node receives a User where the macaddr is GTE than their local macaddr,
/// they have been vetoed and should pick a new random nodenum (filtering against
/// whatever it knows about the nodedb) and rebroadcast their User.
/// A few nodenums are reserved and will never be requested:
/// 0xff - broadcast
/// 0 through 3 - for future use
public struct User: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A globally unique ID string for this user.
  /// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
  /// Note: app developers are encouraged to also use the following standard
  /// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
  public var id: String = String()

  ///
  /// A full name for this user, i.e. "Kevin Hester"
  public var longName: String = String()

  ///
  /// A VERY short name, ideally two characters.
  /// Suitable for a tiny OLED screen
  public var shortName: String = String()

  ///
  /// Deprecated in Meshtastic 2.1.x
  /// This is the addr of the radio.
  /// Not populated by the phone, but added by the esp32 when broadcasting
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var macaddr: Data = Data()

  ///
  /// TBEAM, HELTEC, etc...
  /// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
  /// Apps will still need the string here for older builds
  /// (so OTA update can find the right image), but if the enum is available it will be used instead.
  public var hwModel: HardwareModel = .unset

  ///
  /// In some regions Ham radio operators have different bandwidth limitations than others.
  /// If this user is a licensed operator, set this flag.
  /// Also, "long_name" should be their licence number.
  public var isLicensed: Bool = false

  ///
  /// Indicates that the user's role in the mesh
  public var role: Config.DeviceConfig.Role = .client

  ///
  /// The public key of the user's device.
  /// This is sent out to other nodes on the mesh to allow them to compute a shared secret key.
  public var publicKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A message used in a traceroute
public struct RouteDiscovery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The list of nodenums this packet has visited so far to the destination.
  public var route: [UInt32] = []

  ///
  /// The list of SNRs (in dB, scaled by 4) in the route towards the destination.
  public var snrTowards: [Int32] = []

  ///
  /// The list of nodenums the packet has visited on the way back from the destination.
  public var routeBack: [UInt32] = []

  ///
  /// The list of SNRs (in dB, scaled by 4) in the route back from the destination.
  public var snrBack: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A Routing control Data packet handled by the routing module
public struct Routing: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variant: Routing.OneOf_Variant? = nil

  ///
  /// A route request going from the requester
  public var routeRequest: RouteDiscovery {
    get {
      if case .routeRequest(let v)? = variant {return v}
      return RouteDiscovery()
    }
    set {variant = .routeRequest(newValue)}
  }

  ///
  /// A route reply
  public var routeReply: RouteDiscovery {
    get {
      if case .routeReply(let v)? = variant {return v}
      return RouteDiscovery()
    }
    set {variant = .routeReply(newValue)}
  }

  ///
  /// A failure in delivering a message (usually used for routing control messages, but might be provided
  /// in addition to ack.fail_id to provide details on the type of failure).
  public var errorReason: Routing.Error {
    get {
      if case .errorReason(let v)? = variant {return v}
      return .none
    }
    set {variant = .errorReason(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    ///
    /// A route request going from the requester
    case routeRequest(RouteDiscovery)
    ///
    /// A route reply
    case routeReply(RouteDiscovery)
    ///
    /// A failure in delivering a message (usually used for routing control messages, but might be provided
    /// in addition to ack.fail_id to provide details on the type of failure).
    case errorReason(Routing.Error)

  }

  ///
  /// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
  /// details on the type of failure).
  public enum Error: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// This message is not a failure
    case none // = 0

    ///
    /// Our node doesn't have a route to the requested destination anymore.
    case noRoute // = 1

    ///
    /// We received a nak while trying to forward on your behalf
    case gotNak // = 2

    ///
    /// TODO: REPLACE
    case timeout // = 3

    ///
    /// No suitable interface could be found for delivering this packet
    case noInterface // = 4

    ///
    /// We reached the max retransmission count (typically for naive flood routing)
    case maxRetransmit // = 5

    ///
    /// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
    case noChannel // = 6

    ///
    /// The packet was too big for sending (exceeds interface MTU after encoding)
    case tooLarge // = 7

    ///
    /// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
    /// (possibly due to bad channel permissions)
    case noResponse // = 8

    ///
    /// Cannot send currently because duty cycle regulations will be violated.
    case dutyCycleLimit // = 9

    ///
    /// The application layer service on the remote node received your request, but considered your request somehow invalid
    case badRequest // = 32

    ///
    /// The application layer service on the remote node received your request, but considered your request not authorized
    /// (i.e you did not send the request on the required bound channel)
    case notAuthorized // = 33

    ///
    /// The client specified a PKI transport, but the node was unable to send the packet using PKI (and did not send the message at all)
    case pkiFailed // = 34

    ///
    /// The receiving node does not have a Public Key to decode with
    case pkiUnknownPubkey // = 35

    ///
    /// Admin packet otherwise checks out, but uses a bogus or expired session key
    case adminBadSessionKey // = 36

    ///
    /// Admin packet sent using PKC, but not from a public key on the admin key list
    case adminPublicKeyUnauthorized // = 37
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .noRoute
      case 2: self = .gotNak
      case 3: self = .timeout
      case 4: self = .noInterface
      case 5: self = .maxRetransmit
      case 6: self = .noChannel
      case 7: self = .tooLarge
      case 8: self = .noResponse
      case 9: self = .dutyCycleLimit
      case 32: self = .badRequest
      case 33: self = .notAuthorized
      case 34: self = .pkiFailed
      case 35: self = .pkiUnknownPubkey
      case 36: self = .adminBadSessionKey
      case 37: self = .adminPublicKeyUnauthorized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .noRoute: return 1
      case .gotNak: return 2
      case .timeout: return 3
      case .noInterface: return 4
      case .maxRetransmit: return 5
      case .noChannel: return 6
      case .tooLarge: return 7
      case .noResponse: return 8
      case .dutyCycleLimit: return 9
      case .badRequest: return 32
      case .notAuthorized: return 33
      case .pkiFailed: return 34
      case .pkiUnknownPubkey: return 35
      case .adminBadSessionKey: return 36
      case .adminPublicKeyUnauthorized: return 37
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Routing.Error] = [
      .none,
      .noRoute,
      .gotNak,
      .timeout,
      .noInterface,
      .maxRetransmit,
      .noChannel,
      .tooLarge,
      .noResponse,
      .dutyCycleLimit,
      .badRequest,
      .notAuthorized,
      .pkiFailed,
      .pkiUnknownPubkey,
      .adminBadSessionKey,
      .adminPublicKeyUnauthorized,
    ]

  }

  public init() {}
}

///
/// (Formerly called SubPacket)
/// The payload portion fo a packet, this is the actual bytes that are sent
/// inside a radio packet (because from/to are broken out by the comms library)
public struct DataMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Formerly named typ and of type Type
  public var portnum: PortNum = .unknownApp

  ///
  /// TODO: REPLACE
  public var payload: Data = Data()

  ///
  /// Not normally used, but for testing a sender can request that recipient
  /// responds in kind (i.e. if it received a position, it should unicast back it's position).
  /// Note: that if you set this on a broadcast you will receive many replies.
  public var wantResponse: Bool = false

  ///
  /// The address of the destination node.
  /// This field is is filled in by the mesh radio device software, application
  /// layer software should never need it.
  /// RouteDiscovery messages _must_ populate this.
  /// Other message types might need to if they are doing multihop routing.
  public var dest: UInt32 = 0

  ///
  /// The address of the original sender for this message.
  /// This field should _only_ be populated for reliable multihop packets (to keep
  /// packets small).
  public var source: UInt32 = 0

  ///
  /// Only used in routing or response messages.
  /// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
  public var requestID: UInt32 = 0

  ///
  /// If set, this message is intened to be a reply to a previously sent message with the defined id.
  public var replyID: UInt32 = 0

  ///
  /// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
  /// a message a heart or poop emoji.
  public var emoji: UInt32 = 0

  ///
  /// Bitfield for extra flags. First use is to indicate that user approves the packet being uploaded to MQTT.
  public var bitfield: UInt32 {
    get {return _bitfield ?? 0}
    set {_bitfield = newValue}
  }
  /// Returns true if `bitfield` has been explicitly set.
  public var hasBitfield: Bool {return self._bitfield != nil}
  /// Clears the value of `bitfield`. Subsequent reads from it will return its default value.
  public mutating func clearBitfield() {self._bitfield = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bitfield: UInt32? = nil
}

///
/// Waypoint message, used to share arbitrary locations across the mesh
public struct Waypoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Id of the waypoint
  public var id: UInt32 = 0

  ///
  /// latitude_i
  public var latitudeI: Int32 {
    get {return _latitudeI ?? 0}
    set {_latitudeI = newValue}
  }
  /// Returns true if `latitudeI` has been explicitly set.
  public var hasLatitudeI: Bool {return self._latitudeI != nil}
  /// Clears the value of `latitudeI`. Subsequent reads from it will return its default value.
  public mutating func clearLatitudeI() {self._latitudeI = nil}

  ///
  /// longitude_i
  public var longitudeI: Int32 {
    get {return _longitudeI ?? 0}
    set {_longitudeI = newValue}
  }
  /// Returns true if `longitudeI` has been explicitly set.
  public var hasLongitudeI: Bool {return self._longitudeI != nil}
  /// Clears the value of `longitudeI`. Subsequent reads from it will return its default value.
  public mutating func clearLongitudeI() {self._longitudeI = nil}

  ///
  /// Time the waypoint is to expire (epoch)
  public var expire: UInt32 = 0

  ///
  /// If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
  /// If zero, the waypoint is open to be edited by any member of the mesh.
  public var lockedTo: UInt32 = 0

  ///
  /// Name of the waypoint - max 30 chars
  public var name: String = String()

  ///
  /// Description of the waypoint - max 100 chars
  public var description_p: String = String()

  ///
  /// Designator icon for the waypoint in the form of a unicode emoji
  public var icon: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _latitudeI: Int32? = nil
  fileprivate var _longitudeI: Int32? = nil
}

///
/// This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
public struct MqttClientProxyMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The MQTT topic this message will be sent /received on
  public var topic: String = String()

  ///
  /// The actual service envelope payload or text for mqtt pub / sub
  public var payloadVariant: MqttClientProxyMessage.OneOf_PayloadVariant? = nil

  ///
  /// Bytes
  public var data: Data {
    get {
      if case .data(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .data(newValue)}
  }

  ///
  /// Text
  public var text: String {
    get {
      if case .text(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .text(newValue)}
  }

  ///
  /// Whether the message should be retained (or not)
  public var retained: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The actual service envelope payload or text for mqtt pub / sub
  public enum OneOf_PayloadVariant: Equatable, @unchecked Sendable {
    ///
    /// Bytes
    case data(Data)
    ///
    /// Text
    case text(String)

  }

  public init() {}
}

///
/// A packet envelope sent/received over the mesh
/// only payload_variant is sent in the payload portion of the LORA packet.
/// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
public struct MeshPacket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The sending node number.
  /// Note: Our crypto implementation uses this field as well.
  /// See [crypto](/docs/overview/encryption) for details.
  public var from: UInt32 {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  ///
  /// The (immediate) destination for this packet
  public var to: UInt32 {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  ///
  /// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
  /// If unset, packet was on the primary channel.
  /// A particular node might know only a subset of channels in use on the mesh.
  /// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
  /// Very briefly, while sending and receiving deep inside the device Router code, this field instead
  /// contains the 'channel hash' instead of the index.
  /// This 'trick' is only used while the payload_variant is an 'encrypted'.
  public var channel: UInt32 {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  public var payloadVariant: OneOf_PayloadVariant? {
    get {return _storage._payloadVariant}
    set {_uniqueStorage()._payloadVariant = newValue}
  }

  ///
  /// TODO: REPLACE
  public var decoded: DataMessage {
    get {
      if case .decoded(let v)? = _storage._payloadVariant {return v}
      return DataMessage()
    }
    set {_uniqueStorage()._payloadVariant = .decoded(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var encrypted: Data {
    get {
      if case .encrypted(let v)? = _storage._payloadVariant {return v}
      return Data()
    }
    set {_uniqueStorage()._payloadVariant = .encrypted(newValue)}
  }

  ///
  /// A unique ID for this packet.
  /// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
  /// Otherwise a unique ID for this packet, useful for flooding algorithms.
  /// ID only needs to be unique on a _per sender_ basis, and it only
  /// needs to be unique for a few minutes (long enough to last for the length of
  /// any ACK or the completion of a mesh broadcast flood).
  /// Note: Our crypto implementation uses this id as well.
  /// See [crypto](/docs/overview/encryption) for details.
  public var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///
  /// The time this message was received by the esp32 (secs since 1970).
  /// Note: this field is _never_ sent on the radio link itself (to save space) Times
  /// are typically not sent over the mesh, but they will be added to any Packet
  /// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
  public var rxTime: UInt32 {
    get {return _storage._rxTime}
    set {_uniqueStorage()._rxTime = newValue}
  }

  ///
  /// *Never* sent over the radio links.
  /// Set during reception to indicate the SNR of this packet.
  /// Used to collect statistics on current link quality.
  public var rxSnr: Float {
    get {return _storage._rxSnr}
    set {_uniqueStorage()._rxSnr = newValue}
  }

  ///
  /// If unset treated as zero (no forwarding, send to direct neighbor nodes only)
  /// if 1, allow hopping through one node, etc...
  /// For our usecase real world topologies probably have a max of about 3.
  /// This field is normally placed into a few of bits in the header.
  public var hopLimit: UInt32 {
    get {return _storage._hopLimit}
    set {_uniqueStorage()._hopLimit = newValue}
  }

  ///
  /// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
  /// We would like to receive a ack packet in response.
  /// Broadcasts messages treat this flag specially: Since acks for broadcasts would
  /// rapidly flood the channel, the normal ack behavior is suppressed.
  /// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
  /// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
  /// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
  /// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
  /// Note: This flag is normally sent in a flag bit in the header when sent over the wire
  public var wantAck: Bool {
    get {return _storage._wantAck}
    set {_uniqueStorage()._wantAck = newValue}
  }

  ///
  /// The priority of this message for sending.
  /// See MeshPacket.Priority description for more details.
  public var priority: MeshPacket.Priority {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  ///
  /// rssi of received packet. Only sent to phone for dispay purposes.
  public var rxRssi: Int32 {
    get {return _storage._rxRssi}
    set {_uniqueStorage()._rxRssi = newValue}
  }

  ///
  /// Describe if this message is delayed
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var delayed: MeshPacket.Delayed {
    get {return _storage._delayed}
    set {_uniqueStorage()._delayed = newValue}
  }

  ///
  /// Describes whether this packet passed via MQTT somewhere along the path it currently took.
  public var viaMqtt: Bool {
    get {return _storage._viaMqtt}
    set {_uniqueStorage()._viaMqtt = newValue}
  }

  ///
  /// Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
  /// When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
  public var hopStart: UInt32 {
    get {return _storage._hopStart}
    set {_uniqueStorage()._hopStart = newValue}
  }

  ///
  /// Records the public key the packet was encrypted with, if applicable.
  public var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  ///
  /// Indicates whether the packet was en/decrypted using PKI
  public var pkiEncrypted: Bool {
    get {return _storage._pkiEncrypted}
    set {_uniqueStorage()._pkiEncrypted = newValue}
  }

  ///
  /// Last byte of the node number of the node that should be used as the next hop in routing. 
  /// Set by the firmware internally, clients are not supposed to set this.
  public var nextHop: UInt32 {
    get {return _storage._nextHop}
    set {_uniqueStorage()._nextHop = newValue}
  }

  ///
  /// Last byte of the node number of the node that will relay/relayed this packet.
  /// Set by the firmware internally, clients are not supposed to set this.
  public var relayNode: UInt32 {
    get {return _storage._relayNode}
    set {_uniqueStorage()._relayNode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PayloadVariant: Equatable, @unchecked Sendable {
    ///
    /// TODO: REPLACE
    case decoded(DataMessage)
    ///
    /// TODO: REPLACE
    case encrypted(Data)

  }

  ///
  /// The priority of this message for sending.
  /// Higher priorities are sent first (when managing the transmit queue).
  /// This field is never sent over the air, it is only used internally inside of a local device node.
  /// API clients (either on the local node or connected directly to the node)
  /// can set this parameter if necessary.
  /// (values must be <= 127 to keep protobuf field to one byte in size.
  /// Detailed background on this field:
  /// I noticed a funny side effect of lora being so slow: Usually when making
  /// a protocol there isnt much need to use message priority to change the order
  /// of transmission (because interfaces are fairly fast).
  /// But for lora where packets can take a few seconds each, it is very important
  /// to make sure that critical packets are sent ASAP.
  /// In the case of meshtastic that means we want to send protocol acks as soon as possible
  /// (to prevent unneeded retransmissions), we want routing messages to be sent next,
  /// then messages marked as reliable and finally 'background' packets like periodic position updates.
  /// So I bit the bullet and implemented a new (internal - not sent over the air)
  /// field in MeshPacket called 'priority'.
  /// And the transmission queue in the router object is now a priority queue.
  public enum Priority: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// Treated as Priority.DEFAULT
    case unset // = 0

    ///
    /// TODO: REPLACE
    case min // = 1

    ///
    /// Background position updates are sent with very low priority -
    /// if the link is super congested they might not go out at all
    case background // = 10

    ///
    /// This priority is used for most messages that don't have a priority set
    case `default` // = 64

    ///
    /// If priority is unset but the message is marked as want_ack,
    /// assume it is important and use a slightly higher priority
    case reliable // = 70

    ///
    /// If priority is unset but the packet is a response to a request, we want it to get there relatively quickly.
    /// Furthermore, responses stop relaying packets directed to a node early.
    case response // = 80

    ///
    /// Higher priority for specific message types (portnums) to distinguish between other reliable packets.
    case high // = 100

    ///
    /// Higher priority alert message used for critical alerts which take priority over other reliable packets.
    case alert // = 110

    ///
    /// Ack/naks are sent with very high priority to ensure that retransmission
    /// stops as soon as possible
    case ack // = 120

    ///
    /// TODO: REPLACE
    case max // = 127
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .min
      case 10: self = .background
      case 64: self = .default
      case 70: self = .reliable
      case 80: self = .response
      case 100: self = .high
      case 110: self = .alert
      case 120: self = .ack
      case 127: self = .max
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .min: return 1
      case .background: return 10
      case .default: return 64
      case .reliable: return 70
      case .response: return 80
      case .high: return 100
      case .alert: return 110
      case .ack: return 120
      case .max: return 127
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [MeshPacket.Priority] = [
      .unset,
      .min,
      .background,
      .default,
      .reliable,
      .response,
      .high,
      .alert,
      .ack,
      .max,
    ]

  }

  ///
  /// Identify if this is a delayed packet
  public enum Delayed: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// If unset, the message is being sent in real time.
    case noDelay // = 0

    ///
    /// The message is delayed and was originally a broadcast
    case broadcast // = 1

    ///
    /// The message is delayed and was originally a direct message
    case direct // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .noDelay
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noDelay
      case 1: self = .broadcast
      case 2: self = .direct
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noDelay: return 0
      case .broadcast: return 1
      case .direct: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [MeshPacket.Delayed] = [
      .noDelay,
      .broadcast,
      .direct,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// The bluetooth to device link:
/// Old BTLE protocol docs from TODO, merge in above and make real docs...
/// use protocol buffers, and NanoPB
/// messages from device to phone:
/// POSITION_UPDATE (..., time)
/// TEXT_RECEIVED(from, text, time)
/// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
/// messages from phone to device:
/// SET_MYID(id, human readable long, human readable short) (send down the unique ID
/// string used for this node, a human readable string shown for that id, and a very
/// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
/// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
/// nodes() (returns list of nodes, with full info, last time seen, loc, battery
/// level etc) SET_CONFIG (switches device to a new set of radio params and
/// preshared key, drops all existing nodes, force our node to rejoin this new group)
/// Full information about a node on the mesh
public struct NodeInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The node number
  public var num: UInt32 {
    get {return _storage._num}
    set {_uniqueStorage()._num = newValue}
  }

  ///
  /// The user info for this node
  public var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  ///
  /// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
  /// Position.time now indicates the last time we received a POSITION from that node.
  public var position: Position {
    get {return _storage._position ?? Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {_uniqueStorage()._position = nil}

  ///
  /// Returns the Signal-to-noise ratio (SNR) of the last received message,
  /// as measured by the receiver. Return SNR of the last received message in dB
  public var snr: Float {
    get {return _storage._snr}
    set {_uniqueStorage()._snr = newValue}
  }

  ///
  /// Set to indicate the last time we received a packet from this node
  public var lastHeard: UInt32 {
    get {return _storage._lastHeard}
    set {_uniqueStorage()._lastHeard = newValue}
  }

  ///
  /// The latest device metrics for the node.
  public var deviceMetrics: DeviceMetrics {
    get {return _storage._deviceMetrics ?? DeviceMetrics()}
    set {_uniqueStorage()._deviceMetrics = newValue}
  }
  /// Returns true if `deviceMetrics` has been explicitly set.
  public var hasDeviceMetrics: Bool {return _storage._deviceMetrics != nil}
  /// Clears the value of `deviceMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceMetrics() {_uniqueStorage()._deviceMetrics = nil}

  ///
  /// local channel index we heard that node on. Only populated if its not the default channel.
  public var channel: UInt32 {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  ///
  /// True if we witnessed the node over MQTT instead of LoRA transport
  public var viaMqtt: Bool {
    get {return _storage._viaMqtt}
    set {_uniqueStorage()._viaMqtt = newValue}
  }

  ///
  /// Number of hops away from us this node is (0 if direct neighbor)
  public var hopsAway: UInt32 {
    get {return _storage._hopsAway ?? 0}
    set {_uniqueStorage()._hopsAway = newValue}
  }
  /// Returns true if `hopsAway` has been explicitly set.
  public var hasHopsAway: Bool {return _storage._hopsAway != nil}
  /// Clears the value of `hopsAway`. Subsequent reads from it will return its default value.
  public mutating func clearHopsAway() {_uniqueStorage()._hopsAway = nil}

  ///
  /// True if node is in our favorites list
  /// Persists between NodeDB internal clean ups
  public var isFavorite: Bool {
    get {return _storage._isFavorite}
    set {_uniqueStorage()._isFavorite = newValue}
  }

  ///
  /// True if node is in our ignored list
  /// Persists between NodeDB internal clean ups
  public var isIgnored: Bool {
    get {return _storage._isIgnored}
    set {_uniqueStorage()._isIgnored = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Unique local debugging info for this node
/// Note: we don't include position or the user info, because that will come in the
/// Sent to the phone in response to WantNodes.
public struct MyNodeInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Tells the phone what our node number is, default starting value is
  /// lowbyte of macaddr, but it will be fixed if that is already in use
  public var myNodeNum: UInt32 = 0

  ///
  /// The total number of reboots this node has ever encountered
  /// (well - since the last time we discarded preferences)
  public var rebootCount: UInt32 = 0

  ///
  /// The minimum app version that can talk to this device.
  /// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
  public var minAppVersion: UInt32 = 0

  ///
  /// Unique hardware identifier for this device
  public var deviceID: Data = Data()

  ///
  /// The PlatformIO environment used to build this firmware
  public var pioEnv: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Debug output from the device.
/// To minimize the size of records inside the device code, if a time/source/level is not set
/// on the message it is assumed to be a continuation of the previously sent message.
/// This allows the device code to use fixed maxlen 64 byte strings for messages,
/// and then extend as needed by emitting multiple records.
public struct LogRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Log levels, chosen to match python logging conventions.
  public var message: String = String()

  ///
  /// Seconds since 1970 - or 0 for unknown/unset
  public var time: UInt32 = 0

  ///
  /// Usually based on thread name - if known
  public var source: String = String()

  ///
  /// Not yet set
  public var level: LogRecord.Level = .unset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  public enum Level: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// Log levels, chosen to match python logging conventions.
    case unset // = 0

    ///
    /// Log levels, chosen to match python logging conventions.
    case critical // = 50

    ///
    /// Log levels, chosen to match python logging conventions.
    case error // = 40

    ///
    /// Log levels, chosen to match python logging conventions.
    case warning // = 30

    ///
    /// Log levels, chosen to match python logging conventions.
    case info // = 20

    ///
    /// Log levels, chosen to match python logging conventions.
    case debug // = 10

    ///
    /// Log levels, chosen to match python logging conventions.
    case trace // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 5: self = .trace
      case 10: self = .debug
      case 20: self = .info
      case 30: self = .warning
      case 40: self = .error
      case 50: self = .critical
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .trace: return 5
      case .debug: return 10
      case .info: return 20
      case .warning: return 30
      case .error: return 40
      case .critical: return 50
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [LogRecord.Level] = [
      .unset,
      .critical,
      .error,
      .warning,
      .info,
      .debug,
      .trace,
    ]

  }

  public init() {}
}

public struct QueueStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Last attempt to queue status, ErrorCode 
  public var res: Int32 = 0

  /// Free entries in the outgoing queue 
  public var free: UInt32 = 0

  /// Maximum entries in the outgoing queue 
  public var maxlen: UInt32 = 0

  /// What was mesh packet id that generated this response? 
  public var meshPacketID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Packets from the radio to the phone will appear on the fromRadio characteristic.
/// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
/// It will sit in that descriptor until consumed by the phone,
/// at which point the next item in the FIFO will be populated.
public struct FromRadio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The packet id, used to allow the phone to request missing read packets from the FIFO,
  /// see our bluetooth docs
  public var id: UInt32 = 0

  ///
  /// Log levels, chosen to match python logging conventions.
  public var payloadVariant: FromRadio.OneOf_PayloadVariant? = nil

  ///
  /// Log levels, chosen to match python logging conventions.
  public var packet: MeshPacket {
    get {
      if case .packet(let v)? = payloadVariant {return v}
      return MeshPacket()
    }
    set {payloadVariant = .packet(newValue)}
  }

  ///
  /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  public var myInfo: MyNodeInfo {
    get {
      if case .myInfo(let v)? = payloadVariant {return v}
      return MyNodeInfo()
    }
    set {payloadVariant = .myInfo(newValue)}
  }

  ///
  /// One packet is sent for each node in the on radio DB
  /// starts over with the first node in our DB
  public var nodeInfo: NodeInfo {
    get {
      if case .nodeInfo(let v)? = payloadVariant {return v}
      return NodeInfo()
    }
    set {payloadVariant = .nodeInfo(newValue)}
  }

  ///
  /// Include a part of the config (was: RadioConfig radio)
  public var config: Config {
    get {
      if case .config(let v)? = payloadVariant {return v}
      return Config()
    }
    set {payloadVariant = .config(newValue)}
  }

  ///
  /// Set to send debug console output over our protobuf stream
  public var logRecord: LogRecord {
    get {
      if case .logRecord(let v)? = payloadVariant {return v}
      return LogRecord()
    }
    set {payloadVariant = .logRecord(newValue)}
  }

  ///
  /// Sent as true once the device has finished sending all of the responses to want_config
  /// recipient should check if this ID matches our original request nonce, if
  /// not, it means your config responses haven't started yet.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  public var configCompleteID: UInt32 {
    get {
      if case .configCompleteID(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .configCompleteID(newValue)}
  }

  ///
  /// Sent to tell clients the radio has just rebooted.
  /// Set to true if present.
  /// Not used on all transports, currently just used for the serial console.
  /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
  public var rebooted: Bool {
    get {
      if case .rebooted(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .rebooted(newValue)}
  }

  ///
  /// Include module config
  public var moduleConfig: ModuleConfig {
    get {
      if case .moduleConfig(let v)? = payloadVariant {return v}
      return ModuleConfig()
    }
    set {payloadVariant = .moduleConfig(newValue)}
  }

  ///
  /// One packet is sent for each channel
  public var channel: Channel {
    get {
      if case .channel(let v)? = payloadVariant {return v}
      return Channel()
    }
    set {payloadVariant = .channel(newValue)}
  }

  ///
  /// Queue status info
  public var queueStatus: QueueStatus {
    get {
      if case .queueStatus(let v)? = payloadVariant {return v}
      return QueueStatus()
    }
    set {payloadVariant = .queueStatus(newValue)}
  }

  ///
  /// File Transfer Chunk
  public var xmodemPacket: XModem {
    get {
      if case .xmodemPacket(let v)? = payloadVariant {return v}
      return XModem()
    }
    set {payloadVariant = .xmodemPacket(newValue)}
  }

  ///
  /// Device metadata message
  public var metadata: DeviceMetadata {
    get {
      if case .metadata(let v)? = payloadVariant {return v}
      return DeviceMetadata()
    }
    set {payloadVariant = .metadata(newValue)}
  }

  ///
  /// MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
  public var mqttClientProxyMessage: MqttClientProxyMessage {
    get {
      if case .mqttClientProxyMessage(let v)? = payloadVariant {return v}
      return MqttClientProxyMessage()
    }
    set {payloadVariant = .mqttClientProxyMessage(newValue)}
  }

  ///
  /// File system manifest messages
  public var fileInfo: FileInfo {
    get {
      if case .fileInfo(let v)? = payloadVariant {return v}
      return FileInfo()
    }
    set {payloadVariant = .fileInfo(newValue)}
  }

  ///
  /// Notification message to the client
  public var clientNotification: ClientNotification {
    get {
      if case .clientNotification(let v)? = payloadVariant {return v}
      return ClientNotification()
    }
    set {payloadVariant = .clientNotification(newValue)}
  }

  ///
  /// Persistent data for device-ui
  public var deviceuiConfig: DeviceUIConfig {
    get {
      if case .deviceuiConfig(let v)? = payloadVariant {return v}
      return DeviceUIConfig()
    }
    set {payloadVariant = .deviceuiConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  public enum OneOf_PayloadVariant: Equatable, Sendable {
    ///
    /// Log levels, chosen to match python logging conventions.
    case packet(MeshPacket)
    ///
    /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case myInfo(MyNodeInfo)
    ///
    /// One packet is sent for each node in the on radio DB
    /// starts over with the first node in our DB
    case nodeInfo(NodeInfo)
    ///
    /// Include a part of the config (was: RadioConfig radio)
    case config(Config)
    ///
    /// Set to send debug console output over our protobuf stream
    case logRecord(LogRecord)
    ///
    /// Sent as true once the device has finished sending all of the responses to want_config
    /// recipient should check if this ID matches our original request nonce, if
    /// not, it means your config responses haven't started yet.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case configCompleteID(UInt32)
    ///
    /// Sent to tell clients the radio has just rebooted.
    /// Set to true if present.
    /// Not used on all transports, currently just used for the serial console.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    case rebooted(Bool)
    ///
    /// Include module config
    case moduleConfig(ModuleConfig)
    ///
    /// One packet is sent for each channel
    case channel(Channel)
    ///
    /// Queue status info
    case queueStatus(QueueStatus)
    ///
    /// File Transfer Chunk
    case xmodemPacket(XModem)
    ///
    /// Device metadata message
    case metadata(DeviceMetadata)
    ///
    /// MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
    case mqttClientProxyMessage(MqttClientProxyMessage)
    ///
    /// File system manifest messages
    case fileInfo(FileInfo)
    ///
    /// Notification message to the client
    case clientNotification(ClientNotification)
    ///
    /// Persistent data for device-ui
    case deviceuiConfig(DeviceUIConfig)

  }

  public init() {}
}

///
/// A notification message from the device to the client
/// To be used for important messages that should to be displayed to the user
/// in the form of push notifications or validation messages when saving
/// invalid configuration.
public struct ClientNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The id of the packet we're notifying in response to
  public var replyID: UInt32 {
    get {return _replyID ?? 0}
    set {_replyID = newValue}
  }
  /// Returns true if `replyID` has been explicitly set.
  public var hasReplyID: Bool {return self._replyID != nil}
  /// Clears the value of `replyID`. Subsequent reads from it will return its default value.
  public mutating func clearReplyID() {self._replyID = nil}

  ///
  /// Seconds since 1970 - or 0 for unknown/unset
  public var time: UInt32 = 0

  ///
  /// The level type of notification
  public var level: LogRecord.Level = .unset

  ///
  /// The message body of the notification
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _replyID: UInt32? = nil
}

///
/// Individual File info for the device
public struct FileInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The fully qualified path of the file
  public var fileName: String = String()

  ///
  /// The size of the file in bytes
  public var sizeBytes: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
/// Once the write completes the phone can assume it is handled.
public struct ToRadio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Log levels, chosen to match python logging conventions.
  public var payloadVariant: ToRadio.OneOf_PayloadVariant? = nil

  ///
  /// Send this packet on the mesh
  public var packet: MeshPacket {
    get {
      if case .packet(let v)? = payloadVariant {return v}
      return MeshPacket()
    }
    set {payloadVariant = .packet(newValue)}
  }

  ///
  /// Phone wants radio to send full node db to the phone, This is
  /// typically the first packet sent to the radio when the phone gets a
  /// bluetooth connection. The radio will respond by sending back a
  /// MyNodeInfo, a owner, a radio config and a series of
  /// FromRadio.node_infos, and config_complete
  /// the integer you write into this field will be reported back in the
  /// config_complete_id response this allows clients to never be confused by
  /// a stale old partially sent config.
  public var wantConfigID: UInt32 {
    get {
      if case .wantConfigID(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .wantConfigID(newValue)}
  }

  ///
  /// Tell API server we are disconnecting now.
  /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
  /// (Sending this message is optional for clients)
  public var disconnect: Bool {
    get {
      if case .disconnect(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .disconnect(newValue)}
  }

  public var xmodemPacket: XModem {
    get {
      if case .xmodemPacket(let v)? = payloadVariant {return v}
      return XModem()
    }
    set {payloadVariant = .xmodemPacket(newValue)}
  }

  ///
  /// MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
  public var mqttClientProxyMessage: MqttClientProxyMessage {
    get {
      if case .mqttClientProxyMessage(let v)? = payloadVariant {return v}
      return MqttClientProxyMessage()
    }
    set {payloadVariant = .mqttClientProxyMessage(newValue)}
  }

  ///
  /// Heartbeat message (used to keep the device connection awake on serial)
  public var heartbeat: Heartbeat {
    get {
      if case .heartbeat(let v)? = payloadVariant {return v}
      return Heartbeat()
    }
    set {payloadVariant = .heartbeat(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  public enum OneOf_PayloadVariant: Equatable, Sendable {
    ///
    /// Send this packet on the mesh
    case packet(MeshPacket)
    ///
    /// Phone wants radio to send full node db to the phone, This is
    /// typically the first packet sent to the radio when the phone gets a
    /// bluetooth connection. The radio will respond by sending back a
    /// MyNodeInfo, a owner, a radio config and a series of
    /// FromRadio.node_infos, and config_complete
    /// the integer you write into this field will be reported back in the
    /// config_complete_id response this allows clients to never be confused by
    /// a stale old partially sent config.
    case wantConfigID(UInt32)
    ///
    /// Tell API server we are disconnecting now.
    /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
    /// (Sending this message is optional for clients)
    case disconnect(Bool)
    case xmodemPacket(XModem)
    ///
    /// MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
    case mqttClientProxyMessage(MqttClientProxyMessage)
    ///
    /// Heartbeat message (used to keep the device connection awake on serial)
    case heartbeat(Heartbeat)

  }

  public init() {}
}

///
/// Compressed message payload
public struct Compressed: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// PortNum to determine the how to handle the compressed payload.
  public var portnum: PortNum = .unknownApp

  ///
  /// Compressed data.
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Full info on edges for a single node
public struct NeighborInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The node ID of the node sending info on its neighbors
  public var nodeID: UInt32 = 0

  ///
  /// Field to pass neighbor info for the next sending cycle
  public var lastSentByID: UInt32 = 0

  ///
  /// Broadcast interval of the represented node (in seconds)
  public var nodeBroadcastIntervalSecs: UInt32 = 0

  ///
  /// The list of out edges from this node
  public var neighbors: [Neighbor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A single edge in the mesh
public struct Neighbor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Node ID of neighbor
  public var nodeID: UInt32 = 0

  ///
  /// SNR of last heard message
  public var snr: Float = 0

  ///
  /// Reception time (in secs since 1970) of last message that was last sent by this ID.
  /// Note: this is for local storage only and will not be sent out over the mesh.
  public var lastRxTime: UInt32 = 0

  ///
  /// Broadcast interval of this neighbor (in seconds).
  /// Note: this is for local storage only and will not be sent out over the mesh.
  public var nodeBroadcastIntervalSecs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Device metadata response
public struct DeviceMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Device firmware version string
  public var firmwareVersion: String = String()

  ///
  /// Device state version
  public var deviceStateVersion: UInt32 = 0

  ///
  /// Indicates whether the device can shutdown CPU natively or via power management chip
  public var canShutdown: Bool = false

  ///
  /// Indicates that the device has native wifi capability
  public var hasWifi_p: Bool = false

  ///
  /// Indicates that the device has native bluetooth capability
  public var hasBluetooth_p: Bool = false

  ///
  /// Indicates that the device has an ethernet peripheral
  public var hasEthernet_p: Bool = false

  ///
  /// Indicates that the device's role in the mesh
  public var role: Config.DeviceConfig.Role = .client

  ///
  /// Indicates the device's current enabled position flags
  public var positionFlags: UInt32 = 0

  ///
  /// Device hardware model
  public var hwModel: HardwareModel = .unset

  ///
  /// Has Remote Hardware enabled
  public var hasRemoteHardware_p: Bool = false

  ///
  /// Has PKC capabilities
  public var hasPkc_p: Bool = false

  ///
  /// Bit field of boolean for excluded modules
  /// (bitwise OR of ExcludedModules)
  public var excludedModules: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// A heartbeat message is sent to the node from the client to keep the connection alive.
/// This is currently only needed to keep serial connections alive, but can be used by any PhoneAPI.
public struct Heartbeat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// RemoteHardwarePins associated with a node
public struct NodeRemoteHardwarePin: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The node_num exposing the available gpio pin
  public var nodeNum: UInt32 = 0

  ///
  /// The the available gpio pin for usage with RemoteHardware module
  public var pin: RemoteHardwarePin {
    get {return _pin ?? RemoteHardwarePin()}
    set {_pin = newValue}
  }
  /// Returns true if `pin` has been explicitly set.
  public var hasPin: Bool {return self._pin != nil}
  /// Clears the value of `pin`. Subsequent reads from it will return its default value.
  public mutating func clearPin() {self._pin = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pin: RemoteHardwarePin? = nil
}

public struct ChunkedPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The ID of the entire payload
  public var payloadID: UInt32 = 0

  ///
  /// The total number of chunks in the payload
  public var chunkCount: UInt32 = 0

  ///
  /// The current chunk index in the total
  public var chunkIndex: UInt32 = 0

  ///
  /// The binary data of the current chunk
  public var payloadChunk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Wrapper message for broken repeated oneof support
public struct resend_chunks: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chunks: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Responses to a ChunkedPayload request
public struct ChunkedPayloadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The ID of the entire payload
  public var payloadID: UInt32 = 0

  public var payloadVariant: ChunkedPayloadResponse.OneOf_PayloadVariant? = nil

  ///
  /// Request to transfer chunked payload
  public var requestTransfer: Bool {
    get {
      if case .requestTransfer(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .requestTransfer(newValue)}
  }

  ///
  /// Accept the transfer chunked payload
  public var acceptTransfer: Bool {
    get {
      if case .acceptTransfer(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .acceptTransfer(newValue)}
  }

  ///
  /// Request missing indexes in the chunked payload
  public var resendChunks: resend_chunks {
    get {
      if case .resendChunks(let v)? = payloadVariant {return v}
      return resend_chunks()
    }
    set {payloadVariant = .resendChunks(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PayloadVariant: Equatable, Sendable {
    ///
    /// Request to transfer chunked payload
    case requestTransfer(Bool)
    ///
    /// Accept the transfer chunked payload
    case acceptTransfer(Bool)
    ///
    /// Request missing indexes in the chunked payload
    case resendChunks(resend_chunks)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension HardwareModel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "TLORA_V2"),
    2: .same(proto: "TLORA_V1"),
    3: .same(proto: "TLORA_V2_1_1P6"),
    4: .same(proto: "TBEAM"),
    5: .same(proto: "HELTEC_V2_0"),
    6: .same(proto: "TBEAM_V0P7"),
    7: .same(proto: "T_ECHO"),
    8: .same(proto: "TLORA_V1_1P3"),
    9: .same(proto: "RAK4631"),
    10: .same(proto: "HELTEC_V2_1"),
    11: .same(proto: "HELTEC_V1"),
    12: .same(proto: "LILYGO_TBEAM_S3_CORE"),
    13: .same(proto: "RAK11200"),
    14: .same(proto: "NANO_G1"),
    15: .same(proto: "TLORA_V2_1_1P8"),
    16: .same(proto: "TLORA_T3_S3"),
    17: .same(proto: "NANO_G1_EXPLORER"),
    18: .same(proto: "NANO_G2_ULTRA"),
    19: .same(proto: "LORA_TYPE"),
    20: .same(proto: "WIPHONE"),
    21: .same(proto: "WIO_WM1110"),
    22: .same(proto: "RAK2560"),
    23: .same(proto: "HELTEC_HRU_3601"),
    24: .same(proto: "HELTEC_WIRELESS_BRIDGE"),
    25: .same(proto: "STATION_G1"),
    26: .same(proto: "RAK11310"),
    27: .same(proto: "SENSELORA_RP2040"),
    28: .same(proto: "SENSELORA_S3"),
    29: .same(proto: "CANARYONE"),
    30: .same(proto: "RP2040_LORA"),
    31: .same(proto: "STATION_G2"),
    32: .same(proto: "LORA_RELAY_V1"),
    33: .same(proto: "NRF52840DK"),
    34: .same(proto: "PPR"),
    35: .same(proto: "GENIEBLOCKS"),
    36: .same(proto: "NRF52_UNKNOWN"),
    37: .same(proto: "PORTDUINO"),
    38: .same(proto: "ANDROID_SIM"),
    39: .same(proto: "DIY_V1"),
    40: .same(proto: "NRF52840_PCA10059"),
    41: .same(proto: "DR_DEV"),
    42: .same(proto: "M5STACK"),
    43: .same(proto: "HELTEC_V3"),
    44: .same(proto: "HELTEC_WSL_V3"),
    45: .same(proto: "BETAFPV_2400_TX"),
    46: .same(proto: "BETAFPV_900_NANO_TX"),
    47: .same(proto: "RPI_PICO"),
    48: .same(proto: "HELTEC_WIRELESS_TRACKER"),
    49: .same(proto: "HELTEC_WIRELESS_PAPER"),
    50: .same(proto: "T_DECK"),
    51: .same(proto: "T_WATCH_S3"),
    52: .same(proto: "PICOMPUTER_S3"),
    53: .same(proto: "HELTEC_HT62"),
    54: .same(proto: "EBYTE_ESP32_S3"),
    55: .same(proto: "ESP32_S3_PICO"),
    56: .same(proto: "CHATTER_2"),
    57: .same(proto: "HELTEC_WIRELESS_PAPER_V1_0"),
    58: .same(proto: "HELTEC_WIRELESS_TRACKER_V1_0"),
    59: .same(proto: "UNPHONE"),
    60: .same(proto: "TD_LORAC"),
    61: .same(proto: "CDEBYTE_EORA_S3"),
    62: .same(proto: "TWC_MESH_V4"),
    63: .same(proto: "NRF52_PROMICRO_DIY"),
    64: .same(proto: "RADIOMASTER_900_BANDIT_NANO"),
    65: .same(proto: "HELTEC_CAPSULE_SENSOR_V3"),
    66: .same(proto: "HELTEC_VISION_MASTER_T190"),
    67: .same(proto: "HELTEC_VISION_MASTER_E213"),
    68: .same(proto: "HELTEC_VISION_MASTER_E290"),
    69: .same(proto: "HELTEC_MESH_NODE_T114"),
    70: .same(proto: "SENSECAP_INDICATOR"),
    71: .same(proto: "TRACKER_T1000_E"),
    72: .same(proto: "RAK3172"),
    73: .same(proto: "WIO_E5"),
    74: .same(proto: "RADIOMASTER_900_BANDIT"),
    75: .same(proto: "ME25LS01_4Y10TD"),
    76: .same(proto: "RP2040_FEATHER_RFM95"),
    77: .same(proto: "M5STACK_COREBASIC"),
    78: .same(proto: "M5STACK_CORE2"),
    79: .same(proto: "RPI_PICO2"),
    80: .same(proto: "M5STACK_CORES3"),
    81: .same(proto: "SEEED_XIAO_S3"),
    82: .same(proto: "MS24SF1"),
    83: .same(proto: "TLORA_C6"),
    84: .same(proto: "WISMESH_TAP"),
    85: .same(proto: "ROUTASTIC"),
    86: .same(proto: "MESH_TAB"),
    255: .same(proto: "PRIVATE_HW"),
  ]
}

extension Constants: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ZERO"),
    233: .same(proto: "DATA_PAYLOAD_LEN"),
  ]
}

extension CriticalErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "TX_WATCHDOG"),
    2: .same(proto: "SLEEP_ENTER_WAIT"),
    3: .same(proto: "NO_RADIO"),
    4: .same(proto: "UNSPECIFIED"),
    5: .same(proto: "UBLOX_UNIT_FAILED"),
    6: .same(proto: "NO_AXP192"),
    7: .same(proto: "INVALID_RADIO_SETTING"),
    8: .same(proto: "TRANSMIT_FAILED"),
    9: .same(proto: "BROWNOUT"),
    10: .same(proto: "SX1262_FAILURE"),
    11: .same(proto: "RADIO_SPI_BUG"),
    12: .same(proto: "FLASH_CORRUPTION_RECOVERABLE"),
    13: .same(proto: "FLASH_CORRUPTION_UNRECOVERABLE"),
  ]
}

extension ExcludedModules: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXCLUDED_NONE"),
    1: .same(proto: "MQTT_CONFIG"),
    2: .same(proto: "SERIAL_CONFIG"),
    4: .same(proto: "EXTNOTIF_CONFIG"),
    8: .same(proto: "STOREFORWARD_CONFIG"),
    16: .same(proto: "RANGETEST_CONFIG"),
    32: .same(proto: "TELEMETRY_CONFIG"),
    64: .same(proto: "CANNEDMSG_CONFIG"),
    128: .same(proto: "AUDIO_CONFIG"),
    256: .same(proto: "REMOTEHARDWARE_CONFIG"),
    512: .same(proto: "NEIGHBORINFO_CONFIG"),
    1024: .same(proto: "AMBIENTLIGHTING_CONFIG"),
    2048: .same(proto: "DETECTIONSENSOR_CONFIG"),
    4096: .same(proto: "PAXCOUNTER_CONFIG"),
  ]
}

extension Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_i"),
    2: .standard(proto: "longitude_i"),
    3: .same(proto: "altitude"),
    4: .same(proto: "time"),
    5: .standard(proto: "location_source"),
    6: .standard(proto: "altitude_source"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "timestamp_millis_adjust"),
    9: .standard(proto: "altitude_hae"),
    10: .standard(proto: "altitude_geoidal_separation"),
    11: .same(proto: "PDOP"),
    12: .same(proto: "HDOP"),
    13: .same(proto: "VDOP"),
    14: .standard(proto: "gps_accuracy"),
    15: .standard(proto: "ground_speed"),
    16: .standard(proto: "ground_track"),
    17: .standard(proto: "fix_quality"),
    18: .standard(proto: "fix_type"),
    19: .standard(proto: "sats_in_view"),
    20: .standard(proto: "sensor_id"),
    21: .standard(proto: "next_update"),
    22: .standard(proto: "seq_number"),
    23: .standard(proto: "precision_bits"),
  ]

  fileprivate class _StorageClass {
    var _latitudeI: Int32? = nil
    var _longitudeI: Int32? = nil
    var _altitude: Int32? = nil
    var _time: UInt32 = 0
    var _locationSource: Position.LocSource = .locUnset
    var _altitudeSource: Position.AltSource = .altUnset
    var _timestamp: UInt32 = 0
    var _timestampMillisAdjust: Int32 = 0
    var _altitudeHae: Int32? = nil
    var _altitudeGeoidalSeparation: Int32? = nil
    var _pdop: UInt32 = 0
    var _hdop: UInt32 = 0
    var _vdop: UInt32 = 0
    var _gpsAccuracy: UInt32 = 0
    var _groundSpeed: UInt32? = nil
    var _groundTrack: UInt32? = nil
    var _fixQuality: UInt32 = 0
    var _fixType: UInt32 = 0
    var _satsInView: UInt32 = 0
    var _sensorID: UInt32 = 0
    var _nextUpdate: UInt32 = 0
    var _seqNumber: UInt32 = 0
    var _precisionBits: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _latitudeI = source._latitudeI
      _longitudeI = source._longitudeI
      _altitude = source._altitude
      _time = source._time
      _locationSource = source._locationSource
      _altitudeSource = source._altitudeSource
      _timestamp = source._timestamp
      _timestampMillisAdjust = source._timestampMillisAdjust
      _altitudeHae = source._altitudeHae
      _altitudeGeoidalSeparation = source._altitudeGeoidalSeparation
      _pdop = source._pdop
      _hdop = source._hdop
      _vdop = source._vdop
      _gpsAccuracy = source._gpsAccuracy
      _groundSpeed = source._groundSpeed
      _groundTrack = source._groundTrack
      _fixQuality = source._fixQuality
      _fixType = source._fixType
      _satsInView = source._satsInView
      _sensorID = source._sensorID
      _nextUpdate = source._nextUpdate
      _seqNumber = source._seqNumber
      _precisionBits = source._precisionBits
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularSFixed32Field(value: &_storage._latitudeI) }()
        case 2: try { try decoder.decodeSingularSFixed32Field(value: &_storage._longitudeI) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._altitude) }()
        case 4: try { try decoder.decodeSingularFixed32Field(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._locationSource) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._altitudeSource) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._timestampMillisAdjust) }()
        case 9: try { try decoder.decodeSingularSInt32Field(value: &_storage._altitudeHae) }()
        case 10: try { try decoder.decodeSingularSInt32Field(value: &_storage._altitudeGeoidalSeparation) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._pdop) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._hdop) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._vdop) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAccuracy) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundSpeed) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundTrack) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixQuality) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixType) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._satsInView) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._sensorID) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextUpdate) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._seqNumber) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._precisionBits) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._latitudeI {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._longitudeI {
        try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._altitude {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      if _storage._time != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._time, fieldNumber: 4)
      }
      if _storage._locationSource != .locUnset {
        try visitor.visitSingularEnumField(value: _storage._locationSource, fieldNumber: 5)
      }
      if _storage._altitudeSource != .altUnset {
        try visitor.visitSingularEnumField(value: _storage._altitudeSource, fieldNumber: 6)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._timestamp, fieldNumber: 7)
      }
      if _storage._timestampMillisAdjust != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timestampMillisAdjust, fieldNumber: 8)
      }
      try { if let v = _storage._altitudeHae {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._altitudeGeoidalSeparation {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 10)
      } }()
      if _storage._pdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pdop, fieldNumber: 11)
      }
      if _storage._hdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hdop, fieldNumber: 12)
      }
      if _storage._vdop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._vdop, fieldNumber: 13)
      }
      if _storage._gpsAccuracy != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsAccuracy, fieldNumber: 14)
      }
      try { if let v = _storage._groundSpeed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._groundTrack {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      } }()
      if _storage._fixQuality != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fixQuality, fieldNumber: 17)
      }
      if _storage._fixType != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fixType, fieldNumber: 18)
      }
      if _storage._satsInView != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._satsInView, fieldNumber: 19)
      }
      if _storage._sensorID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sensorID, fieldNumber: 20)
      }
      if _storage._nextUpdate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextUpdate, fieldNumber: 21)
      }
      if _storage._seqNumber != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seqNumber, fieldNumber: 22)
      }
      if _storage._precisionBits != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._precisionBits, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Position, rhs: Position) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitudeI != rhs_storage._latitudeI {return false}
        if _storage._longitudeI != rhs_storage._longitudeI {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._locationSource != rhs_storage._locationSource {return false}
        if _storage._altitudeSource != rhs_storage._altitudeSource {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._timestampMillisAdjust != rhs_storage._timestampMillisAdjust {return false}
        if _storage._altitudeHae != rhs_storage._altitudeHae {return false}
        if _storage._altitudeGeoidalSeparation != rhs_storage._altitudeGeoidalSeparation {return false}
        if _storage._pdop != rhs_storage._pdop {return false}
        if _storage._hdop != rhs_storage._hdop {return false}
        if _storage._vdop != rhs_storage._vdop {return false}
        if _storage._gpsAccuracy != rhs_storage._gpsAccuracy {return false}
        if _storage._groundSpeed != rhs_storage._groundSpeed {return false}
        if _storage._groundTrack != rhs_storage._groundTrack {return false}
        if _storage._fixQuality != rhs_storage._fixQuality {return false}
        if _storage._fixType != rhs_storage._fixType {return false}
        if _storage._satsInView != rhs_storage._satsInView {return false}
        if _storage._sensorID != rhs_storage._sensorID {return false}
        if _storage._nextUpdate != rhs_storage._nextUpdate {return false}
        if _storage._seqNumber != rhs_storage._seqNumber {return false}
        if _storage._precisionBits != rhs_storage._precisionBits {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Position.LocSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNSET"),
    1: .same(proto: "LOC_MANUAL"),
    2: .same(proto: "LOC_INTERNAL"),
    3: .same(proto: "LOC_EXTERNAL"),
  ]
}

extension Position.AltSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALT_UNSET"),
    1: .same(proto: "ALT_MANUAL"),
    2: .same(proto: "ALT_INTERNAL"),
    3: .same(proto: "ALT_EXTERNAL"),
    4: .same(proto: "ALT_BAROMETRIC"),
  ]
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "long_name"),
    3: .standard(proto: "short_name"),
    4: .same(proto: "macaddr"),
    5: .standard(proto: "hw_model"),
    6: .standard(proto: "is_licensed"),
    7: .same(proto: "role"),
    8: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.macaddr) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.hwModel) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isLicensed) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
    }
    if !self.macaddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.macaddr, fieldNumber: 4)
    }
    if self.hwModel != .unset {
      try visitor.visitSingularEnumField(value: self.hwModel, fieldNumber: 5)
    }
    if self.isLicensed != false {
      try visitor.visitSingularBoolField(value: self.isLicensed, fieldNumber: 6)
    }
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 7)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.macaddr != rhs.macaddr {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs.isLicensed != rhs.isLicensed {return false}
    if lhs.role != rhs.role {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RouteDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteDiscovery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
    2: .standard(proto: "snr_towards"),
    3: .standard(proto: "route_back"),
    4: .standard(proto: "snr_back"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.route) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.snrTowards) }()
      case 3: try { try decoder.decodeRepeatedFixed32Field(value: &self.routeBack) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.snrBack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.route, fieldNumber: 1)
    }
    if !self.snrTowards.isEmpty {
      try visitor.visitPackedInt32Field(value: self.snrTowards, fieldNumber: 2)
    }
    if !self.routeBack.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.routeBack, fieldNumber: 3)
    }
    if !self.snrBack.isEmpty {
      try visitor.visitPackedInt32Field(value: self.snrBack, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RouteDiscovery, rhs: RouteDiscovery) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.snrTowards != rhs.snrTowards {return false}
    if lhs.routeBack != rhs.routeBack {return false}
    if lhs.snrBack != rhs.snrBack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Routing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_request"),
    2: .standard(proto: "route_reply"),
    3: .standard(proto: "error_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeRequest(v)
        }
      }()
      case 2: try {
        var v: RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeReply(v)
        }
      }()
      case 3: try {
        var v: Routing.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .errorReason(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .routeRequest?: try {
      guard case .routeRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .routeReply?: try {
      guard case .routeReply(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .errorReason?: try {
      guard case .errorReason(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Routing, rhs: Routing) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routing.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "NO_ROUTE"),
    2: .same(proto: "GOT_NAK"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "NO_INTERFACE"),
    5: .same(proto: "MAX_RETRANSMIT"),
    6: .same(proto: "NO_CHANNEL"),
    7: .same(proto: "TOO_LARGE"),
    8: .same(proto: "NO_RESPONSE"),
    9: .same(proto: "DUTY_CYCLE_LIMIT"),
    32: .same(proto: "BAD_REQUEST"),
    33: .same(proto: "NOT_AUTHORIZED"),
    34: .same(proto: "PKI_FAILED"),
    35: .same(proto: "PKI_UNKNOWN_PUBKEY"),
    36: .same(proto: "ADMIN_BAD_SESSION_KEY"),
    37: .same(proto: "ADMIN_PUBLIC_KEY_UNAUTHORIZED"),
  ]
}

extension DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "portnum"),
    2: .same(proto: "payload"),
    3: .standard(proto: "want_response"),
    4: .same(proto: "dest"),
    5: .same(proto: "source"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "reply_id"),
    8: .same(proto: "emoji"),
    9: .same(proto: "bitfield"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wantResponse) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dest) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.source) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self.replyID) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.emoji) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._bitfield) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.portnum != .unknownApp {
      try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if self.wantResponse != false {
      try visitor.visitSingularBoolField(value: self.wantResponse, fieldNumber: 3)
    }
    if self.dest != 0 {
      try visitor.visitSingularFixed32Field(value: self.dest, fieldNumber: 4)
    }
    if self.source != 0 {
      try visitor.visitSingularFixed32Field(value: self.source, fieldNumber: 5)
    }
    if self.requestID != 0 {
      try visitor.visitSingularFixed32Field(value: self.requestID, fieldNumber: 6)
    }
    if self.replyID != 0 {
      try visitor.visitSingularFixed32Field(value: self.replyID, fieldNumber: 7)
    }
    if self.emoji != 0 {
      try visitor.visitSingularFixed32Field(value: self.emoji, fieldNumber: 8)
    }
    try { if let v = self._bitfield {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataMessage, rhs: DataMessage) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.wantResponse != rhs.wantResponse {return false}
    if lhs.dest != rhs.dest {return false}
    if lhs.source != rhs.source {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.replyID != rhs.replyID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs._bitfield != rhs._bitfield {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "latitude_i"),
    3: .standard(proto: "longitude_i"),
    4: .same(proto: "expire"),
    5: .standard(proto: "locked_to"),
    6: .same(proto: "name"),
    7: .same(proto: "description"),
    8: .same(proto: "icon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self._latitudeI) }()
      case 3: try { try decoder.decodeSingularSFixed32Field(value: &self._longitudeI) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.expire) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.lockedTo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.icon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._latitudeI {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._longitudeI {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 3)
    } }()
    if self.expire != 0 {
      try visitor.visitSingularUInt32Field(value: self.expire, fieldNumber: 4)
    }
    if self.lockedTo != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockedTo, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if self.icon != 0 {
      try visitor.visitSingularFixed32Field(value: self.icon, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Waypoint, rhs: Waypoint) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._latitudeI != rhs._latitudeI {return false}
    if lhs._longitudeI != rhs._longitudeI {return false}
    if lhs.expire != rhs.expire {return false}
    if lhs.lockedTo != rhs.lockedTo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MqttClientProxyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MqttClientProxyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "data"),
    3: .same(proto: "text"),
    4: .same(proto: "retained"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .data(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .text(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.retained) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    switch self.payloadVariant {
    case .data?: try {
      guard case .data(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .text?: try {
      guard case .text(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.retained != false {
      try visitor.visitSingularBoolField(value: self.retained, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MqttClientProxyMessage, rhs: MqttClientProxyMessage) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.retained != rhs.retained {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeshPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MeshPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .same(proto: "channel"),
    4: .same(proto: "decoded"),
    5: .same(proto: "encrypted"),
    6: .same(proto: "id"),
    7: .standard(proto: "rx_time"),
    8: .standard(proto: "rx_snr"),
    9: .standard(proto: "hop_limit"),
    10: .standard(proto: "want_ack"),
    11: .same(proto: "priority"),
    12: .standard(proto: "rx_rssi"),
    13: .same(proto: "delayed"),
    14: .standard(proto: "via_mqtt"),
    15: .standard(proto: "hop_start"),
    16: .standard(proto: "public_key"),
    17: .standard(proto: "pki_encrypted"),
    18: .standard(proto: "next_hop"),
    19: .standard(proto: "relay_node"),
  ]

  fileprivate class _StorageClass {
    var _from: UInt32 = 0
    var _to: UInt32 = 0
    var _channel: UInt32 = 0
    var _payloadVariant: MeshPacket.OneOf_PayloadVariant?
    var _id: UInt32 = 0
    var _rxTime: UInt32 = 0
    var _rxSnr: Float = 0
    var _hopLimit: UInt32 = 0
    var _wantAck: Bool = false
    var _priority: MeshPacket.Priority = .unset
    var _rxRssi: Int32 = 0
    var _delayed: MeshPacket.Delayed = .noDelay
    var _viaMqtt: Bool = false
    var _hopStart: UInt32 = 0
    var _publicKey: Data = Data()
    var _pkiEncrypted: Bool = false
    var _nextHop: UInt32 = 0
    var _relayNode: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _to = source._to
      _channel = source._channel
      _payloadVariant = source._payloadVariant
      _id = source._id
      _rxTime = source._rxTime
      _rxSnr = source._rxSnr
      _hopLimit = source._hopLimit
      _wantAck = source._wantAck
      _priority = source._priority
      _rxRssi = source._rxRssi
      _delayed = source._delayed
      _viaMqtt = source._viaMqtt
      _hopStart = source._hopStart
      _publicKey = source._publicKey
      _pkiEncrypted = source._pkiEncrypted
      _nextHop = source._nextHop
      _relayNode = source._relayNode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._from) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._to) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
        case 4: try {
          var v: DataMessage?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .decoded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .decoded(v)
          }
        }()
        case 5: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .encrypted(v)
          }
        }()
        case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._id) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._rxTime) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._rxSnr) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._wantAck) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._rxRssi) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._delayed) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._viaMqtt) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopStart) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._pkiEncrypted) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextHop) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._relayNode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._from != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._from, fieldNumber: 1)
      }
      if _storage._to != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._to, fieldNumber: 2)
      }
      if _storage._channel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 3)
      }
      switch _storage._payloadVariant {
      case .decoded?: try {
        guard case .decoded(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .encrypted?: try {
        guard case .encrypted(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if _storage._id != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._id, fieldNumber: 6)
      }
      if _storage._rxTime != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._rxTime, fieldNumber: 7)
      }
      if _storage._rxSnr.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._rxSnr, fieldNumber: 8)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 9)
      }
      if _storage._wantAck != false {
        try visitor.visitSingularBoolField(value: _storage._wantAck, fieldNumber: 10)
      }
      if _storage._priority != .unset {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 11)
      }
      if _storage._rxRssi != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rxRssi, fieldNumber: 12)
      }
      if _storage._delayed != .noDelay {
        try visitor.visitSingularEnumField(value: _storage._delayed, fieldNumber: 13)
      }
      if _storage._viaMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._viaMqtt, fieldNumber: 14)
      }
      if _storage._hopStart != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopStart, fieldNumber: 15)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 16)
      }
      if _storage._pkiEncrypted != false {
        try visitor.visitSingularBoolField(value: _storage._pkiEncrypted, fieldNumber: 17)
      }
      if _storage._nextHop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextHop, fieldNumber: 18)
      }
      if _storage._relayNode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._relayNode, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MeshPacket, rhs: MeshPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._payloadVariant != rhs_storage._payloadVariant {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._rxTime != rhs_storage._rxTime {return false}
        if _storage._rxSnr != rhs_storage._rxSnr {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._wantAck != rhs_storage._wantAck {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._rxRssi != rhs_storage._rxRssi {return false}
        if _storage._delayed != rhs_storage._delayed {return false}
        if _storage._viaMqtt != rhs_storage._viaMqtt {return false}
        if _storage._hopStart != rhs_storage._hopStart {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._pkiEncrypted != rhs_storage._pkiEncrypted {return false}
        if _storage._nextHop != rhs_storage._nextHop {return false}
        if _storage._relayNode != rhs_storage._relayNode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeshPacket.Priority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "MIN"),
    10: .same(proto: "BACKGROUND"),
    64: .same(proto: "DEFAULT"),
    70: .same(proto: "RELIABLE"),
    80: .same(proto: "RESPONSE"),
    100: .same(proto: "HIGH"),
    110: .same(proto: "ALERT"),
    120: .same(proto: "ACK"),
    127: .same(proto: "MAX"),
  ]
}

extension MeshPacket.Delayed: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_DELAY"),
    1: .same(proto: "DELAYED_BROADCAST"),
    2: .same(proto: "DELAYED_DIRECT"),
  ]
}

extension NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "user"),
    3: .same(proto: "position"),
    4: .same(proto: "snr"),
    5: .standard(proto: "last_heard"),
    6: .standard(proto: "device_metrics"),
    7: .same(proto: "channel"),
    8: .standard(proto: "via_mqtt"),
    9: .standard(proto: "hops_away"),
    10: .standard(proto: "is_favorite"),
    11: .standard(proto: "is_ignored"),
  ]

  fileprivate class _StorageClass {
    var _num: UInt32 = 0
    var _user: User? = nil
    var _position: Position? = nil
    var _snr: Float = 0
    var _lastHeard: UInt32 = 0
    var _deviceMetrics: DeviceMetrics? = nil
    var _channel: UInt32 = 0
    var _viaMqtt: Bool = false
    var _hopsAway: UInt32? = nil
    var _isFavorite: Bool = false
    var _isIgnored: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _num = source._num
      _user = source._user
      _position = source._position
      _snr = source._snr
      _lastHeard = source._lastHeard
      _deviceMetrics = source._deviceMetrics
      _channel = source._channel
      _viaMqtt = source._viaMqtt
      _hopsAway = source._hopsAway
      _isFavorite = source._isFavorite
      _isIgnored = source._isIgnored
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._num) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._snr) }()
        case 5: try { try decoder.decodeSingularFixed32Field(value: &_storage._lastHeard) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._deviceMetrics) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._viaMqtt) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopsAway) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isFavorite) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isIgnored) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._num != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._num, fieldNumber: 1)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._snr.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._snr, fieldNumber: 4)
      }
      if _storage._lastHeard != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._lastHeard, fieldNumber: 5)
      }
      try { if let v = _storage._deviceMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._channel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 7)
      }
      if _storage._viaMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._viaMqtt, fieldNumber: 8)
      }
      try { if let v = _storage._hopsAway {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      if _storage._isFavorite != false {
        try visitor.visitSingularBoolField(value: _storage._isFavorite, fieldNumber: 10)
      }
      if _storage._isIgnored != false {
        try visitor.visitSingularBoolField(value: _storage._isIgnored, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._num != rhs_storage._num {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._snr != rhs_storage._snr {return false}
        if _storage._lastHeard != rhs_storage._lastHeard {return false}
        if _storage._deviceMetrics != rhs_storage._deviceMetrics {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._viaMqtt != rhs_storage._viaMqtt {return false}
        if _storage._hopsAway != rhs_storage._hopsAway {return false}
        if _storage._isFavorite != rhs_storage._isFavorite {return false}
        if _storage._isIgnored != rhs_storage._isIgnored {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MyNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "my_node_num"),
    8: .standard(proto: "reboot_count"),
    11: .standard(proto: "min_app_version"),
    12: .standard(proto: "device_id"),
    13: .standard(proto: "pio_env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.myNodeNum) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.rebootCount) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.minAppVersion) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.deviceID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.pioEnv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myNodeNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.myNodeNum, fieldNumber: 1)
    }
    if self.rebootCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rebootCount, fieldNumber: 8)
    }
    if self.minAppVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAppVersion, fieldNumber: 11)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 12)
    }
    if !self.pioEnv.isEmpty {
      try visitor.visitSingularStringField(value: self.pioEnv, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MyNodeInfo, rhs: MyNodeInfo) -> Bool {
    if lhs.myNodeNum != rhs.myNodeNum {return false}
    if lhs.rebootCount != rhs.rebootCount {return false}
    if lhs.minAppVersion != rhs.minAppVersion {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.pioEnv != rhs.pioEnv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogRecord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "time"),
    3: .same(proto: "source"),
    4: .same(proto: "level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if self.level != .unset {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogRecord, rhs: LogRecord) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.time != rhs.time {return false}
    if lhs.source != rhs.source {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    5: .same(proto: "TRACE"),
    10: .same(proto: "DEBUG"),
    20: .same(proto: "INFO"),
    30: .same(proto: "WARNING"),
    40: .same(proto: "ERROR"),
    50: .same(proto: "CRITICAL"),
  ]
}

extension QueueStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueueStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "res"),
    2: .same(proto: "free"),
    3: .same(proto: "maxlen"),
    4: .standard(proto: "mesh_packet_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.res) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.free) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxlen) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.meshPacketID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.res != 0 {
      try visitor.visitSingularInt32Field(value: self.res, fieldNumber: 1)
    }
    if self.free != 0 {
      try visitor.visitSingularUInt32Field(value: self.free, fieldNumber: 2)
    }
    if self.maxlen != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxlen, fieldNumber: 3)
    }
    if self.meshPacketID != 0 {
      try visitor.visitSingularUInt32Field(value: self.meshPacketID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: QueueStatus, rhs: QueueStatus) -> Bool {
    if lhs.res != rhs.res {return false}
    if lhs.free != rhs.free {return false}
    if lhs.maxlen != rhs.maxlen {return false}
    if lhs.meshPacketID != rhs.meshPacketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FromRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FromRadio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "packet"),
    3: .standard(proto: "my_info"),
    4: .standard(proto: "node_info"),
    5: .same(proto: "config"),
    6: .standard(proto: "log_record"),
    7: .standard(proto: "config_complete_id"),
    8: .same(proto: "rebooted"),
    9: .same(proto: "moduleConfig"),
    10: .same(proto: "channel"),
    11: .same(proto: "queueStatus"),
    12: .same(proto: "xmodemPacket"),
    13: .same(proto: "metadata"),
    14: .same(proto: "mqttClientProxyMessage"),
    15: .same(proto: "fileInfo"),
    16: .same(proto: "clientNotification"),
    17: .same(proto: "deviceuiConfig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: MeshPacket?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .packet(v)
        }
      }()
      case 3: try {
        var v: MyNodeInfo?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .myInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .myInfo(v)
        }
      }()
      case 4: try {
        var v: NodeInfo?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .nodeInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .nodeInfo(v)
        }
      }()
      case 5: try {
        var v: Config?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .config(v)
        }
      }()
      case 6: try {
        var v: LogRecord?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .logRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .logRecord(v)
        }
      }()
      case 7: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .configCompleteID(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rebooted(v)
        }
      }()
      case 9: try {
        var v: ModuleConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .moduleConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .moduleConfig(v)
        }
      }()
      case 10: try {
        var v: Channel?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .channel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .channel(v)
        }
      }()
      case 11: try {
        var v: QueueStatus?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .queueStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .queueStatus(v)
        }
      }()
      case 12: try {
        var v: XModem?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .xmodemPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .xmodemPacket(v)
        }
      }()
      case 13: try {
        var v: DeviceMetadata?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .metadata(v)
        }
      }()
      case 14: try {
        var v: MqttClientProxyMessage?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqttClientProxyMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqttClientProxyMessage(v)
        }
      }()
      case 15: try {
        var v: FileInfo?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .fileInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .fileInfo(v)
        }
      }()
      case 16: try {
        var v: ClientNotification?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .clientNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .clientNotification(v)
        }
      }()
      case 17: try {
        var v: DeviceUIConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .deviceuiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .deviceuiConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.payloadVariant {
    case .packet?: try {
      guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .myInfo?: try {
      guard case .myInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .nodeInfo?: try {
      guard case .nodeInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .config?: try {
      guard case .config(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .logRecord?: try {
      guard case .logRecord(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .configCompleteID?: try {
      guard case .configCompleteID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }()
    case .rebooted?: try {
      guard case .rebooted(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .moduleConfig?: try {
      guard case .moduleConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .channel?: try {
      guard case .channel(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .queueStatus?: try {
      guard case .queueStatus(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .xmodemPacket?: try {
      guard case .xmodemPacket(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .mqttClientProxyMessage?: try {
      guard case .mqttClientProxyMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .fileInfo?: try {
      guard case .fileInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .clientNotification?: try {
      guard case .clientNotification(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .deviceuiConfig?: try {
      guard case .deviceuiConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FromRadio, rhs: FromRadio) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reply_id"),
    2: .same(proto: "time"),
    3: .same(proto: "level"),
    4: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._replyID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._replyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 2)
    }
    if self.level != .unset {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientNotification, rhs: ClientNotification) -> Bool {
    if lhs._replyID != rhs._replyID {return false}
    if lhs.time != rhs.time {return false}
    if lhs.level != rhs.level {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_name"),
    2: .standard(proto: "size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 1)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.sizeBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileInfo, rhs: FileInfo) -> Bool {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ToRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToRadio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packet"),
    3: .standard(proto: "want_config_id"),
    4: .same(proto: "disconnect"),
    5: .same(proto: "xmodemPacket"),
    6: .same(proto: "mqttClientProxyMessage"),
    7: .same(proto: "heartbeat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MeshPacket?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .packet(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .wantConfigID(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .disconnect(v)
        }
      }()
      case 5: try {
        var v: XModem?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .xmodemPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .xmodemPacket(v)
        }
      }()
      case 6: try {
        var v: MqttClientProxyMessage?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqttClientProxyMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqttClientProxyMessage(v)
        }
      }()
      case 7: try {
        var v: Heartbeat?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .heartbeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .heartbeat(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .packet?: try {
      guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wantConfigID?: try {
      guard case .wantConfigID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .xmodemPacket?: try {
      guard case .xmodemPacket(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .mqttClientProxyMessage?: try {
      guard case .mqttClientProxyMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .heartbeat?: try {
      guard case .heartbeat(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ToRadio, rhs: ToRadio) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compressed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Compressed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "portnum"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.portnum != .unknownApp {
      try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compressed, rhs: Compressed) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NeighborInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NeighborInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "last_sent_by_id"),
    3: .standard(proto: "node_broadcast_interval_secs"),
    4: .same(proto: "neighbors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lastSentByID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nodeBroadcastIntervalSecs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.neighbors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeID, fieldNumber: 1)
    }
    if self.lastSentByID != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastSentByID, fieldNumber: 2)
    }
    if self.nodeBroadcastIntervalSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeBroadcastIntervalSecs, fieldNumber: 3)
    }
    if !self.neighbors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.neighbors, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NeighborInfo, rhs: NeighborInfo) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.lastSentByID != rhs.lastSentByID {return false}
    if lhs.nodeBroadcastIntervalSecs != rhs.nodeBroadcastIntervalSecs {return false}
    if lhs.neighbors != rhs.neighbors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neighbor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Neighbor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "snr"),
    3: .standard(proto: "last_rx_time"),
    4: .standard(proto: "node_broadcast_interval_secs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.snr) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.lastRxTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.nodeBroadcastIntervalSecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeID, fieldNumber: 1)
    }
    if self.snr.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.snr, fieldNumber: 2)
    }
    if self.lastRxTime != 0 {
      try visitor.visitSingularFixed32Field(value: self.lastRxTime, fieldNumber: 3)
    }
    if self.nodeBroadcastIntervalSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeBroadcastIntervalSecs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Neighbor, rhs: Neighbor) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.snr != rhs.snr {return false}
    if lhs.lastRxTime != rhs.lastRxTime {return false}
    if lhs.nodeBroadcastIntervalSecs != rhs.nodeBroadcastIntervalSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "firmware_version"),
    2: .standard(proto: "device_state_version"),
    3: .same(proto: "canShutdown"),
    4: .same(proto: "hasWifi"),
    5: .same(proto: "hasBluetooth"),
    6: .same(proto: "hasEthernet"),
    7: .same(proto: "role"),
    8: .standard(proto: "position_flags"),
    9: .standard(proto: "hw_model"),
    10: .same(proto: "hasRemoteHardware"),
    11: .same(proto: "hasPKC"),
    12: .standard(proto: "excluded_modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.firmwareVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.deviceStateVersion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canShutdown) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasWifi_p) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasBluetooth_p) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasEthernet_p) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.positionFlags) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.hwModel) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.hasRemoteHardware_p) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.hasPkc_p) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.excludedModules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.firmwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.firmwareVersion, fieldNumber: 1)
    }
    if self.deviceStateVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceStateVersion, fieldNumber: 2)
    }
    if self.canShutdown != false {
      try visitor.visitSingularBoolField(value: self.canShutdown, fieldNumber: 3)
    }
    if self.hasWifi_p != false {
      try visitor.visitSingularBoolField(value: self.hasWifi_p, fieldNumber: 4)
    }
    if self.hasBluetooth_p != false {
      try visitor.visitSingularBoolField(value: self.hasBluetooth_p, fieldNumber: 5)
    }
    if self.hasEthernet_p != false {
      try visitor.visitSingularBoolField(value: self.hasEthernet_p, fieldNumber: 6)
    }
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 7)
    }
    if self.positionFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionFlags, fieldNumber: 8)
    }
    if self.hwModel != .unset {
      try visitor.visitSingularEnumField(value: self.hwModel, fieldNumber: 9)
    }
    if self.hasRemoteHardware_p != false {
      try visitor.visitSingularBoolField(value: self.hasRemoteHardware_p, fieldNumber: 10)
    }
    if self.hasPkc_p != false {
      try visitor.visitSingularBoolField(value: self.hasPkc_p, fieldNumber: 11)
    }
    if self.excludedModules != 0 {
      try visitor.visitSingularUInt32Field(value: self.excludedModules, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeviceMetadata, rhs: DeviceMetadata) -> Bool {
    if lhs.firmwareVersion != rhs.firmwareVersion {return false}
    if lhs.deviceStateVersion != rhs.deviceStateVersion {return false}
    if lhs.canShutdown != rhs.canShutdown {return false}
    if lhs.hasWifi_p != rhs.hasWifi_p {return false}
    if lhs.hasBluetooth_p != rhs.hasBluetooth_p {return false}
    if lhs.hasEthernet_p != rhs.hasEthernet_p {return false}
    if lhs.role != rhs.role {return false}
    if lhs.positionFlags != rhs.positionFlags {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs.hasRemoteHardware_p != rhs.hasRemoteHardware_p {return false}
    if lhs.hasPkc_p != rhs.hasPkc_p {return false}
    if lhs.excludedModules != rhs.excludedModules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Heartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Heartbeat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Heartbeat, rhs: Heartbeat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeRemoteHardwarePin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeRemoteHardwarePin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_num"),
    2: .same(proto: "pin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeNum) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.nodeNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeNum, fieldNumber: 1)
    }
    try { if let v = self._pin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeRemoteHardwarePin, rhs: NodeRemoteHardwarePin) -> Bool {
    if lhs.nodeNum != rhs.nodeNum {return false}
    if lhs._pin != rhs._pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChunkedPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChunkedPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_id"),
    2: .standard(proto: "chunk_count"),
    3: .standard(proto: "chunk_index"),
    4: .standard(proto: "payload_chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.payloadID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.chunkCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunkIndex) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payloadChunk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.payloadID != 0 {
      try visitor.visitSingularUInt32Field(value: self.payloadID, fieldNumber: 1)
    }
    if self.chunkCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunkCount, fieldNumber: 2)
    }
    if self.chunkIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunkIndex, fieldNumber: 3)
    }
    if !self.payloadChunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadChunk, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChunkedPayload, rhs: ChunkedPayload) -> Bool {
    if lhs.payloadID != rhs.payloadID {return false}
    if lhs.chunkCount != rhs.chunkCount {return false}
    if lhs.chunkIndex != rhs.chunkIndex {return false}
    if lhs.payloadChunk != rhs.payloadChunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension resend_chunks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".resend_chunks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.chunks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chunks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.chunks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: resend_chunks, rhs: resend_chunks) -> Bool {
    if lhs.chunks != rhs.chunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChunkedPayloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChunkedPayloadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_id"),
    2: .standard(proto: "request_transfer"),
    3: .standard(proto: "accept_transfer"),
    4: .standard(proto: "resend_chunks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.payloadID) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .requestTransfer(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .acceptTransfer(v)
        }
      }()
      case 4: try {
        var v: resend_chunks?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .resendChunks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .resendChunks(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.payloadID != 0 {
      try visitor.visitSingularUInt32Field(value: self.payloadID, fieldNumber: 1)
    }
    switch self.payloadVariant {
    case .requestTransfer?: try {
      guard case .requestTransfer(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .acceptTransfer?: try {
      guard case .acceptTransfer(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .resendChunks?: try {
      guard case .resendChunks(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChunkedPayloadResponse, rhs: ChunkedPayloadResponse) -> Bool {
    if lhs.payloadID != rhs.payloadID {return false}
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
