// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Payload Variant
  public var payloadVariant: Config.OneOf_PayloadVariant? = nil

  public var device: Config.DeviceConfig {
    get {
      if case .device(let v)? = payloadVariant {return v}
      return Config.DeviceConfig()
    }
    set {payloadVariant = .device(newValue)}
  }

  public var position: Config.PositionConfig {
    get {
      if case .position(let v)? = payloadVariant {return v}
      return Config.PositionConfig()
    }
    set {payloadVariant = .position(newValue)}
  }

  public var power: Config.PowerConfig {
    get {
      if case .power(let v)? = payloadVariant {return v}
      return Config.PowerConfig()
    }
    set {payloadVariant = .power(newValue)}
  }

  public var network: Config.NetworkConfig {
    get {
      if case .network(let v)? = payloadVariant {return v}
      return Config.NetworkConfig()
    }
    set {payloadVariant = .network(newValue)}
  }

  public var display: Config.DisplayConfig {
    get {
      if case .display(let v)? = payloadVariant {return v}
      return Config.DisplayConfig()
    }
    set {payloadVariant = .display(newValue)}
  }

  public var lora: Config.LoRaConfig {
    get {
      if case .lora(let v)? = payloadVariant {return v}
      return Config.LoRaConfig()
    }
    set {payloadVariant = .lora(newValue)}
  }

  public var bluetooth: Config.BluetoothConfig {
    get {
      if case .bluetooth(let v)? = payloadVariant {return v}
      return Config.BluetoothConfig()
    }
    set {payloadVariant = .bluetooth(newValue)}
  }

  public var security: Config.SecurityConfig {
    get {
      if case .security(let v)? = payloadVariant {return v}
      return Config.SecurityConfig()
    }
    set {payloadVariant = .security(newValue)}
  }

  public var sessionkey: Config.SessionkeyConfig {
    get {
      if case .sessionkey(let v)? = payloadVariant {return v}
      return Config.SessionkeyConfig()
    }
    set {payloadVariant = .sessionkey(newValue)}
  }

  public var deviceUi: DeviceUIConfig {
    get {
      if case .deviceUi(let v)? = payloadVariant {return v}
      return DeviceUIConfig()
    }
    set {payloadVariant = .deviceUi(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Payload Variant
  public enum OneOf_PayloadVariant: Equatable, Sendable {
    case device(Config.DeviceConfig)
    case position(Config.PositionConfig)
    case power(Config.PowerConfig)
    case network(Config.NetworkConfig)
    case display(Config.DisplayConfig)
    case lora(Config.LoRaConfig)
    case bluetooth(Config.BluetoothConfig)
    case security(Config.SecurityConfig)
    case sessionkey(Config.SessionkeyConfig)
    case deviceUi(DeviceUIConfig)

  }

  ///
  /// Configuration
  public struct DeviceConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Sets the role of node
    public var role: Config.DeviceConfig.Role = .client

    ///
    /// Disabling this will disable the SerialConsole by not initilizing the StreamAPI
    /// Moved to SecurityConfig
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var serialEnabled: Bool = false

    ///
    /// For boards without a hard wired button, this is the pin number that will be used
    /// Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
    public var buttonGpio: UInt32 = 0

    ///
    /// For boards without a PWM buzzer, this is the pin number that will be used
    /// Defaults to PIN_BUZZER if defined.
    public var buzzerGpio: UInt32 = 0

    ///
    /// Sets the role of node
    public var rebroadcastMode: Config.DeviceConfig.RebroadcastMode = .all

    ///
    /// Send our nodeinfo this often
    /// Defaults to 900 Seconds (15 minutes)
    public var nodeInfoBroadcastSecs: UInt32 = 0

    ///
    /// Treat double tap interrupt on supported accelerometers as a button press if set to true
    public var doubleTapAsButtonPress: Bool = false

    ///
    /// If true, device is considered to be "managed" by a mesh administrator
    /// Clients should then limit available configuration and administrative options inside the user interface
    /// Moved to SecurityConfig
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var isManaged: Bool = false

    ///
    /// Disables the triple-press of user button to enable or disable GPS
    public var disableTripleClick: Bool = false

    ///
    /// POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
    public var tzdef: String = String()

    ///
    /// If true, disable the default blinking LED (LED_PIN) behavior on the device 
    public var ledHeartbeatDisabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Defines the device's role on the Mesh network
    public enum Role: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Description: App connected or stand alone messaging device.
      /// Technical Details: Default Role
      case client // = 0

      ///
      ///  Description: Device that does not forward packets from other devices.
      case clientMute // = 1

      ///
      /// Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
      /// Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
      ///   The wifi radio and the oled screen will be put to sleep.
      ///   This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
      case router // = 2

      /// NOTE: This enum value was marked as deprecated in the .proto file
      case routerClient // = 3

      ///
      /// Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
      /// Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
      ///   or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
      case repeater // = 4

      ///
      /// Description: Broadcasts GPS position packets as priority.
      /// Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
      ///   When used in conjunction with power.is_power_saving = true, nodes will wake up,
      ///   send position, and then sleep for position.position_broadcast_secs seconds.
      case tracker // = 5

      ///
      /// Description: Broadcasts telemetry packets as priority.
      /// Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
      ///   When used in conjunction with power.is_power_saving = true, nodes will wake up,
      ///   send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
      case sensor // = 6

      ///
      /// Description: Optimized for ATAK system communication and reduces routine broadcasts.
      /// Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
      ///    Turns off many of the routine broadcasts to favor CoT packet stream
      ///    from the Meshtastic ATAK plugin -> IMeshService -> Node
      case tak // = 7

      ///
      /// Description: Device that only broadcasts as needed for stealth or power savings.
      /// Technical Details: Used for nodes that "only speak when spoken to"
      ///    Turns all of the routine broadcasts but allows for ad-hoc communication
      ///    Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
      ///    Can be used for clandestine operation or to dramatically reduce airtime / power consumption
      case clientHidden // = 8

      ///
      /// Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
      /// Technical Details: Used to automatically send a text message to the mesh
      ///    with the current position of the device on a frequent interval:
      ///    "I'm lost! Position: lat / long"
      case lostAndFound // = 9

      ///
      /// Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
      /// Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
      ///    and automatic TAK PLI (position location information) broadcasts.
      ///    Uses position module configuration to determine TAK PLI broadcast interval.
      case takTracker // = 10
      case UNRECOGNIZED(Int)

      public init() {
        self = .client
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .client
        case 1: self = .clientMute
        case 2: self = .router
        case 3: self = .routerClient
        case 4: self = .repeater
        case 5: self = .tracker
        case 6: self = .sensor
        case 7: self = .tak
        case 8: self = .clientHidden
        case 9: self = .lostAndFound
        case 10: self = .takTracker
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .client: return 0
        case .clientMute: return 1
        case .router: return 2
        case .routerClient: return 3
        case .repeater: return 4
        case .tracker: return 5
        case .sensor: return 6
        case .tak: return 7
        case .clientHidden: return 8
        case .lostAndFound: return 9
        case .takTracker: return 10
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DeviceConfig.Role] = [
        .client,
        .clientMute,
        .router,
        .routerClient,
        .repeater,
        .tracker,
        .sensor,
        .tak,
        .clientHidden,
        .lostAndFound,
        .takTracker,
      ]

    }

    ///
    /// Defines the device's behavior for how messages are rebroadcast
    public enum RebroadcastMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Default behavior.
      /// Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
      case all // = 0

      ///
      /// Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
      /// Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
      case allSkipDecoding // = 1

      ///
      /// Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
      /// Only rebroadcasts message on the nodes local primary / secondary channels.
      case localOnly // = 2

      ///
      /// Ignores observed messages from foreign meshes like LOCAL_ONLY,
      /// but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
      case knownOnly // = 3

      ///
      /// Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
      case none // = 4

      ///
      /// Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
      /// Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
      case corePortnumsOnly // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .all
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .all
        case 1: self = .allSkipDecoding
        case 2: self = .localOnly
        case 3: self = .knownOnly
        case 4: self = .none
        case 5: self = .corePortnumsOnly
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .all: return 0
        case .allSkipDecoding: return 1
        case .localOnly: return 2
        case .knownOnly: return 3
        case .none: return 4
        case .corePortnumsOnly: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DeviceConfig.RebroadcastMode] = [
        .all,
        .allSkipDecoding,
        .localOnly,
        .knownOnly,
        .none,
        .corePortnumsOnly,
      ]

    }

    public init() {}
  }

  ///
  /// Position Config
  public struct PositionConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// We should send our position this often (but only if it has changed significantly)
    /// Defaults to 15 minutes
    public var positionBroadcastSecs: UInt32 = 0

    ///
    /// Adaptive position braoadcast, which is now the default.
    public var positionBroadcastSmartEnabled: Bool = false

    ///
    /// If set, this node is at a fixed position.
    /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
    /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
    public var fixedPosition: Bool = false

    ///
    /// Is GPS enabled for this node?
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var gpsEnabled: Bool = false

    ///
    /// How often should we try to get GPS position (in seconds)
    /// or zero for the default of once every 30 seconds
    /// or a very large value (maxint) to update only once at boot.
    public var gpsUpdateInterval: UInt32 = 0

    ///
    /// Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var gpsAttemptTime: UInt32 = 0

    ///
    /// Bit field of boolean configuration options for POSITION messages
    /// (bitwise OR of PositionFlags)
    public var positionFlags: UInt32 = 0

    ///
    /// (Re)define GPS_RX_PIN for your board.
    public var rxGpio: UInt32 = 0

    ///
    /// (Re)define GPS_TX_PIN for your board.
    public var txGpio: UInt32 = 0

    ///
    /// The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
    public var broadcastSmartMinimumDistance: UInt32 = 0

    ///
    /// The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
    public var broadcastSmartMinimumIntervalSecs: UInt32 = 0

    ///
    /// (Re)define PIN_GPS_EN for your board.
    public var gpsEnGpio: UInt32 = 0

    ///
    /// Set where GPS is enabled, disabled, or not present
    public var gpsMode: Config.PositionConfig.GpsMode = .disabled

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// Bit field of boolean configuration options, indicating which optional
    /// fields to include when assembling POSITION messages.
    /// Longitude, latitude, altitude, speed, heading, and DOP
    /// are always included (also time if GPS-synced)
    /// NOTE: the more fields are included, the larger the message will be -
    ///   leading to longer airtime and a higher risk of packet loss
    public enum PositionFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Required for compilation
      case unset // = 0

      ///
      /// Include an altitude value (if available)
      case altitude // = 1

      ///
      /// Altitude value is MSL
      case altitudeMsl // = 2

      ///
      /// Include geoidal separation
      case geoidalSeparation // = 4

      ///
      /// Include the DOP value ; PDOP used by default, see below
      case dop // = 8

      ///
      /// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
      case hvdop // = 16

      ///
      /// Include number of "satellites in view"
      case satinview // = 32

      ///
      /// Include a sequence number incremented per packet
      case seqNo // = 64

      ///
      /// Include positional timestamp (from GPS solution)
      case timestamp // = 128

      ///
      /// Include positional heading
      /// Intended for use with vehicle not walking speeds
      /// walking speeds are likely to be error prone like the compass
      case heading // = 256

      ///
      /// Include positional speed
      /// Intended for use with vehicle not walking speeds
      /// walking speeds are likely to be error prone like the compass
      case speed // = 512
      case UNRECOGNIZED(Int)

      public init() {
        self = .unset
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .altitude
        case 2: self = .altitudeMsl
        case 4: self = .geoidalSeparation
        case 8: self = .dop
        case 16: self = .hvdop
        case 32: self = .satinview
        case 64: self = .seqNo
        case 128: self = .timestamp
        case 256: self = .heading
        case 512: self = .speed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unset: return 0
        case .altitude: return 1
        case .altitudeMsl: return 2
        case .geoidalSeparation: return 4
        case .dop: return 8
        case .hvdop: return 16
        case .satinview: return 32
        case .seqNo: return 64
        case .timestamp: return 128
        case .heading: return 256
        case .speed: return 512
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.PositionConfig.PositionFlags] = [
        .unset,
        .altitude,
        .altitudeMsl,
        .geoidalSeparation,
        .dop,
        .hvdop,
        .satinview,
        .seqNo,
        .timestamp,
        .heading,
        .speed,
      ]

    }

    public enum GpsMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// GPS is present but disabled
      case disabled // = 0

      ///
      /// GPS is present and enabled
      case enabled // = 1

      ///
      /// GPS is not present on the device
      case notPresent // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .disabled
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .disabled
        case 1: self = .enabled
        case 2: self = .notPresent
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .disabled: return 0
        case .enabled: return 1
        case .notPresent: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.PositionConfig.GpsMode] = [
        .disabled,
        .enabled,
        .notPresent,
      ]

    }

    public init() {}
  }

  ///
  /// Power Config\
  /// See [Power Config](/docs/settings/config/power) for additional power config details.
  public struct PowerConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio. 
    /// Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
    /// Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
    public var isPowerSaving: Bool = false

    ///
    ///  Description: If non-zero, the device will fully power off this many seconds after external power is removed.
    public var onBatteryShutdownAfterSecs: UInt32 = 0

    ///
    /// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
    /// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
    /// https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
    /// Should be set to floating point value between 2 and 6
    public var adcMultiplierOverride: Float = 0

    ///
    ///  Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
    ///  Technical Details: ESP32 Only 0 for default of 1 minute
    public var waitBluetoothSecs: UInt32 = 0

    ///
    /// Super Deep Sleep Seconds
    /// While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
    /// for this value (default 1 year) or a button press
    /// 0 for default of one year
    public var sdsSecs: UInt32 = 0

    ///
    /// Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
    /// Technical Details: ESP32 Only 0 for default of 300
    public var lsSecs: UInt32 = 0

    ///
    /// Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
    /// Technical Details: ESP32 Only 0 for default of 10 seconds
    public var minWakeSecs: UInt32 = 0

    ///
    /// I2C address of INA_2XX to use for reading device battery voltage
    public var deviceBatteryInaAddress: UInt32 = 0

    ///
    /// If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
    /// Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
    public var powermonEnables: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Network Config
  public struct NetworkConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable WiFi (disables Bluetooth)
    public var wifiEnabled: Bool = false

    ///
    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    public var wifiSsid: String = String()

    ///
    /// If set, will be use to authenticate to the named wifi
    public var wifiPsk: String = String()

    ///
    /// NTP server to use if WiFi is conneced, defaults to `0.pool.ntp.org`
    public var ntpServer: String = String()

    ///
    /// Enable Ethernet
    public var ethEnabled: Bool = false

    ///
    /// acquire an address via DHCP or assign static
    public var addressMode: Config.NetworkConfig.AddressMode = .dhcp

    ///
    /// struct to keep static address
    public var ipv4Config: Config.NetworkConfig.IpV4Config {
      get {return _ipv4Config ?? Config.NetworkConfig.IpV4Config()}
      set {_ipv4Config = newValue}
    }
    /// Returns true if `ipv4Config` has been explicitly set.
    public var hasIpv4Config: Bool {return self._ipv4Config != nil}
    /// Clears the value of `ipv4Config`. Subsequent reads from it will return its default value.
    public mutating func clearIpv4Config() {self._ipv4Config = nil}

    ///
    /// rsyslog Server and Port
    public var rsyslogServer: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum AddressMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// obtain ip address via DHCP
      case dhcp // = 0

      ///
      /// use static ip address
      case `static` // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .dhcp
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dhcp
        case 1: self = .static
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .dhcp: return 0
        case .static: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.NetworkConfig.AddressMode] = [
        .dhcp,
        .static,
      ]

    }

    public struct IpV4Config: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///
      /// Static IP address
      public var ip: UInt32 = 0

      ///
      /// Static gateway address
      public var gateway: UInt32 = 0

      ///
      /// Static subnet mask
      public var subnet: UInt32 = 0

      ///
      /// Static DNS server address
      public var dns: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _ipv4Config: Config.NetworkConfig.IpV4Config? = nil
  }

  ///
  /// Display Config
  public struct DisplayConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Number of seconds the screen stays on after pressing the user button or receiving a message
    /// 0 for default of one minute MAXUINT for always on
    public var screenOnSecs: UInt32 = 0

    ///
    /// How the GPS coordinates are formatted on the OLED screen.
    public var gpsFormat: Config.DisplayConfig.GpsCoordinateFormat = .dec

    ///
    /// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
    /// Potentially useful for devices without user buttons.
    public var autoScreenCarouselSecs: UInt32 = 0

    ///
    /// If this is set, the displayed compass will always point north. if unset, the old behaviour
    /// (top of display is heading direction) is used.
    public var compassNorthTop: Bool = false

    ///
    /// Flip screen vertically, for cases that mount the screen upside down
    public var flipScreen: Bool = false

    ///
    /// Perferred display units
    public var units: Config.DisplayConfig.DisplayUnits = .metric

    ///
    /// Override auto-detect in screen
    public var oled: Config.DisplayConfig.OledType = .oledAuto

    ///
    /// Display Mode
    public var displaymode: Config.DisplayConfig.DisplayMode = .default

    ///
    /// Print first line in pseudo-bold? FALSE is original style, TRUE is bold
    public var headingBold: Bool = false

    ///
    /// Should we wake the screen up on accelerometer detected motion or tap
    public var wakeOnTapOrMotion: Bool = false

    ///
    /// Indicates how to rotate or invert the compass output to accurate display on the display.
    public var compassOrientation: Config.DisplayConfig.CompassOrientation = .degrees0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// How the GPS coordinates are displayed on the OLED screen.
    public enum GpsCoordinateFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// GPS coordinates are displayed in the normal decimal degrees format:
      /// DD.DDDDDD DDD.DDDDDD
      case dec // = 0

      ///
      /// GPS coordinates are displayed in the degrees minutes seconds format:
      /// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
      case dms // = 1

      ///
      /// Universal Transverse Mercator format:
      /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
      case utm // = 2

      ///
      /// Military Grid Reference System format:
      /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
      /// E is easting, N is northing
      case mgrs // = 3

      ///
      /// Open Location Code (aka Plus Codes).
      case olc // = 4

      ///
      /// Ordnance Survey Grid Reference (the National Grid System of the UK).
      /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
      /// E is the easting, N is the northing
      case osgr // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .dec
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dec
        case 1: self = .dms
        case 2: self = .utm
        case 3: self = .mgrs
        case 4: self = .olc
        case 5: self = .osgr
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .dec: return 0
        case .dms: return 1
        case .utm: return 2
        case .mgrs: return 3
        case .olc: return 4
        case .osgr: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DisplayConfig.GpsCoordinateFormat] = [
        .dec,
        .dms,
        .utm,
        .mgrs,
        .olc,
        .osgr,
      ]

    }

    ///
    /// Unit display preference
    public enum DisplayUnits: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Metric (Default)
      case metric // = 0

      ///
      /// Imperial
      case imperial // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .metric
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .metric
        case 1: self = .imperial
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .metric: return 0
        case .imperial: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DisplayConfig.DisplayUnits] = [
        .metric,
        .imperial,
      ]

    }

    ///
    /// Override OLED outo detect with this if it fails.
    public enum OledType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Default / Auto
      case oledAuto // = 0

      ///
      /// Default / Auto
      case oledSsd1306 // = 1

      ///
      /// Default / Auto
      case oledSh1106 // = 2

      ///
      /// Can not be auto detected but set by proto. Used for 128x128 screens
      case oledSh1107 // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .oledAuto
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .oledAuto
        case 1: self = .oledSsd1306
        case 2: self = .oledSh1106
        case 3: self = .oledSh1107
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .oledAuto: return 0
        case .oledSsd1306: return 1
        case .oledSh1106: return 2
        case .oledSh1107: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DisplayConfig.OledType] = [
        .oledAuto,
        .oledSsd1306,
        .oledSh1106,
        .oledSh1107,
      ]

    }

    public enum DisplayMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Default. The old style for the 128x64 OLED screen
      case `default` // = 0

      ///
      /// Rearrange display elements to cater for bicolor OLED displays
      case twocolor // = 1

      ///
      /// Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
      case inverted // = 2

      ///
      /// TFT Full Color Displays (not implemented yet)
      case color // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .twocolor
        case 2: self = .inverted
        case 3: self = .color
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .twocolor: return 1
        case .inverted: return 2
        case .color: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DisplayConfig.DisplayMode] = [
        .default,
        .twocolor,
        .inverted,
        .color,
      ]

    }

    public enum CompassOrientation: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// The compass and the display are in the same orientation.
      case degrees0 // = 0

      ///
      /// Rotate the compass by 90 degrees.
      case degrees90 // = 1

      ///
      /// Rotate the compass by 180 degrees.
      case degrees180 // = 2

      ///
      /// Rotate the compass by 270 degrees.
      case degrees270 // = 3

      ///
      /// Don't rotate the compass, but invert the result.
      case degrees0Inverted // = 4

      ///
      /// Rotate the compass by 90 degrees and invert.
      case degrees90Inverted // = 5

      ///
      /// Rotate the compass by 180 degrees and invert.
      case degrees180Inverted // = 6

      ///
      /// Rotate the compass by 270 degrees and invert.
      case degrees270Inverted // = 7
      case UNRECOGNIZED(Int)

      public init() {
        self = .degrees0
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .degrees0
        case 1: self = .degrees90
        case 2: self = .degrees180
        case 3: self = .degrees270
        case 4: self = .degrees0Inverted
        case 5: self = .degrees90Inverted
        case 6: self = .degrees180Inverted
        case 7: self = .degrees270Inverted
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .degrees0: return 0
        case .degrees90: return 1
        case .degrees180: return 2
        case .degrees270: return 3
        case .degrees0Inverted: return 4
        case .degrees90Inverted: return 5
        case .degrees180Inverted: return 6
        case .degrees270Inverted: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.DisplayConfig.CompassOrientation] = [
        .degrees0,
        .degrees90,
        .degrees180,
        .degrees270,
        .degrees0Inverted,
        .degrees90Inverted,
        .degrees180Inverted,
        .degrees270Inverted,
      ]

    }

    public init() {}
  }

  ///
  /// Lora Config
  public struct LoRaConfig: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
    /// will be taked from their respective manually defined fields
    public var usePreset: Bool {
      get {return _storage._usePreset}
      set {_uniqueStorage()._usePreset = newValue}
    }

    ///
    /// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
    /// As a heuristic: If bandwidth is specified, do not use modem_config.
    /// Because protobufs take ZERO space when the value is zero this works out nicely.
    /// This value is replaced by bandwidth/spread_factor/coding_rate.
    /// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
    public var modemPreset: Config.LoRaConfig.ModemPreset {
      get {return _storage._modemPreset}
      set {_uniqueStorage()._modemPreset = newValue}
    }

    ///
    /// Bandwidth in MHz
    /// Certain bandwidth numbers are 'special' and will be converted to the
    /// appropriate floating point value: 31 -> 31.25MHz
    public var bandwidth: UInt32 {
      get {return _storage._bandwidth}
      set {_uniqueStorage()._bandwidth = newValue}
    }

    ///
    /// A number from 7 to 12.
    /// Indicates number of chirps per symbol as 1<<spread_factor.
    public var spreadFactor: UInt32 {
      get {return _storage._spreadFactor}
      set {_uniqueStorage()._spreadFactor = newValue}
    }

    ///
    /// The denominator of the coding rate.
    /// ie for 4/5, the value is 5. 4/8 the value is 8.
    public var codingRate: UInt32 {
      get {return _storage._codingRate}
      set {_uniqueStorage()._codingRate = newValue}
    }

    ///
    /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
    /// A frequency offset that is added to to the calculated band center frequency.
    /// Used to correct for crystal calibration errors.
    public var frequencyOffset: Float {
      get {return _storage._frequencyOffset}
      set {_uniqueStorage()._frequencyOffset = newValue}
    }

    ///
    /// The region code for the radio (US, CN, EU433, etc...)
    public var region: Config.LoRaConfig.RegionCode {
      get {return _storage._region}
      set {_uniqueStorage()._region = newValue}
    }

    ///
    /// Maximum number of hops. This can't be greater than 7.
    /// Default of 3
    /// Attempting to set a value > 7 results in the default
    public var hopLimit: UInt32 {
      get {return _storage._hopLimit}
      set {_uniqueStorage()._hopLimit = newValue}
    }

    ///
    /// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
    /// Defaults to false
    public var txEnabled: Bool {
      get {return _storage._txEnabled}
      set {_uniqueStorage()._txEnabled = newValue}
    }

    ///
    /// If zero, then use default max legal continuous power (ie. something that won't
    /// burn out the radio hardware)
    /// In most cases you should use zero here.
    /// Units are in dBm.
    public var txPower: Int32 {
      get {return _storage._txPower}
      set {_uniqueStorage()._txPower = newValue}
    }

    ///
    /// This controls the actual hardware frequency the radio transmits on.
    /// Most users should never need to be exposed to this field/concept.
    /// A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
    /// If ZERO then the rule is "use the old channel name hash based
    /// algorithm to derive the channel number")
    /// If using the hash algorithm the channel number will be: hash(channel_name) %
    /// NUM_CHANNELS (Where num channels depends on the regulatory region).
    public var channelNum: UInt32 {
      get {return _storage._channelNum}
      set {_uniqueStorage()._channelNum = newValue}
    }

    ///
    /// If true, duty cycle limits will be exceeded and thus you're possibly not following
    /// the local regulations if you're not a HAM.
    /// Has no effect if the duty cycle of the used region is 100%.
    public var overrideDutyCycle: Bool {
      get {return _storage._overrideDutyCycle}
      set {_uniqueStorage()._overrideDutyCycle = newValue}
    }

    ///
    /// If true, sets RX boosted gain mode on SX126X based radios
    public var sx126XRxBoostedGain: Bool {
      get {return _storage._sx126XRxBoostedGain}
      set {_uniqueStorage()._sx126XRxBoostedGain = newValue}
    }

    ///
    /// This parameter is for advanced users and licensed HAM radio operators.
    /// Ignore Channel Calculation and use this frequency instead. The frequency_offset
    /// will still be applied. This will allow you to use out-of-band frequencies.
    /// Please respect your local laws and regulations. If you are a HAM, make sure you
    /// enable HAM mode and turn off encryption.
    public var overrideFrequency: Float {
      get {return _storage._overrideFrequency}
      set {_uniqueStorage()._overrideFrequency = newValue}
    }

    ///
    /// If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
    public var paFanDisabled: Bool {
      get {return _storage._paFanDisabled}
      set {_uniqueStorage()._paFanDisabled = newValue}
    }

    ///
    /// For testing it is useful sometimes to force a node to never listen to
    /// particular other nodes (simulating radio out of range). All nodenums listed
    /// in ignore_incoming will have packets they send dropped on receive (by router.cpp)
    public var ignoreIncoming: [UInt32] {
      get {return _storage._ignoreIncoming}
      set {_uniqueStorage()._ignoreIncoming = newValue}
    }

    ///
    /// If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
    public var ignoreMqtt: Bool {
      get {return _storage._ignoreMqtt}
      set {_uniqueStorage()._ignoreMqtt = newValue}
    }

    ///
    /// Sets the ok_to_mqtt bit on outgoing packets
    public var configOkToMqtt: Bool {
      get {return _storage._configOkToMqtt}
      set {_uniqueStorage()._configOkToMqtt = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum RegionCode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Region is not set
      case unset // = 0

      ///
      /// United States
      case us // = 1

      ///
      /// European Union 433mhz
      case eu433 // = 2

      ///
      /// European Union 868mhz
      case eu868 // = 3

      ///
      /// China
      case cn // = 4

      ///
      /// Japan
      case jp // = 5

      ///
      /// Australia / New Zealand
      case anz // = 6

      ///
      /// Korea
      case kr // = 7

      ///
      /// Taiwan
      case tw // = 8

      ///
      /// Russia
      case ru // = 9

      ///
      /// India
      case `in` // = 10

      ///
      /// New Zealand 865mhz
      case nz865 // = 11

      ///
      /// Thailand
      case th // = 12

      ///
      /// WLAN Band
      case lora24 // = 13

      ///
      /// Ukraine 433mhz
      case ua433 // = 14

      ///
      /// Ukraine 868mhz
      case ua868 // = 15

      ///
      /// Malaysia 433mhz
      case my433 // = 16

      ///
      /// Malaysia 919mhz
      case my919 // = 17

      ///
      /// Singapore 923mhz
      case sg923 // = 18

      ///
      /// Philippines 433mhz
      case ph433 // = 19

      ///
      /// Philippines 868mhz
      case ph868 // = 20

      ///
      /// Philippines 915mhz
      case ph915 // = 21
      case UNRECOGNIZED(Int)

      public init() {
        self = .unset
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .us
        case 2: self = .eu433
        case 3: self = .eu868
        case 4: self = .cn
        case 5: self = .jp
        case 6: self = .anz
        case 7: self = .kr
        case 8: self = .tw
        case 9: self = .ru
        case 10: self = .in
        case 11: self = .nz865
        case 12: self = .th
        case 13: self = .lora24
        case 14: self = .ua433
        case 15: self = .ua868
        case 16: self = .my433
        case 17: self = .my919
        case 18: self = .sg923
        case 19: self = .ph433
        case 20: self = .ph868
        case 21: self = .ph915
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unset: return 0
        case .us: return 1
        case .eu433: return 2
        case .eu868: return 3
        case .cn: return 4
        case .jp: return 5
        case .anz: return 6
        case .kr: return 7
        case .tw: return 8
        case .ru: return 9
        case .in: return 10
        case .nz865: return 11
        case .th: return 12
        case .lora24: return 13
        case .ua433: return 14
        case .ua868: return 15
        case .my433: return 16
        case .my919: return 17
        case .sg923: return 18
        case .ph433: return 19
        case .ph868: return 20
        case .ph915: return 21
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.LoRaConfig.RegionCode] = [
        .unset,
        .us,
        .eu433,
        .eu868,
        .cn,
        .jp,
        .anz,
        .kr,
        .tw,
        .ru,
        .in,
        .nz865,
        .th,
        .lora24,
        .ua433,
        .ua868,
        .my433,
        .my919,
        .sg923,
        .ph433,
        .ph868,
        .ph915,
      ]

    }

    ///
    /// Standard predefined channel settings
    /// Note: these mappings must match ModemPreset Choice in the device code.
    public enum ModemPreset: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Long Range - Fast
      case longFast // = 0

      ///
      /// Long Range - Slow
      case longSlow // = 1

      ///
      /// Very Long Range - Slow
      /// Deprecated in 2.5: Works only with txco and is unusably slow
      ///
      /// NOTE: This enum value was marked as deprecated in the .proto file
      case veryLongSlow // = 2

      ///
      /// Medium Range - Slow
      case mediumSlow // = 3

      ///
      /// Medium Range - Fast
      case mediumFast // = 4

      ///
      /// Short Range - Slow
      case shortSlow // = 5

      ///
      /// Short Range - Fast
      case shortFast // = 6

      ///
      /// Long Range - Moderately Fast
      case longModerate // = 7

      ///
      /// Short Range - Turbo
      /// This is the fastest preset and the only one with 500kHz bandwidth.
      /// It is not legal to use in all regions due to this wider bandwidth.
      case shortTurbo // = 8
      case UNRECOGNIZED(Int)

      public init() {
        self = .longFast
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .longFast
        case 1: self = .longSlow
        case 2: self = .veryLongSlow
        case 3: self = .mediumSlow
        case 4: self = .mediumFast
        case 5: self = .shortSlow
        case 6: self = .shortFast
        case 7: self = .longModerate
        case 8: self = .shortTurbo
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .longFast: return 0
        case .longSlow: return 1
        case .veryLongSlow: return 2
        case .mediumSlow: return 3
        case .mediumFast: return 4
        case .shortSlow: return 5
        case .shortFast: return 6
        case .longModerate: return 7
        case .shortTurbo: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.LoRaConfig.ModemPreset] = [
        .longFast,
        .longSlow,
        .veryLongSlow,
        .mediumSlow,
        .mediumFast,
        .shortSlow,
        .shortFast,
        .longModerate,
        .shortTurbo,
      ]

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct BluetoothConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Enable Bluetooth on the device
    public var enabled: Bool = false

    ///
    /// Determines the pairing strategy for the device
    public var mode: Config.BluetoothConfig.PairingMode = .randomPin

    ///
    /// Specified PIN for PairingMode.FixedPin
    public var fixedPin: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum PairingMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      ///
      /// Device generates a random PIN that will be shown on the screen of the device for pairing
      case randomPin // = 0

      ///
      /// Device requires a specified fixed PIN for pairing
      case fixedPin // = 1

      ///
      /// Device requires no PIN for pairing
      case noPin // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .randomPin
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .randomPin
        case 1: self = .fixedPin
        case 2: self = .noPin
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .randomPin: return 0
        case .fixedPin: return 1
        case .noPin: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Config.BluetoothConfig.PairingMode] = [
        .randomPin,
        .fixedPin,
        .noPin,
      ]

    }

    public init() {}
  }

  public struct SecurityConfig: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// The public key of the user's device.
    /// Sent out to other nodes on the mesh to allow them to compute a shared secret key.
    public var publicKey: Data = Data()

    ///
    /// The private key of the device.
    /// Used to create a shared key with a remote device.
    public var privateKey: Data = Data()

    ///
    /// The public key authorized to send admin messages to this node.
    public var adminKey: [Data] = []

    ///
    /// If true, device is considered to be "managed" by a mesh administrator via admin messages
    /// Device is managed by a mesh administrator.
    public var isManaged: Bool = false

    ///
    /// Serial Console over the Stream API."
    public var serialEnabled: Bool = false

    ///
    /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
    /// Output live debug logging over serial or bluetooth is set to true.
    public var debugLogApiEnabled: Bool = false

    ///
    /// Allow incoming device control over the insecure legacy admin channel.
    public var adminChannelEnabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  ///
  /// Blank config request, strictly for getting the session key
  public struct SessionkeyConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "position"),
    3: .same(proto: "power"),
    4: .same(proto: "network"),
    5: .same(proto: "display"),
    6: .same(proto: "lora"),
    7: .same(proto: "bluetooth"),
    8: .same(proto: "security"),
    9: .same(proto: "sessionkey"),
    10: .standard(proto: "device_ui"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Config.DeviceConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .device(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .device(v)
        }
      }()
      case 2: try {
        var v: Config.PositionConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .position(v)
        }
      }()
      case 3: try {
        var v: Config.PowerConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .power(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .power(v)
        }
      }()
      case 4: try {
        var v: Config.NetworkConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .network(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .network(v)
        }
      }()
      case 5: try {
        var v: Config.DisplayConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .display(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .display(v)
        }
      }()
      case 6: try {
        var v: Config.LoRaConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .lora(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .lora(v)
        }
      }()
      case 7: try {
        var v: Config.BluetoothConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .bluetooth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .bluetooth(v)
        }
      }()
      case 8: try {
        var v: Config.SecurityConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .security(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .security(v)
        }
      }()
      case 9: try {
        var v: Config.SessionkeyConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .sessionkey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .sessionkey(v)
        }
      }()
      case 10: try {
        var v: DeviceUIConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .deviceUi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .deviceUi(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .device?: try {
      guard case .device(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .power?: try {
      guard case .power(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .network?: try {
      guard case .network(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .display?: try {
      guard case .display(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .lora?: try {
      guard case .lora(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bluetooth?: try {
      guard case .bluetooth(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .security?: try {
      guard case .security(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sessionkey?: try {
      guard case .sessionkey(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deviceUi?: try {
      guard case .deviceUi(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config, rhs: Config) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".DeviceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .standard(proto: "serial_enabled"),
    4: .standard(proto: "button_gpio"),
    5: .standard(proto: "buzzer_gpio"),
    6: .standard(proto: "rebroadcast_mode"),
    7: .standard(proto: "node_info_broadcast_secs"),
    8: .standard(proto: "double_tap_as_button_press"),
    9: .standard(proto: "is_managed"),
    10: .standard(proto: "disable_triple_click"),
    11: .same(proto: "tzdef"),
    12: .standard(proto: "led_heartbeat_disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.serialEnabled) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.buttonGpio) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.buzzerGpio) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.rebroadcastMode) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.nodeInfoBroadcastSecs) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.doubleTapAsButtonPress) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isManaged) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.disableTripleClick) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.tzdef) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.ledHeartbeatDisabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    if self.serialEnabled != false {
      try visitor.visitSingularBoolField(value: self.serialEnabled, fieldNumber: 2)
    }
    if self.buttonGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.buttonGpio, fieldNumber: 4)
    }
    if self.buzzerGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.buzzerGpio, fieldNumber: 5)
    }
    if self.rebroadcastMode != .all {
      try visitor.visitSingularEnumField(value: self.rebroadcastMode, fieldNumber: 6)
    }
    if self.nodeInfoBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeInfoBroadcastSecs, fieldNumber: 7)
    }
    if self.doubleTapAsButtonPress != false {
      try visitor.visitSingularBoolField(value: self.doubleTapAsButtonPress, fieldNumber: 8)
    }
    if self.isManaged != false {
      try visitor.visitSingularBoolField(value: self.isManaged, fieldNumber: 9)
    }
    if self.disableTripleClick != false {
      try visitor.visitSingularBoolField(value: self.disableTripleClick, fieldNumber: 10)
    }
    if !self.tzdef.isEmpty {
      try visitor.visitSingularStringField(value: self.tzdef, fieldNumber: 11)
    }
    if self.ledHeartbeatDisabled != false {
      try visitor.visitSingularBoolField(value: self.ledHeartbeatDisabled, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.DeviceConfig, rhs: Config.DeviceConfig) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.serialEnabled != rhs.serialEnabled {return false}
    if lhs.buttonGpio != rhs.buttonGpio {return false}
    if lhs.buzzerGpio != rhs.buzzerGpio {return false}
    if lhs.rebroadcastMode != rhs.rebroadcastMode {return false}
    if lhs.nodeInfoBroadcastSecs != rhs.nodeInfoBroadcastSecs {return false}
    if lhs.doubleTapAsButtonPress != rhs.doubleTapAsButtonPress {return false}
    if lhs.isManaged != rhs.isManaged {return false}
    if lhs.disableTripleClick != rhs.disableTripleClick {return false}
    if lhs.tzdef != rhs.tzdef {return false}
    if lhs.ledHeartbeatDisabled != rhs.ledHeartbeatDisabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DeviceConfig.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT"),
    1: .same(proto: "CLIENT_MUTE"),
    2: .same(proto: "ROUTER"),
    3: .same(proto: "ROUTER_CLIENT"),
    4: .same(proto: "REPEATER"),
    5: .same(proto: "TRACKER"),
    6: .same(proto: "SENSOR"),
    7: .same(proto: "TAK"),
    8: .same(proto: "CLIENT_HIDDEN"),
    9: .same(proto: "LOST_AND_FOUND"),
    10: .same(proto: "TAK_TRACKER"),
  ]
}

extension Config.DeviceConfig.RebroadcastMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "ALL_SKIP_DECODING"),
    2: .same(proto: "LOCAL_ONLY"),
    3: .same(proto: "KNOWN_ONLY"),
    4: .same(proto: "NONE"),
    5: .same(proto: "CORE_PORTNUMS_ONLY"),
  ]
}

extension Config.PositionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".PositionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_broadcast_secs"),
    2: .standard(proto: "position_broadcast_smart_enabled"),
    3: .standard(proto: "fixed_position"),
    4: .standard(proto: "gps_enabled"),
    5: .standard(proto: "gps_update_interval"),
    6: .standard(proto: "gps_attempt_time"),
    7: .standard(proto: "position_flags"),
    8: .standard(proto: "rx_gpio"),
    9: .standard(proto: "tx_gpio"),
    10: .standard(proto: "broadcast_smart_minimum_distance"),
    11: .standard(proto: "broadcast_smart_minimum_interval_secs"),
    12: .standard(proto: "gps_en_gpio"),
    13: .standard(proto: "gps_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.positionBroadcastSecs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.positionBroadcastSmartEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fixedPosition) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.gpsEnabled) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.gpsUpdateInterval) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.gpsAttemptTime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.positionFlags) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.rxGpio) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.txGpio) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.broadcastSmartMinimumDistance) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.broadcastSmartMinimumIntervalSecs) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.gpsEnGpio) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.gpsMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positionBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionBroadcastSecs, fieldNumber: 1)
    }
    if self.positionBroadcastSmartEnabled != false {
      try visitor.visitSingularBoolField(value: self.positionBroadcastSmartEnabled, fieldNumber: 2)
    }
    if self.fixedPosition != false {
      try visitor.visitSingularBoolField(value: self.fixedPosition, fieldNumber: 3)
    }
    if self.gpsEnabled != false {
      try visitor.visitSingularBoolField(value: self.gpsEnabled, fieldNumber: 4)
    }
    if self.gpsUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsUpdateInterval, fieldNumber: 5)
    }
    if self.gpsAttemptTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsAttemptTime, fieldNumber: 6)
    }
    if self.positionFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionFlags, fieldNumber: 7)
    }
    if self.rxGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxGpio, fieldNumber: 8)
    }
    if self.txGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.txGpio, fieldNumber: 9)
    }
    if self.broadcastSmartMinimumDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastSmartMinimumDistance, fieldNumber: 10)
    }
    if self.broadcastSmartMinimumIntervalSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastSmartMinimumIntervalSecs, fieldNumber: 11)
    }
    if self.gpsEnGpio != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsEnGpio, fieldNumber: 12)
    }
    if self.gpsMode != .disabled {
      try visitor.visitSingularEnumField(value: self.gpsMode, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.PositionConfig, rhs: Config.PositionConfig) -> Bool {
    if lhs.positionBroadcastSecs != rhs.positionBroadcastSecs {return false}
    if lhs.positionBroadcastSmartEnabled != rhs.positionBroadcastSmartEnabled {return false}
    if lhs.fixedPosition != rhs.fixedPosition {return false}
    if lhs.gpsEnabled != rhs.gpsEnabled {return false}
    if lhs.gpsUpdateInterval != rhs.gpsUpdateInterval {return false}
    if lhs.gpsAttemptTime != rhs.gpsAttemptTime {return false}
    if lhs.positionFlags != rhs.positionFlags {return false}
    if lhs.rxGpio != rhs.rxGpio {return false}
    if lhs.txGpio != rhs.txGpio {return false}
    if lhs.broadcastSmartMinimumDistance != rhs.broadcastSmartMinimumDistance {return false}
    if lhs.broadcastSmartMinimumIntervalSecs != rhs.broadcastSmartMinimumIntervalSecs {return false}
    if lhs.gpsEnGpio != rhs.gpsEnGpio {return false}
    if lhs.gpsMode != rhs.gpsMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.PositionConfig.PositionFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "ALTITUDE"),
    2: .same(proto: "ALTITUDE_MSL"),
    4: .same(proto: "GEOIDAL_SEPARATION"),
    8: .same(proto: "DOP"),
    16: .same(proto: "HVDOP"),
    32: .same(proto: "SATINVIEW"),
    64: .same(proto: "SEQ_NO"),
    128: .same(proto: "TIMESTAMP"),
    256: .same(proto: "HEADING"),
    512: .same(proto: "SPEED"),
  ]
}

extension Config.PositionConfig.GpsMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "ENABLED"),
    2: .same(proto: "NOT_PRESENT"),
  ]
}

extension Config.PowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".PowerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_power_saving"),
    2: .standard(proto: "on_battery_shutdown_after_secs"),
    3: .standard(proto: "adc_multiplier_override"),
    4: .standard(proto: "wait_bluetooth_secs"),
    6: .standard(proto: "sds_secs"),
    7: .standard(proto: "ls_secs"),
    8: .standard(proto: "min_wake_secs"),
    9: .standard(proto: "device_battery_ina_address"),
    32: .standard(proto: "powermon_enables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isPowerSaving) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.onBatteryShutdownAfterSecs) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.adcMultiplierOverride) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.waitBluetoothSecs) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.sdsSecs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.lsSecs) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.minWakeSecs) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.deviceBatteryInaAddress) }()
      case 32: try { try decoder.decodeSingularUInt64Field(value: &self.powermonEnables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPowerSaving != false {
      try visitor.visitSingularBoolField(value: self.isPowerSaving, fieldNumber: 1)
    }
    if self.onBatteryShutdownAfterSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.onBatteryShutdownAfterSecs, fieldNumber: 2)
    }
    if self.adcMultiplierOverride.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.adcMultiplierOverride, fieldNumber: 3)
    }
    if self.waitBluetoothSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.waitBluetoothSecs, fieldNumber: 4)
    }
    if self.sdsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sdsSecs, fieldNumber: 6)
    }
    if self.lsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.lsSecs, fieldNumber: 7)
    }
    if self.minWakeSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minWakeSecs, fieldNumber: 8)
    }
    if self.deviceBatteryInaAddress != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceBatteryInaAddress, fieldNumber: 9)
    }
    if self.powermonEnables != 0 {
      try visitor.visitSingularUInt64Field(value: self.powermonEnables, fieldNumber: 32)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.PowerConfig, rhs: Config.PowerConfig) -> Bool {
    if lhs.isPowerSaving != rhs.isPowerSaving {return false}
    if lhs.onBatteryShutdownAfterSecs != rhs.onBatteryShutdownAfterSecs {return false}
    if lhs.adcMultiplierOverride != rhs.adcMultiplierOverride {return false}
    if lhs.waitBluetoothSecs != rhs.waitBluetoothSecs {return false}
    if lhs.sdsSecs != rhs.sdsSecs {return false}
    if lhs.lsSecs != rhs.lsSecs {return false}
    if lhs.minWakeSecs != rhs.minWakeSecs {return false}
    if lhs.deviceBatteryInaAddress != rhs.deviceBatteryInaAddress {return false}
    if lhs.powermonEnables != rhs.powermonEnables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".NetworkConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wifi_enabled"),
    3: .standard(proto: "wifi_ssid"),
    4: .standard(proto: "wifi_psk"),
    5: .standard(proto: "ntp_server"),
    6: .standard(proto: "eth_enabled"),
    7: .standard(proto: "address_mode"),
    8: .standard(proto: "ipv4_config"),
    9: .standard(proto: "rsyslog_server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wifiEnabled) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.wifiSsid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.wifiPsk) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ntpServer) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ethEnabled) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.addressMode) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ipv4Config) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.rsyslogServer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.wifiEnabled != false {
      try visitor.visitSingularBoolField(value: self.wifiEnabled, fieldNumber: 1)
    }
    if !self.wifiSsid.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiSsid, fieldNumber: 3)
    }
    if !self.wifiPsk.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiPsk, fieldNumber: 4)
    }
    if !self.ntpServer.isEmpty {
      try visitor.visitSingularStringField(value: self.ntpServer, fieldNumber: 5)
    }
    if self.ethEnabled != false {
      try visitor.visitSingularBoolField(value: self.ethEnabled, fieldNumber: 6)
    }
    if self.addressMode != .dhcp {
      try visitor.visitSingularEnumField(value: self.addressMode, fieldNumber: 7)
    }
    try { if let v = self._ipv4Config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.rsyslogServer.isEmpty {
      try visitor.visitSingularStringField(value: self.rsyslogServer, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.NetworkConfig, rhs: Config.NetworkConfig) -> Bool {
    if lhs.wifiEnabled != rhs.wifiEnabled {return false}
    if lhs.wifiSsid != rhs.wifiSsid {return false}
    if lhs.wifiPsk != rhs.wifiPsk {return false}
    if lhs.ntpServer != rhs.ntpServer {return false}
    if lhs.ethEnabled != rhs.ethEnabled {return false}
    if lhs.addressMode != rhs.addressMode {return false}
    if lhs._ipv4Config != rhs._ipv4Config {return false}
    if lhs.rsyslogServer != rhs.rsyslogServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.NetworkConfig.AddressMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DHCP"),
    1: .same(proto: "STATIC"),
  ]
}

extension Config.NetworkConfig.IpV4Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.NetworkConfig.protoMessageName + ".IpV4Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "gateway"),
    3: .same(proto: "subnet"),
    4: .same(proto: "dns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.gateway) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.subnet) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dns) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ip != 0 {
      try visitor.visitSingularFixed32Field(value: self.ip, fieldNumber: 1)
    }
    if self.gateway != 0 {
      try visitor.visitSingularFixed32Field(value: self.gateway, fieldNumber: 2)
    }
    if self.subnet != 0 {
      try visitor.visitSingularFixed32Field(value: self.subnet, fieldNumber: 3)
    }
    if self.dns != 0 {
      try visitor.visitSingularFixed32Field(value: self.dns, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.NetworkConfig.IpV4Config, rhs: Config.NetworkConfig.IpV4Config) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.dns != rhs.dns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DisplayConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".DisplayConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_on_secs"),
    2: .standard(proto: "gps_format"),
    3: .standard(proto: "auto_screen_carousel_secs"),
    4: .standard(proto: "compass_north_top"),
    5: .standard(proto: "flip_screen"),
    6: .same(proto: "units"),
    7: .same(proto: "oled"),
    8: .same(proto: "displaymode"),
    9: .standard(proto: "heading_bold"),
    10: .standard(proto: "wake_on_tap_or_motion"),
    11: .standard(proto: "compass_orientation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenOnSecs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gpsFormat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.autoScreenCarouselSecs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.compassNorthTop) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.flipScreen) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.units) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.oled) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.displaymode) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.headingBold) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.wakeOnTapOrMotion) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.compassOrientation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenOnSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenOnSecs, fieldNumber: 1)
    }
    if self.gpsFormat != .dec {
      try visitor.visitSingularEnumField(value: self.gpsFormat, fieldNumber: 2)
    }
    if self.autoScreenCarouselSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.autoScreenCarouselSecs, fieldNumber: 3)
    }
    if self.compassNorthTop != false {
      try visitor.visitSingularBoolField(value: self.compassNorthTop, fieldNumber: 4)
    }
    if self.flipScreen != false {
      try visitor.visitSingularBoolField(value: self.flipScreen, fieldNumber: 5)
    }
    if self.units != .metric {
      try visitor.visitSingularEnumField(value: self.units, fieldNumber: 6)
    }
    if self.oled != .oledAuto {
      try visitor.visitSingularEnumField(value: self.oled, fieldNumber: 7)
    }
    if self.displaymode != .default {
      try visitor.visitSingularEnumField(value: self.displaymode, fieldNumber: 8)
    }
    if self.headingBold != false {
      try visitor.visitSingularBoolField(value: self.headingBold, fieldNumber: 9)
    }
    if self.wakeOnTapOrMotion != false {
      try visitor.visitSingularBoolField(value: self.wakeOnTapOrMotion, fieldNumber: 10)
    }
    if self.compassOrientation != .degrees0 {
      try visitor.visitSingularEnumField(value: self.compassOrientation, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.DisplayConfig, rhs: Config.DisplayConfig) -> Bool {
    if lhs.screenOnSecs != rhs.screenOnSecs {return false}
    if lhs.gpsFormat != rhs.gpsFormat {return false}
    if lhs.autoScreenCarouselSecs != rhs.autoScreenCarouselSecs {return false}
    if lhs.compassNorthTop != rhs.compassNorthTop {return false}
    if lhs.flipScreen != rhs.flipScreen {return false}
    if lhs.units != rhs.units {return false}
    if lhs.oled != rhs.oled {return false}
    if lhs.displaymode != rhs.displaymode {return false}
    if lhs.headingBold != rhs.headingBold {return false}
    if lhs.wakeOnTapOrMotion != rhs.wakeOnTapOrMotion {return false}
    if lhs.compassOrientation != rhs.compassOrientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DisplayConfig.GpsCoordinateFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEC"),
    1: .same(proto: "DMS"),
    2: .same(proto: "UTM"),
    3: .same(proto: "MGRS"),
    4: .same(proto: "OLC"),
    5: .same(proto: "OSGR"),
  ]
}

extension Config.DisplayConfig.DisplayUnits: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METRIC"),
    1: .same(proto: "IMPERIAL"),
  ]
}

extension Config.DisplayConfig.OledType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OLED_AUTO"),
    1: .same(proto: "OLED_SSD1306"),
    2: .same(proto: "OLED_SH1106"),
    3: .same(proto: "OLED_SH1107"),
  ]
}

extension Config.DisplayConfig.DisplayMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "TWOCOLOR"),
    2: .same(proto: "INVERTED"),
    3: .same(proto: "COLOR"),
  ]
}

extension Config.DisplayConfig.CompassOrientation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEGREES_0"),
    1: .same(proto: "DEGREES_90"),
    2: .same(proto: "DEGREES_180"),
    3: .same(proto: "DEGREES_270"),
    4: .same(proto: "DEGREES_0_INVERTED"),
    5: .same(proto: "DEGREES_90_INVERTED"),
    6: .same(proto: "DEGREES_180_INVERTED"),
    7: .same(proto: "DEGREES_270_INVERTED"),
  ]
}

extension Config.LoRaConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".LoRaConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_preset"),
    2: .standard(proto: "modem_preset"),
    3: .same(proto: "bandwidth"),
    4: .standard(proto: "spread_factor"),
    5: .standard(proto: "coding_rate"),
    6: .standard(proto: "frequency_offset"),
    7: .same(proto: "region"),
    8: .standard(proto: "hop_limit"),
    9: .standard(proto: "tx_enabled"),
    10: .standard(proto: "tx_power"),
    11: .standard(proto: "channel_num"),
    12: .standard(proto: "override_duty_cycle"),
    13: .standard(proto: "sx126x_rx_boosted_gain"),
    14: .standard(proto: "override_frequency"),
    15: .standard(proto: "pa_fan_disabled"),
    103: .standard(proto: "ignore_incoming"),
    104: .standard(proto: "ignore_mqtt"),
    105: .standard(proto: "config_ok_to_mqtt"),
  ]

  fileprivate class _StorageClass {
    var _usePreset: Bool = false
    var _modemPreset: Config.LoRaConfig.ModemPreset = .longFast
    var _bandwidth: UInt32 = 0
    var _spreadFactor: UInt32 = 0
    var _codingRate: UInt32 = 0
    var _frequencyOffset: Float = 0
    var _region: Config.LoRaConfig.RegionCode = .unset
    var _hopLimit: UInt32 = 0
    var _txEnabled: Bool = false
    var _txPower: Int32 = 0
    var _channelNum: UInt32 = 0
    var _overrideDutyCycle: Bool = false
    var _sx126XRxBoostedGain: Bool = false
    var _overrideFrequency: Float = 0
    var _paFanDisabled: Bool = false
    var _ignoreIncoming: [UInt32] = []
    var _ignoreMqtt: Bool = false
    var _configOkToMqtt: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _usePreset = source._usePreset
      _modemPreset = source._modemPreset
      _bandwidth = source._bandwidth
      _spreadFactor = source._spreadFactor
      _codingRate = source._codingRate
      _frequencyOffset = source._frequencyOffset
      _region = source._region
      _hopLimit = source._hopLimit
      _txEnabled = source._txEnabled
      _txPower = source._txPower
      _channelNum = source._channelNum
      _overrideDutyCycle = source._overrideDutyCycle
      _sx126XRxBoostedGain = source._sx126XRxBoostedGain
      _overrideFrequency = source._overrideFrequency
      _paFanDisabled = source._paFanDisabled
      _ignoreIncoming = source._ignoreIncoming
      _ignoreMqtt = source._ignoreMqtt
      _configOkToMqtt = source._configOkToMqtt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._usePreset) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._modemPreset) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._bandwidth) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._spreadFactor) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._codingRate) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._frequencyOffset) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._region) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._txEnabled) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._txPower) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._channelNum) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._overrideDutyCycle) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._sx126XRxBoostedGain) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._overrideFrequency) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._paFanDisabled) }()
        case 103: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._ignoreIncoming) }()
        case 104: try { try decoder.decodeSingularBoolField(value: &_storage._ignoreMqtt) }()
        case 105: try { try decoder.decodeSingularBoolField(value: &_storage._configOkToMqtt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._usePreset != false {
        try visitor.visitSingularBoolField(value: _storage._usePreset, fieldNumber: 1)
      }
      if _storage._modemPreset != .longFast {
        try visitor.visitSingularEnumField(value: _storage._modemPreset, fieldNumber: 2)
      }
      if _storage._bandwidth != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bandwidth, fieldNumber: 3)
      }
      if _storage._spreadFactor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._spreadFactor, fieldNumber: 4)
      }
      if _storage._codingRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._codingRate, fieldNumber: 5)
      }
      if _storage._frequencyOffset.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._frequencyOffset, fieldNumber: 6)
      }
      if _storage._region != .unset {
        try visitor.visitSingularEnumField(value: _storage._region, fieldNumber: 7)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 8)
      }
      if _storage._txEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._txEnabled, fieldNumber: 9)
      }
      if _storage._txPower != 0 {
        try visitor.visitSingularInt32Field(value: _storage._txPower, fieldNumber: 10)
      }
      if _storage._channelNum != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channelNum, fieldNumber: 11)
      }
      if _storage._overrideDutyCycle != false {
        try visitor.visitSingularBoolField(value: _storage._overrideDutyCycle, fieldNumber: 12)
      }
      if _storage._sx126XRxBoostedGain != false {
        try visitor.visitSingularBoolField(value: _storage._sx126XRxBoostedGain, fieldNumber: 13)
      }
      if _storage._overrideFrequency.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._overrideFrequency, fieldNumber: 14)
      }
      if _storage._paFanDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._paFanDisabled, fieldNumber: 15)
      }
      if !_storage._ignoreIncoming.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._ignoreIncoming, fieldNumber: 103)
      }
      if _storage._ignoreMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._ignoreMqtt, fieldNumber: 104)
      }
      if _storage._configOkToMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._configOkToMqtt, fieldNumber: 105)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.LoRaConfig, rhs: Config.LoRaConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._usePreset != rhs_storage._usePreset {return false}
        if _storage._modemPreset != rhs_storage._modemPreset {return false}
        if _storage._bandwidth != rhs_storage._bandwidth {return false}
        if _storage._spreadFactor != rhs_storage._spreadFactor {return false}
        if _storage._codingRate != rhs_storage._codingRate {return false}
        if _storage._frequencyOffset != rhs_storage._frequencyOffset {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._txEnabled != rhs_storage._txEnabled {return false}
        if _storage._txPower != rhs_storage._txPower {return false}
        if _storage._channelNum != rhs_storage._channelNum {return false}
        if _storage._overrideDutyCycle != rhs_storage._overrideDutyCycle {return false}
        if _storage._sx126XRxBoostedGain != rhs_storage._sx126XRxBoostedGain {return false}
        if _storage._overrideFrequency != rhs_storage._overrideFrequency {return false}
        if _storage._paFanDisabled != rhs_storage._paFanDisabled {return false}
        if _storage._ignoreIncoming != rhs_storage._ignoreIncoming {return false}
        if _storage._ignoreMqtt != rhs_storage._ignoreMqtt {return false}
        if _storage._configOkToMqtt != rhs_storage._configOkToMqtt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.LoRaConfig.RegionCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "US"),
    2: .same(proto: "EU_433"),
    3: .same(proto: "EU_868"),
    4: .same(proto: "CN"),
    5: .same(proto: "JP"),
    6: .same(proto: "ANZ"),
    7: .same(proto: "KR"),
    8: .same(proto: "TW"),
    9: .same(proto: "RU"),
    10: .same(proto: "IN"),
    11: .same(proto: "NZ_865"),
    12: .same(proto: "TH"),
    13: .same(proto: "LORA_24"),
    14: .same(proto: "UA_433"),
    15: .same(proto: "UA_868"),
    16: .same(proto: "MY_433"),
    17: .same(proto: "MY_919"),
    18: .same(proto: "SG_923"),
    19: .same(proto: "PH_433"),
    20: .same(proto: "PH_868"),
    21: .same(proto: "PH_915"),
  ]
}

extension Config.LoRaConfig.ModemPreset: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LONG_FAST"),
    1: .same(proto: "LONG_SLOW"),
    2: .same(proto: "VERY_LONG_SLOW"),
    3: .same(proto: "MEDIUM_SLOW"),
    4: .same(proto: "MEDIUM_FAST"),
    5: .same(proto: "SHORT_SLOW"),
    6: .same(proto: "SHORT_FAST"),
    7: .same(proto: "LONG_MODERATE"),
    8: .same(proto: "SHORT_TURBO"),
  ]
}

extension Config.BluetoothConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".BluetoothConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "mode"),
    3: .standard(proto: "fixed_pin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fixedPin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.mode != .randomPin {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    if self.fixedPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.fixedPin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.BluetoothConfig, rhs: Config.BluetoothConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.fixedPin != rhs.fixedPin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.BluetoothConfig.PairingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANDOM_PIN"),
    1: .same(proto: "FIXED_PIN"),
    2: .same(proto: "NO_PIN"),
  ]
}

extension Config.SecurityConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".SecurityConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "private_key"),
    3: .standard(proto: "admin_key"),
    4: .standard(proto: "is_managed"),
    5: .standard(proto: "serial_enabled"),
    6: .standard(proto: "debug_log_api_enabled"),
    8: .standard(proto: "admin_channel_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.adminKey) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isManaged) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.serialEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.debugLogApiEnabled) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.adminChannelEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    if !self.adminKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.adminKey, fieldNumber: 3)
    }
    if self.isManaged != false {
      try visitor.visitSingularBoolField(value: self.isManaged, fieldNumber: 4)
    }
    if self.serialEnabled != false {
      try visitor.visitSingularBoolField(value: self.serialEnabled, fieldNumber: 5)
    }
    if self.debugLogApiEnabled != false {
      try visitor.visitSingularBoolField(value: self.debugLogApiEnabled, fieldNumber: 6)
    }
    if self.adminChannelEnabled != false {
      try visitor.visitSingularBoolField(value: self.adminChannelEnabled, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.SecurityConfig, rhs: Config.SecurityConfig) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.adminKey != rhs.adminKey {return false}
    if lhs.isManaged != rhs.isManaged {return false}
    if lhs.serialEnabled != rhs.serialEnabled {return false}
    if lhs.debugLogApiEnabled != rhs.debugLogApiEnabled {return false}
    if lhs.adminChannelEnabled != rhs.adminChannelEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.SessionkeyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Config.protoMessageName + ".SessionkeyConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Config.SessionkeyConfig, rhs: Config.SessionkeyConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
