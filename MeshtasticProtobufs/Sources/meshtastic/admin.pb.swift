// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meshtastic/admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// This message is handled by the Admin module and is responsible for all settings/channel read/write operations.
/// This message is used to do settings operations to both remote AND local nodes.
/// (Prior to 1.2 these operations were done via special ToRadio operations)
public struct AdminMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The node generates this key and sends it with any get_x_response packets.
  /// The client MUST include the same key with any set_x commands. Key expires after 300 seconds.
  /// Prevents replay attacks for admin messages.
  public var sessionPasskey: Data = Data()

  ///
  /// TODO: REPLACE
  public var payloadVariant: AdminMessage.OneOf_PayloadVariant? = nil

  ///
  /// Send the specified channel in the response to this message
  /// NOTE: This field is sent with the channel index + 1 (to ensure we never try to send 'zero' - which protobufs treats as not present)
  public var getChannelRequest: UInt32 {
    get {
      if case .getChannelRequest(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .getChannelRequest(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var getChannelResponse: Channel {
    get {
      if case .getChannelResponse(let v)? = payloadVariant {return v}
      return Channel()
    }
    set {payloadVariant = .getChannelResponse(newValue)}
  }

  ///
  /// Send the current owner data in the response to this message.
  public var getOwnerRequest: Bool {
    get {
      if case .getOwnerRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getOwnerRequest(newValue)}
  }

  ///
  /// TODO: REPLACE
  public var getOwnerResponse: User {
    get {
      if case .getOwnerResponse(let v)? = payloadVariant {return v}
      return User()
    }
    set {payloadVariant = .getOwnerResponse(newValue)}
  }

  ///
  /// Ask for the following config data to be sent
  public var getConfigRequest: AdminMessage.ConfigType {
    get {
      if case .getConfigRequest(let v)? = payloadVariant {return v}
      return .deviceConfig
    }
    set {payloadVariant = .getConfigRequest(newValue)}
  }

  ///
  /// Send the current Config in the response to this message.
  public var getConfigResponse: Config {
    get {
      if case .getConfigResponse(let v)? = payloadVariant {return v}
      return Config()
    }
    set {payloadVariant = .getConfigResponse(newValue)}
  }

  ///
  /// Ask for the following config data to be sent
  public var getModuleConfigRequest: AdminMessage.ModuleConfigType {
    get {
      if case .getModuleConfigRequest(let v)? = payloadVariant {return v}
      return .mqttConfig
    }
    set {payloadVariant = .getModuleConfigRequest(newValue)}
  }

  ///
  /// Send the current Config in the response to this message.
  public var getModuleConfigResponse: ModuleConfig {
    get {
      if case .getModuleConfigResponse(let v)? = payloadVariant {return v}
      return ModuleConfig()
    }
    set {payloadVariant = .getModuleConfigResponse(newValue)}
  }

  ///
  /// Get the Canned Message Module messages in the response to this message.
  public var getCannedMessageModuleMessagesRequest: Bool {
    get {
      if case .getCannedMessageModuleMessagesRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getCannedMessageModuleMessagesRequest(newValue)}
  }

  ///
  /// Get the Canned Message Module messages in the response to this message.
  public var getCannedMessageModuleMessagesResponse: String {
    get {
      if case .getCannedMessageModuleMessagesResponse(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .getCannedMessageModuleMessagesResponse(newValue)}
  }

  ///
  /// Request the node to send device metadata (firmware, protobuf version, etc)
  public var getDeviceMetadataRequest: Bool {
    get {
      if case .getDeviceMetadataRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getDeviceMetadataRequest(newValue)}
  }

  ///
  /// Device metadata response
  public var getDeviceMetadataResponse: DeviceMetadata {
    get {
      if case .getDeviceMetadataResponse(let v)? = payloadVariant {return v}
      return DeviceMetadata()
    }
    set {payloadVariant = .getDeviceMetadataResponse(newValue)}
  }

  ///
  /// Get the Ringtone in the response to this message.
  public var getRingtoneRequest: Bool {
    get {
      if case .getRingtoneRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getRingtoneRequest(newValue)}
  }

  ///
  /// Get the Ringtone in the response to this message.
  public var getRingtoneResponse: String {
    get {
      if case .getRingtoneResponse(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .getRingtoneResponse(newValue)}
  }

  ///
  /// Request the node to send it's connection status
  public var getDeviceConnectionStatusRequest: Bool {
    get {
      if case .getDeviceConnectionStatusRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getDeviceConnectionStatusRequest(newValue)}
  }

  ///
  /// Device connection status response
  public var getDeviceConnectionStatusResponse: DeviceConnectionStatus {
    get {
      if case .getDeviceConnectionStatusResponse(let v)? = payloadVariant {return v}
      return DeviceConnectionStatus()
    }
    set {payloadVariant = .getDeviceConnectionStatusResponse(newValue)}
  }

  ///
  /// Setup a node for licensed amateur (ham) radio operation
  public var setHamMode: HamParameters {
    get {
      if case .setHamMode(let v)? = payloadVariant {return v}
      return HamParameters()
    }
    set {payloadVariant = .setHamMode(newValue)}
  }

  ///
  /// Get the mesh's nodes with their available gpio pins for RemoteHardware module use
  public var getNodeRemoteHardwarePinsRequest: Bool {
    get {
      if case .getNodeRemoteHardwarePinsRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getNodeRemoteHardwarePinsRequest(newValue)}
  }

  ///
  /// Respond with the mesh's nodes with their available gpio pins for RemoteHardware module use
  public var getNodeRemoteHardwarePinsResponse: NodeRemoteHardwarePinsResponse {
    get {
      if case .getNodeRemoteHardwarePinsResponse(let v)? = payloadVariant {return v}
      return NodeRemoteHardwarePinsResponse()
    }
    set {payloadVariant = .getNodeRemoteHardwarePinsResponse(newValue)}
  }

  ///
  /// Enter (UF2) DFU mode
  /// Only implemented on NRF52 currently
  public var enterDfuModeRequest: Bool {
    get {
      if case .enterDfuModeRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .enterDfuModeRequest(newValue)}
  }

  ///
  /// Delete the file by the specified path from the device
  public var deleteFileRequest: String {
    get {
      if case .deleteFileRequest(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .deleteFileRequest(newValue)}
  }

  ///
  /// Set zero and offset for scale chips
  public var setScale: UInt32 {
    get {
      if case .setScale(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .setScale(newValue)}
  }

  ///
  /// Set the owner for this node
  public var setOwner: User {
    get {
      if case .setOwner(let v)? = payloadVariant {return v}
      return User()
    }
    set {payloadVariant = .setOwner(newValue)}
  }

  ///
  /// Set channels (using the new API).
  /// A special channel is the "primary channel".
  /// The other records are secondary channels.
  /// Note: only one channel can be marked as primary.
  /// If the client sets a particular channel to be primary, the previous channel will be set to SECONDARY automatically.
  public var setChannel: Channel {
    get {
      if case .setChannel(let v)? = payloadVariant {return v}
      return Channel()
    }
    set {payloadVariant = .setChannel(newValue)}
  }

  ///
  /// Set the current Config
  public var setConfig: Config {
    get {
      if case .setConfig(let v)? = payloadVariant {return v}
      return Config()
    }
    set {payloadVariant = .setConfig(newValue)}
  }

  ///
  /// Set the current Config
  public var setModuleConfig: ModuleConfig {
    get {
      if case .setModuleConfig(let v)? = payloadVariant {return v}
      return ModuleConfig()
    }
    set {payloadVariant = .setModuleConfig(newValue)}
  }

  ///
  /// Set the Canned Message Module messages text.
  public var setCannedMessageModuleMessages: String {
    get {
      if case .setCannedMessageModuleMessages(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .setCannedMessageModuleMessages(newValue)}
  }

  ///
  /// Set the ringtone for ExternalNotification.
  public var setRingtoneMessage: String {
    get {
      if case .setRingtoneMessage(let v)? = payloadVariant {return v}
      return String()
    }
    set {payloadVariant = .setRingtoneMessage(newValue)}
  }

  ///
  /// Remove the node by the specified node-num from the NodeDB on the device
  public var removeByNodenum: UInt32 {
    get {
      if case .removeByNodenum(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .removeByNodenum(newValue)}
  }

  ///
  /// Set specified node-num to be favorited on the NodeDB on the device
  public var setFavoriteNode: UInt32 {
    get {
      if case .setFavoriteNode(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .setFavoriteNode(newValue)}
  }

  ///
  /// Set specified node-num to be un-favorited on the NodeDB on the device
  public var removeFavoriteNode: UInt32 {
    get {
      if case .removeFavoriteNode(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .removeFavoriteNode(newValue)}
  }

  ///
  /// Set fixed position data on the node and then set the position.fixed_position = true
  public var setFixedPosition: Position {
    get {
      if case .setFixedPosition(let v)? = payloadVariant {return v}
      return Position()
    }
    set {payloadVariant = .setFixedPosition(newValue)}
  }

  ///
  /// Clear fixed position coordinates and then set position.fixed_position = false
  public var removeFixedPosition: Bool {
    get {
      if case .removeFixedPosition(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .removeFixedPosition(newValue)}
  }

  ///
  /// Set time only on the node
  /// Convenience method to set the time on the node (as Net quality) without any other position data
  public var setTimeOnly: UInt32 {
    get {
      if case .setTimeOnly(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .setTimeOnly(newValue)}
  }

  ///
  /// Tell the node to send the stored ui data.
  public var getUiConfigRequest: Bool {
    get {
      if case .getUiConfigRequest(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .getUiConfigRequest(newValue)}
  }

  ///
  /// Reply stored device ui data.
  public var getUiConfigResponse: DeviceUIConfig {
    get {
      if case .getUiConfigResponse(let v)? = payloadVariant {return v}
      return DeviceUIConfig()
    }
    set {payloadVariant = .getUiConfigResponse(newValue)}
  }

  ///
  /// Tell the node to store UI data persistently.
  public var storeUiConfig: DeviceUIConfig {
    get {
      if case .storeUiConfig(let v)? = payloadVariant {return v}
      return DeviceUIConfig()
    }
    set {payloadVariant = .storeUiConfig(newValue)}
  }

  ///
  /// Set specified node-num to be ignored on the NodeDB on the device
  public var setIgnoredNode: UInt32 {
    get {
      if case .setIgnoredNode(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .setIgnoredNode(newValue)}
  }

  ///
  /// Set specified node-num to be un-ignored on the NodeDB on the device
  public var removeIgnoredNode: UInt32 {
    get {
      if case .removeIgnoredNode(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .removeIgnoredNode(newValue)}
  }

  ///
  /// Begins an edit transaction for config, module config, owner, and channel settings changes
  /// This will delay the standard *implicit* save to the file system and subsequent reboot behavior until committed (commit_edit_settings)
  public var beginEditSettings: Bool {
    get {
      if case .beginEditSettings(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .beginEditSettings(newValue)}
  }

  ///
  /// Commits an open transaction for any edits made to config, module config, owner, and channel settings
  public var commitEditSettings: Bool {
    get {
      if case .commitEditSettings(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .commitEditSettings(newValue)}
  }

  ///
  /// Tell the node to factory reset config everything; all device state and configuration will be returned to factory defaults and BLE bonds will be cleared.
  public var factoryResetDevice: Int32 {
    get {
      if case .factoryResetDevice(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .factoryResetDevice(newValue)}
  }

  ///
  /// Tell the node to reboot into the OTA Firmware in this many seconds (or <0 to cancel reboot)
  /// Only Implemented for ESP32 Devices. This needs to be issued to send a new main firmware via bluetooth.
  public var rebootOtaSeconds: Int32 {
    get {
      if case .rebootOtaSeconds(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .rebootOtaSeconds(newValue)}
  }

  ///
  /// This message is only supported for the simulator Portduino build.
  /// If received the simulator will exit successfully.
  public var exitSimulator: Bool {
    get {
      if case .exitSimulator(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .exitSimulator(newValue)}
  }

  ///
  /// Tell the node to reboot in this many seconds (or <0 to cancel reboot)
  public var rebootSeconds: Int32 {
    get {
      if case .rebootSeconds(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .rebootSeconds(newValue)}
  }

  ///
  /// Tell the node to shutdown in this many seconds (or <0 to cancel shutdown)
  public var shutdownSeconds: Int32 {
    get {
      if case .shutdownSeconds(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .shutdownSeconds(newValue)}
  }

  ///
  /// Tell the node to factory reset config; all device state and configuration will be returned to factory defaults; BLE bonds will be preserved.
  public var factoryResetConfig: Int32 {
    get {
      if case .factoryResetConfig(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .factoryResetConfig(newValue)}
  }

  ///
  /// Tell the node to reset the nodedb.
  public var nodedbReset: Int32 {
    get {
      if case .nodedbReset(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .nodedbReset(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// TODO: REPLACE
  public enum OneOf_PayloadVariant: Equatable, Sendable {
    ///
    /// Send the specified channel in the response to this message
    /// NOTE: This field is sent with the channel index + 1 (to ensure we never try to send 'zero' - which protobufs treats as not present)
    case getChannelRequest(UInt32)
    ///
    /// TODO: REPLACE
    case getChannelResponse(Channel)
    ///
    /// Send the current owner data in the response to this message.
    case getOwnerRequest(Bool)
    ///
    /// TODO: REPLACE
    case getOwnerResponse(User)
    ///
    /// Ask for the following config data to be sent
    case getConfigRequest(AdminMessage.ConfigType)
    ///
    /// Send the current Config in the response to this message.
    case getConfigResponse(Config)
    ///
    /// Ask for the following config data to be sent
    case getModuleConfigRequest(AdminMessage.ModuleConfigType)
    ///
    /// Send the current Config in the response to this message.
    case getModuleConfigResponse(ModuleConfig)
    ///
    /// Get the Canned Message Module messages in the response to this message.
    case getCannedMessageModuleMessagesRequest(Bool)
    ///
    /// Get the Canned Message Module messages in the response to this message.
    case getCannedMessageModuleMessagesResponse(String)
    ///
    /// Request the node to send device metadata (firmware, protobuf version, etc)
    case getDeviceMetadataRequest(Bool)
    ///
    /// Device metadata response
    case getDeviceMetadataResponse(DeviceMetadata)
    ///
    /// Get the Ringtone in the response to this message.
    case getRingtoneRequest(Bool)
    ///
    /// Get the Ringtone in the response to this message.
    case getRingtoneResponse(String)
    ///
    /// Request the node to send it's connection status
    case getDeviceConnectionStatusRequest(Bool)
    ///
    /// Device connection status response
    case getDeviceConnectionStatusResponse(DeviceConnectionStatus)
    ///
    /// Setup a node for licensed amateur (ham) radio operation
    case setHamMode(HamParameters)
    ///
    /// Get the mesh's nodes with their available gpio pins for RemoteHardware module use
    case getNodeRemoteHardwarePinsRequest(Bool)
    ///
    /// Respond with the mesh's nodes with their available gpio pins for RemoteHardware module use
    case getNodeRemoteHardwarePinsResponse(NodeRemoteHardwarePinsResponse)
    ///
    /// Enter (UF2) DFU mode
    /// Only implemented on NRF52 currently
    case enterDfuModeRequest(Bool)
    ///
    /// Delete the file by the specified path from the device
    case deleteFileRequest(String)
    ///
    /// Set zero and offset for scale chips
    case setScale(UInt32)
    ///
    /// Set the owner for this node
    case setOwner(User)
    ///
    /// Set channels (using the new API).
    /// A special channel is the "primary channel".
    /// The other records are secondary channels.
    /// Note: only one channel can be marked as primary.
    /// If the client sets a particular channel to be primary, the previous channel will be set to SECONDARY automatically.
    case setChannel(Channel)
    ///
    /// Set the current Config
    case setConfig(Config)
    ///
    /// Set the current Config
    case setModuleConfig(ModuleConfig)
    ///
    /// Set the Canned Message Module messages text.
    case setCannedMessageModuleMessages(String)
    ///
    /// Set the ringtone for ExternalNotification.
    case setRingtoneMessage(String)
    ///
    /// Remove the node by the specified node-num from the NodeDB on the device
    case removeByNodenum(UInt32)
    ///
    /// Set specified node-num to be favorited on the NodeDB on the device
    case setFavoriteNode(UInt32)
    ///
    /// Set specified node-num to be un-favorited on the NodeDB on the device
    case removeFavoriteNode(UInt32)
    ///
    /// Set fixed position data on the node and then set the position.fixed_position = true
    case setFixedPosition(Position)
    ///
    /// Clear fixed position coordinates and then set position.fixed_position = false
    case removeFixedPosition(Bool)
    ///
    /// Set time only on the node
    /// Convenience method to set the time on the node (as Net quality) without any other position data
    case setTimeOnly(UInt32)
    ///
    /// Tell the node to send the stored ui data.
    case getUiConfigRequest(Bool)
    ///
    /// Reply stored device ui data.
    case getUiConfigResponse(DeviceUIConfig)
    ///
    /// Tell the node to store UI data persistently.
    case storeUiConfig(DeviceUIConfig)
    ///
    /// Set specified node-num to be ignored on the NodeDB on the device
    case setIgnoredNode(UInt32)
    ///
    /// Set specified node-num to be un-ignored on the NodeDB on the device
    case removeIgnoredNode(UInt32)
    ///
    /// Begins an edit transaction for config, module config, owner, and channel settings changes
    /// This will delay the standard *implicit* save to the file system and subsequent reboot behavior until committed (commit_edit_settings)
    case beginEditSettings(Bool)
    ///
    /// Commits an open transaction for any edits made to config, module config, owner, and channel settings
    case commitEditSettings(Bool)
    ///
    /// Tell the node to factory reset config everything; all device state and configuration will be returned to factory defaults and BLE bonds will be cleared.
    case factoryResetDevice(Int32)
    ///
    /// Tell the node to reboot into the OTA Firmware in this many seconds (or <0 to cancel reboot)
    /// Only Implemented for ESP32 Devices. This needs to be issued to send a new main firmware via bluetooth.
    case rebootOtaSeconds(Int32)
    ///
    /// This message is only supported for the simulator Portduino build.
    /// If received the simulator will exit successfully.
    case exitSimulator(Bool)
    ///
    /// Tell the node to reboot in this many seconds (or <0 to cancel reboot)
    case rebootSeconds(Int32)
    ///
    /// Tell the node to shutdown in this many seconds (or <0 to cancel shutdown)
    case shutdownSeconds(Int32)
    ///
    /// Tell the node to factory reset config; all device state and configuration will be returned to factory defaults; BLE bonds will be preserved.
    case factoryResetConfig(Int32)
    ///
    /// Tell the node to reset the nodedb.
    case nodedbReset(Int32)

  }

  ///
  /// TODO: REPLACE
  public enum ConfigType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case deviceConfig // = 0

    ///
    /// TODO: REPLACE
    case positionConfig // = 1

    ///
    /// TODO: REPLACE
    case powerConfig // = 2

    ///
    /// TODO: REPLACE
    case networkConfig // = 3

    ///
    /// TODO: REPLACE
    case displayConfig // = 4

    ///
    /// TODO: REPLACE
    case loraConfig // = 5

    ///
    /// TODO: REPLACE
    case bluetoothConfig // = 6

    ///
    /// TODO: REPLACE
    case securityConfig // = 7
    case sessionkeyConfig // = 8

    ///
    /// device-ui config
    case deviceuiConfig // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .deviceConfig
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .deviceConfig
      case 1: self = .positionConfig
      case 2: self = .powerConfig
      case 3: self = .networkConfig
      case 4: self = .displayConfig
      case 5: self = .loraConfig
      case 6: self = .bluetoothConfig
      case 7: self = .securityConfig
      case 8: self = .sessionkeyConfig
      case 9: self = .deviceuiConfig
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .deviceConfig: return 0
      case .positionConfig: return 1
      case .powerConfig: return 2
      case .networkConfig: return 3
      case .displayConfig: return 4
      case .loraConfig: return 5
      case .bluetoothConfig: return 6
      case .securityConfig: return 7
      case .sessionkeyConfig: return 8
      case .deviceuiConfig: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [AdminMessage.ConfigType] = [
      .deviceConfig,
      .positionConfig,
      .powerConfig,
      .networkConfig,
      .displayConfig,
      .loraConfig,
      .bluetoothConfig,
      .securityConfig,
      .sessionkeyConfig,
      .deviceuiConfig,
    ]

  }

  ///
  /// TODO: REPLACE
  public enum ModuleConfigType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case mqttConfig // = 0

    ///
    /// TODO: REPLACE
    case serialConfig // = 1

    ///
    /// TODO: REPLACE
    case extnotifConfig // = 2

    ///
    /// TODO: REPLACE
    case storeforwardConfig // = 3

    ///
    /// TODO: REPLACE
    case rangetestConfig // = 4

    ///
    /// TODO: REPLACE
    case telemetryConfig // = 5

    ///
    /// TODO: REPLACE
    case cannedmsgConfig // = 6

    ///
    /// TODO: REPLACE
    case audioConfig // = 7

    ///
    /// TODO: REPLACE
    case remotehardwareConfig // = 8

    ///
    /// TODO: REPLACE
    case neighborinfoConfig // = 9

    ///
    /// TODO: REPLACE
    case ambientlightingConfig // = 10

    ///
    /// TODO: REPLACE
    case detectionsensorConfig // = 11

    ///
    /// TODO: REPLACE
    case paxcounterConfig // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .mqttConfig
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mqttConfig
      case 1: self = .serialConfig
      case 2: self = .extnotifConfig
      case 3: self = .storeforwardConfig
      case 4: self = .rangetestConfig
      case 5: self = .telemetryConfig
      case 6: self = .cannedmsgConfig
      case 7: self = .audioConfig
      case 8: self = .remotehardwareConfig
      case 9: self = .neighborinfoConfig
      case 10: self = .ambientlightingConfig
      case 11: self = .detectionsensorConfig
      case 12: self = .paxcounterConfig
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .mqttConfig: return 0
      case .serialConfig: return 1
      case .extnotifConfig: return 2
      case .storeforwardConfig: return 3
      case .rangetestConfig: return 4
      case .telemetryConfig: return 5
      case .cannedmsgConfig: return 6
      case .audioConfig: return 7
      case .remotehardwareConfig: return 8
      case .neighborinfoConfig: return 9
      case .ambientlightingConfig: return 10
      case .detectionsensorConfig: return 11
      case .paxcounterConfig: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [AdminMessage.ModuleConfigType] = [
      .mqttConfig,
      .serialConfig,
      .extnotifConfig,
      .storeforwardConfig,
      .rangetestConfig,
      .telemetryConfig,
      .cannedmsgConfig,
      .audioConfig,
      .remotehardwareConfig,
      .neighborinfoConfig,
      .ambientlightingConfig,
      .detectionsensorConfig,
      .paxcounterConfig,
    ]

  }

  public init() {}
}

///
/// Parameters for setting up Meshtastic for ameteur radio usage
public struct HamParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Amateur radio call sign, eg. KD2ABC
  public var callSign: String = String()

  ///
  /// Transmit power in dBm at the LoRA transceiver, not including any amplification
  public var txPower: Int32 = 0

  ///
  /// The selected frequency of LoRA operation
  /// Please respect your local laws, regulations, and band plans.
  /// Ensure your radio is capable of operating of the selected frequency before setting this.
  public var frequency: Float = 0

  ///
  /// Optional short name of user
  public var shortName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Response envelope for node_remote_hardware_pins
public struct NodeRemoteHardwarePinsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Nodes and their respective remote hardware GPIO pins
  public var nodeRemoteHardwarePins: [NodeRemoteHardwarePin] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension AdminMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "session_passkey"),
    1: .standard(proto: "get_channel_request"),
    2: .standard(proto: "get_channel_response"),
    3: .standard(proto: "get_owner_request"),
    4: .standard(proto: "get_owner_response"),
    5: .standard(proto: "get_config_request"),
    6: .standard(proto: "get_config_response"),
    7: .standard(proto: "get_module_config_request"),
    8: .standard(proto: "get_module_config_response"),
    10: .standard(proto: "get_canned_message_module_messages_request"),
    11: .standard(proto: "get_canned_message_module_messages_response"),
    12: .standard(proto: "get_device_metadata_request"),
    13: .standard(proto: "get_device_metadata_response"),
    14: .standard(proto: "get_ringtone_request"),
    15: .standard(proto: "get_ringtone_response"),
    16: .standard(proto: "get_device_connection_status_request"),
    17: .standard(proto: "get_device_connection_status_response"),
    18: .standard(proto: "set_ham_mode"),
    19: .standard(proto: "get_node_remote_hardware_pins_request"),
    20: .standard(proto: "get_node_remote_hardware_pins_response"),
    21: .standard(proto: "enter_dfu_mode_request"),
    22: .standard(proto: "delete_file_request"),
    23: .standard(proto: "set_scale"),
    32: .standard(proto: "set_owner"),
    33: .standard(proto: "set_channel"),
    34: .standard(proto: "set_config"),
    35: .standard(proto: "set_module_config"),
    36: .standard(proto: "set_canned_message_module_messages"),
    37: .standard(proto: "set_ringtone_message"),
    38: .standard(proto: "remove_by_nodenum"),
    39: .standard(proto: "set_favorite_node"),
    40: .standard(proto: "remove_favorite_node"),
    41: .standard(proto: "set_fixed_position"),
    42: .standard(proto: "remove_fixed_position"),
    43: .standard(proto: "set_time_only"),
    44: .standard(proto: "get_ui_config_request"),
    45: .standard(proto: "get_ui_config_response"),
    46: .standard(proto: "store_ui_config"),
    47: .standard(proto: "set_ignored_node"),
    48: .standard(proto: "remove_ignored_node"),
    64: .standard(proto: "begin_edit_settings"),
    65: .standard(proto: "commit_edit_settings"),
    94: .standard(proto: "factory_reset_device"),
    95: .standard(proto: "reboot_ota_seconds"),
    96: .standard(proto: "exit_simulator"),
    97: .standard(proto: "reboot_seconds"),
    98: .standard(proto: "shutdown_seconds"),
    99: .standard(proto: "factory_reset_config"),
    100: .standard(proto: "nodedb_reset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getChannelRequest(v)
        }
      }()
      case 2: try {
        var v: Channel?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getChannelResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getChannelResponse(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getOwnerRequest(v)
        }
      }()
      case 4: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getOwnerResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getOwnerResponse(v)
        }
      }()
      case 5: try {
        var v: AdminMessage.ConfigType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getConfigRequest(v)
        }
      }()
      case 6: try {
        var v: Config?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getConfigResponse(v)
        }
      }()
      case 7: try {
        var v: AdminMessage.ModuleConfigType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getModuleConfigRequest(v)
        }
      }()
      case 8: try {
        var v: ModuleConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getModuleConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getModuleConfigResponse(v)
        }
      }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getCannedMessageModuleMessagesRequest(v)
        }
      }()
      case 11: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getCannedMessageModuleMessagesResponse(v)
        }
      }()
      case 12: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getDeviceMetadataRequest(v)
        }
      }()
      case 13: try {
        var v: DeviceMetadata?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getDeviceMetadataResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getDeviceMetadataResponse(v)
        }
      }()
      case 14: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getRingtoneRequest(v)
        }
      }()
      case 15: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getRingtoneResponse(v)
        }
      }()
      case 16: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getDeviceConnectionStatusRequest(v)
        }
      }()
      case 17: try {
        var v: DeviceConnectionStatus?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getDeviceConnectionStatusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getDeviceConnectionStatusResponse(v)
        }
      }()
      case 18: try {
        var v: HamParameters?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setHamMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setHamMode(v)
        }
      }()
      case 19: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getNodeRemoteHardwarePinsRequest(v)
        }
      }()
      case 20: try {
        var v: NodeRemoteHardwarePinsResponse?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getNodeRemoteHardwarePinsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getNodeRemoteHardwarePinsResponse(v)
        }
      }()
      case 21: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .enterDfuModeRequest(v)
        }
      }()
      case 22: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .deleteFileRequest(v)
        }
      }()
      case 23: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setScale(v)
        }
      }()
      case 32: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setOwner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setOwner(v)
        }
      }()
      case 33: try {
        var v: Channel?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setChannel(v)
        }
      }()
      case 34: try {
        var v: Config?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setConfig(v)
        }
      }()
      case 35: try {
        var v: ModuleConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setModuleConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setModuleConfig(v)
        }
      }()
      case 36: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setCannedMessageModuleMessages(v)
        }
      }()
      case 37: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setRingtoneMessage(v)
        }
      }()
      case 38: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .removeByNodenum(v)
        }
      }()
      case 39: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setFavoriteNode(v)
        }
      }()
      case 40: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .removeFavoriteNode(v)
        }
      }()
      case 41: try {
        var v: Position?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .setFixedPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setFixedPosition(v)
        }
      }()
      case 42: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .removeFixedPosition(v)
        }
      }()
      case 43: try {
        var v: UInt32?
        try decoder.decodeSingularFixed32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setTimeOnly(v)
        }
      }()
      case 44: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getUiConfigRequest(v)
        }
      }()
      case 45: try {
        var v: DeviceUIConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .getUiConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .getUiConfigResponse(v)
        }
      }()
      case 46: try {
        var v: DeviceUIConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .storeUiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .storeUiConfig(v)
        }
      }()
      case 47: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .setIgnoredNode(v)
        }
      }()
      case 48: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .removeIgnoredNode(v)
        }
      }()
      case 64: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .beginEditSettings(v)
        }
      }()
      case 65: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .commitEditSettings(v)
        }
      }()
      case 94: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .factoryResetDevice(v)
        }
      }()
      case 95: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rebootOtaSeconds(v)
        }
      }()
      case 96: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .exitSimulator(v)
        }
      }()
      case 97: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rebootSeconds(v)
        }
      }()
      case 98: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .shutdownSeconds(v)
        }
      }()
      case 99: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .factoryResetConfig(v)
        }
      }()
      case 100: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .nodedbReset(v)
        }
      }()
      case 101: try { try decoder.decodeSingularBytesField(value: &self.sessionPasskey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .getChannelRequest?: try {
      guard case .getChannelRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .getChannelResponse?: try {
      guard case .getChannelResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getOwnerRequest?: try {
      guard case .getOwnerRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .getOwnerResponse?: try {
      guard case .getOwnerResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getConfigRequest?: try {
      guard case .getConfigRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case .getConfigResponse?: try {
      guard case .getConfigResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getModuleConfigRequest?: try {
      guard case .getModuleConfigRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }()
    case .getModuleConfigResponse?: try {
      guard case .getModuleConfigResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .getCannedMessageModuleMessagesRequest?: try {
      guard case .getCannedMessageModuleMessagesRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }()
    case .getCannedMessageModuleMessagesResponse?: try {
      guard case .getCannedMessageModuleMessagesResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }()
    case .getDeviceMetadataRequest?: try {
      guard case .getDeviceMetadataRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }()
    case .getDeviceMetadataResponse?: try {
      guard case .getDeviceMetadataResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .getRingtoneRequest?: try {
      guard case .getRingtoneRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    }()
    case .getRingtoneResponse?: try {
      guard case .getRingtoneResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    }()
    case .getDeviceConnectionStatusRequest?: try {
      guard case .getDeviceConnectionStatusRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }()
    case .getDeviceConnectionStatusResponse?: try {
      guard case .getDeviceConnectionStatusResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .setHamMode?: try {
      guard case .setHamMode(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .getNodeRemoteHardwarePinsRequest?: try {
      guard case .getNodeRemoteHardwarePinsRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
    }()
    case .getNodeRemoteHardwarePinsResponse?: try {
      guard case .getNodeRemoteHardwarePinsResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .enterDfuModeRequest?: try {
      guard case .enterDfuModeRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
    }()
    case .deleteFileRequest?: try {
      guard case .deleteFileRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 22)
    }()
    case .setScale?: try {
      guard case .setScale(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
    }()
    case .setOwner?: try {
      guard case .setOwner(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .setChannel?: try {
      guard case .setChannel(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .setConfig?: try {
      guard case .setConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .setModuleConfig?: try {
      guard case .setModuleConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .setCannedMessageModuleMessages?: try {
      guard case .setCannedMessageModuleMessages(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 36)
    }()
    case .setRingtoneMessage?: try {
      guard case .setRingtoneMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 37)
    }()
    case .removeByNodenum?: try {
      guard case .removeByNodenum(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 38)
    }()
    case .setFavoriteNode?: try {
      guard case .setFavoriteNode(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 39)
    }()
    case .removeFavoriteNode?: try {
      guard case .removeFavoriteNode(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 40)
    }()
    case .setFixedPosition?: try {
      guard case .setFixedPosition(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .removeFixedPosition?: try {
      guard case .removeFixedPosition(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 42)
    }()
    case .setTimeOnly?: try {
      guard case .setTimeOnly(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 43)
    }()
    case .getUiConfigRequest?: try {
      guard case .getUiConfigRequest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 44)
    }()
    case .getUiConfigResponse?: try {
      guard case .getUiConfigResponse(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .storeUiConfig?: try {
      guard case .storeUiConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .setIgnoredNode?: try {
      guard case .setIgnoredNode(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 47)
    }()
    case .removeIgnoredNode?: try {
      guard case .removeIgnoredNode(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 48)
    }()
    case .beginEditSettings?: try {
      guard case .beginEditSettings(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 64)
    }()
    case .commitEditSettings?: try {
      guard case .commitEditSettings(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 65)
    }()
    case .factoryResetDevice?: try {
      guard case .factoryResetDevice(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 94)
    }()
    case .rebootOtaSeconds?: try {
      guard case .rebootOtaSeconds(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 95)
    }()
    case .exitSimulator?: try {
      guard case .exitSimulator(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 96)
    }()
    case .rebootSeconds?: try {
      guard case .rebootSeconds(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 97)
    }()
    case .shutdownSeconds?: try {
      guard case .shutdownSeconds(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 98)
    }()
    case .factoryResetConfig?: try {
      guard case .factoryResetConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 99)
    }()
    case .nodedbReset?: try {
      guard case .nodedbReset(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 100)
    }()
    case nil: break
    }
    if !self.sessionPasskey.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionPasskey, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AdminMessage, rhs: AdminMessage) -> Bool {
    if lhs.sessionPasskey != rhs.sessionPasskey {return false}
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AdminMessage.ConfigType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_CONFIG"),
    1: .same(proto: "POSITION_CONFIG"),
    2: .same(proto: "POWER_CONFIG"),
    3: .same(proto: "NETWORK_CONFIG"),
    4: .same(proto: "DISPLAY_CONFIG"),
    5: .same(proto: "LORA_CONFIG"),
    6: .same(proto: "BLUETOOTH_CONFIG"),
    7: .same(proto: "SECURITY_CONFIG"),
    8: .same(proto: "SESSIONKEY_CONFIG"),
    9: .same(proto: "DEVICEUI_CONFIG"),
  ]
}

extension AdminMessage.ModuleConfigType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MQTT_CONFIG"),
    1: .same(proto: "SERIAL_CONFIG"),
    2: .same(proto: "EXTNOTIF_CONFIG"),
    3: .same(proto: "STOREFORWARD_CONFIG"),
    4: .same(proto: "RANGETEST_CONFIG"),
    5: .same(proto: "TELEMETRY_CONFIG"),
    6: .same(proto: "CANNEDMSG_CONFIG"),
    7: .same(proto: "AUDIO_CONFIG"),
    8: .same(proto: "REMOTEHARDWARE_CONFIG"),
    9: .same(proto: "NEIGHBORINFO_CONFIG"),
    10: .same(proto: "AMBIENTLIGHTING_CONFIG"),
    11: .same(proto: "DETECTIONSENSOR_CONFIG"),
    12: .same(proto: "PAXCOUNTER_CONFIG"),
  ]
}

extension HamParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HamParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_sign"),
    2: .standard(proto: "tx_power"),
    3: .same(proto: "frequency"),
    4: .standard(proto: "short_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callSign) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.txPower) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.frequency) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callSign.isEmpty {
      try visitor.visitSingularStringField(value: self.callSign, fieldNumber: 1)
    }
    if self.txPower != 0 {
      try visitor.visitSingularInt32Field(value: self.txPower, fieldNumber: 2)
    }
    if self.frequency.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.frequency, fieldNumber: 3)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HamParameters, rhs: HamParameters) -> Bool {
    if lhs.callSign != rhs.callSign {return false}
    if lhs.txPower != rhs.txPower {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeRemoteHardwarePinsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeRemoteHardwarePinsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_remote_hardware_pins"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeRemoteHardwarePins) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeRemoteHardwarePins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeRemoteHardwarePins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeRemoteHardwarePinsResponse, rhs: NodeRemoteHardwarePinsResponse) -> Bool {
    if lhs.nodeRemoteHardwarePins != rhs.nodeRemoteHardwarePins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
